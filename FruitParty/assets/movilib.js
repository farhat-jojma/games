! function(t) {
    var e;
    "object" == typeof exports ? module.exports = t() : ("undefined" != typeof window ? e = window : "undefined" != typeof global ? e = global : "undefined" != typeof self && (e = self), e.p2 = t())
}(function() {
    return function t(e, i, n) {
        function s(o, a) {
            if (!i[o]) {
                if (!e[o]) {
                    var h = "function" == typeof require && require;
                    if (!a && h) return h(o, !0);
                    if (r) return r(o, !0);
                    throw new Error("Cannot find module '" + o + "'")
                }
                var l = i[o] = {
                    exports: {}
                };
                e[o][0].call(l.exports, function(t) {
                    var i = e[o][1][t];
                    return s(i || t)
                }, l, l.exports, t, e, i, n)
            }
            return i[o].exports
        }
        for (var r = "function" == typeof require && require, o = 0; o < n.length; o++) s(n[o]);
        return s
    }({
        1: [function(t, e, i) {
            var n = t("./Scalar");

            function s() {}
            e.exports = s, s.lineInt = function(t, e, i) {
                i = i || 0;
                var s, r, o, a, h, l, c, u = [0, 0];
                return s = t[1][1] - t[0][1], r = t[0][0] - t[1][0], o = s * t[0][0] + r * t[0][1], a = e[1][1] - e[0][1], h = e[0][0] - e[1][0], l = a * e[0][0] + h * e[0][1], c = s * h - a * r, n.eq(c, 0, i) || (u[0] = (h * o - r * l) / c, u[1] = (s * l - a * o) / c), u
            }, s.segmentsIntersect = function(t, e, i, n) {
                var s = e[0] - t[0],
                    r = e[1] - t[1],
                    o = n[0] - i[0],
                    a = n[1] - i[1];
                if (o * r - a * s == 0) return !1;
                var h = (s * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * s),
                    l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * s - o * r);
                return h >= 0 && h <= 1 && l >= 0 && l <= 1
            }
        }, {
            "./Scalar": 4
        }],
        2: [function(t, e, i) {
            function n() {}
            e.exports = n, n.area = function(t, e, i) {
                return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])
            }, n.left = function(t, e, i) {
                return n.area(t, e, i) > 0
            }, n.leftOn = function(t, e, i) {
                return n.area(t, e, i) >= 0
            }, n.right = function(t, e, i) {
                return n.area(t, e, i) < 0
            }, n.rightOn = function(t, e, i) {
                return n.area(t, e, i) <= 0
            };
            var s = [],
                r = [];
            n.collinear = function(t, e, i, o) {
                if (o) {
                    var a = s,
                        h = r;
                    a[0] = e[0] - t[0], a[1] = e[1] - t[1], h[0] = i[0] - e[0], h[1] = i[1] - e[1];
                    var l = a[0] * h[0] + a[1] * h[1],
                        c = Math.sqrt(a[0] * a[0] + a[1] * a[1]),
                        u = Math.sqrt(h[0] * h[0] + h[1] * h[1]);
                    return Math.acos(l / (c * u)) < o
                }
                return 0 == n.area(t, e, i)
            }, n.sqdist = function(t, e) {
                var i = e[0] - t[0],
                    n = e[1] - t[1];
                return i * i + n * n
            }
        }, {}],
        3: [function(t, e, i) {
            var n = t("./Line"),
                s = t("./Point"),
                r = t("./Scalar");

            function o() {
                this.vertices = []
            }
            e.exports = o, o.prototype.at = function(t) {
                var e = this.vertices,
                    i = e.length;
                return e[t < 0 ? t % i + i : t % i]
            }, o.prototype.first = function() {
                return this.vertices[0]
            }, o.prototype.last = function() {
                return this.vertices[this.vertices.length - 1]
            }, o.prototype.clear = function() {
                this.vertices.length = 0
            }, o.prototype.append = function(t, e, i) {
                if (void 0 === e) throw new Error("From is not given!");
                if (void 0 === i) throw new Error("To is not given!");
                if (i - 1 < e) throw new Error("lol1");
                if (i > t.vertices.length) throw new Error("lol2");
                if (e < 0) throw new Error("lol3");
                for (var n = e; n < i; n++) this.vertices.push(t.vertices[n])
            }, o.prototype.makeCCW = function() {
                for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                s.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
            }, o.prototype.reverse = function() {
                for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                this.vertices = t
            }, o.prototype.isReflex = function(t) {
                return s.right(this.at(t - 1), this.at(t), this.at(t + 1))
            };
            var a = [],
                h = [];

            function l(t, e, i, n, s) {
                s = s || 0;
                var o = e[1] - t[1],
                    a = t[0] - e[0],
                    h = o * t[0] + a * t[1],
                    l = n[1] - i[1],
                    c = i[0] - n[0],
                    u = l * i[0] + c * i[1],
                    d = o * c - l * a;
                return r.eq(d, 0, s) ? [0, 0] : [(c * h - a * u) / d, (o * u - l * h) / d]
            }
            o.prototype.canSee = function(t, e) {
                var i, r, o = a,
                    l = h;
                if (s.leftOn(this.at(t + 1), this.at(t), this.at(e)) && s.rightOn(this.at(t - 1), this.at(t), this.at(e))) return !1;
                r = s.sqdist(this.at(t), this.at(e));
                for (var c = 0; c !== this.vertices.length; ++c)
                    if ((c + 1) % this.vertices.length !== t && c !== t && s.leftOn(this.at(t), this.at(e), this.at(c + 1)) && s.rightOn(this.at(t), this.at(e), this.at(c)) && (o[0] = this.at(t), o[1] = this.at(e), l[0] = this.at(c), l[1] = this.at(c + 1), i = n.lineInt(o, l), s.sqdist(this.at(t), i) < r)) return !1;
                return !0
            }, o.prototype.copy = function(t, e, i) {
                var n = i || new o;
                if (n.clear(), t < e)
                    for (var s = t; s <= e; s++) n.vertices.push(this.vertices[s]);
                else {
                    for (s = 0; s <= e; s++) n.vertices.push(this.vertices[s]);
                    for (s = t; s < this.vertices.length; s++) n.vertices.push(this.vertices[s])
                }
                return n
            }, o.prototype.getCutEdges = function() {
                for (var t = [], e = [], i = [], n = new o, s = Number.MAX_VALUE, r = 0; r < this.vertices.length; ++r)
                    if (this.isReflex(r))
                        for (var a = 0; a < this.vertices.length; ++a)
                            if (this.canSee(r, a)) {
                                e = this.copy(r, a, n).getCutEdges(), i = this.copy(a, r, n).getCutEdges();
                                for (var h = 0; h < i.length; h++) e.push(i[h]);
                                e.length < s && (t = e, s = e.length, t.push([this.at(r), this.at(a)]))
                            }
                return t
            }, o.prototype.decomp = function() {
                var t = this.getCutEdges();
                return t.length > 0 ? this.slice(t) : [this]
            }, o.prototype.slice = function(t) {
                if (0 == t.length) return [this];
                if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) {
                    for (var e = [this], i = 0; i < t.length; i++)
                        for (var n = t[i], s = 0; s < e.length; s++) {
                            var r = e[s].slice(n);
                            if (r) {
                                e.splice(s, 1), e.push(r[0], r[1]);
                                break
                            }
                        }
                    return e
                }
                n = t, i = this.vertices.indexOf(n[0]), s = this.vertices.indexOf(n[1]);
                return -1 != i && -1 != s && [this.copy(i, s), this.copy(s, i)]
            }, o.prototype.isSimple = function() {
                for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                    for (var i = 0; i < e - 1; i++)
                        if (n.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return !1;
                for (e = 1; e < t.length - 2; e++)
                    if (n.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return !1;
                return !0
            }, o.prototype.quickDecomp = function(t, e, i, n, r, a) {
                r = r || 100, a = a || 0, n = n || 25, t = void 0 !== t ? t : [], e = e || [], i = i || [];
                var h = [0, 0],
                    c = [0, 0],
                    u = [0, 0],
                    d = 0,
                    p = 0,
                    f = 0,
                    g = 0,
                    m = 0,
                    y = 0,
                    v = 0,
                    b = new o,
                    x = new o,
                    w = this.vertices;
                if (w.length < 3) return t;
                if (++a > r) return t;
                for (var _ = 0; _ < this.vertices.length; ++_)
                    if (this.isReflex(_)) {
                        e.push(this.vertices[_]), d = p = Number.MAX_VALUE;
                        for (var P = 0; P < this.vertices.length; ++P) s.left(this.at(_ - 1), this.at(_), this.at(P)) && s.rightOn(this.at(_ - 1), this.at(_), this.at(P - 1)) && (u = l(this.at(_ - 1), this.at(_), this.at(P), this.at(P - 1)), s.right(this.at(_ + 1), this.at(_), u) && (f = s.sqdist(this.vertices[_], u)) < p && (p = f, c = u, y = P)), s.left(this.at(_ + 1), this.at(_), this.at(P + 1)) && s.rightOn(this.at(_ + 1), this.at(_), this.at(P)) && (u = l(this.at(_ + 1), this.at(_), this.at(P), this.at(P + 1)), s.left(this.at(_ - 1), this.at(_), u) && (f = s.sqdist(this.vertices[_], u)) < d && (d = f, h = u, m = P));
                        if (y == (m + 1) % this.vertices.length) u[0] = (c[0] + h[0]) / 2, u[1] = (c[1] + h[1]) / 2, i.push(u), _ < m ? (b.append(this, _, m + 1), b.vertices.push(u), x.vertices.push(u), 0 != y && x.append(this, y, this.vertices.length), x.append(this, 0, _ + 1)) : (0 != _ && b.append(this, _, this.vertices.length), b.append(this, 0, m + 1), b.vertices.push(u), x.vertices.push(u), x.append(this, y, _ + 1));
                        else {
                            if (y > m && (m += this.vertices.length), g = Number.MAX_VALUE, m < y) return t;
                            for (P = y; P <= m; ++P) s.leftOn(this.at(_ - 1), this.at(_), this.at(P)) && s.rightOn(this.at(_ + 1), this.at(_), this.at(P)) && (f = s.sqdist(this.at(_), this.at(P))) < g && (g = f, v = P % this.vertices.length);
                            _ < v ? (b.append(this, _, v + 1), 0 != v && x.append(this, v, w.length), x.append(this, 0, _ + 1)) : (0 != _ && b.append(this, _, w.length), b.append(this, 0, v + 1), x.append(this, v, _ + 1))
                        }
                        return b.vertices.length < x.vertices.length ? (b.quickDecomp(t, e, i, n, r, a), x.quickDecomp(t, e, i, n, r, a)) : (x.quickDecomp(t, e, i, n, r, a), b.quickDecomp(t, e, i, n, r, a)), t
                    }
                return t.push(this), t
            }, o.prototype.removeCollinearPoints = function(t) {
                for (var e = 0, i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) s.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++);
                return e
            }
        }, {
            "./Line": 1,
            "./Point": 2,
            "./Scalar": 4
        }],
        4: [function(t, e, i) {
            function n() {}
            e.exports = n, n.eq = function(t, e, i) {
                return i = i || 0, Math.abs(t - e) < i
            }
        }, {}],
        5: [function(t, e, i) {
            e.exports = {
                Polygon: t("./Polygon"),
                Point: t("./Point")
            }
        }, {
            "./Point": 2,
            "./Polygon": 3
        }],
        6: [function(t, e, i) {
            e.exports = {
                name: "p2",
                version: "0.7.0",
                description: "A JavaScript 2D physics engine.",
                author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                main: "./src/p2.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/schteppe/p2.js.git"
                },
                bugs: {
                    url: "https://github.com/schteppe/p2.js/issues"
                },
                licenses: [{
                    type: "MIT"
                }],
                devDependencies: {
                    grunt: "^0.4.5",
                    "grunt-contrib-jshint": "^0.11.2",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-uglify": "~0.4.0",
                    "grunt-contrib-watch": "~0.5.0",
                    "grunt-browserify": "~2.0.1",
                    "grunt-contrib-concat": "^0.4.0"
                },
                dependencies: {
                    "poly-decomp": "0.1.0"
                }
            }
        }, {}],
        7: [function(t, e, i) {
            var n = t("../math/vec2");
            t("../utils/Utils");

            function s(t) {
                this.lowerBound = n.create(), t && t.lowerBound && n.copy(this.lowerBound, t.lowerBound), this.upperBound = n.create(), t && t.upperBound && n.copy(this.upperBound, t.upperBound)
            }
            e.exports = s;
            var r = n.create();
            s.prototype.setFromPoints = function(t, e, i, s) {
                var o = this.lowerBound,
                    a = this.upperBound;
                "number" != typeof i && (i = 0), 0 !== i ? n.rotate(o, t[0], i) : n.copy(o, t[0]), n.copy(a, o);
                for (var h = Math.cos(i), l = Math.sin(i), c = 1; c < t.length; c++) {
                    var u = t[c];
                    if (0 !== i) {
                        var d = u[0],
                            p = u[1];
                        r[0] = h * d - l * p, r[1] = l * d + h * p, u = r
                    }
                    for (var f = 0; f < 2; f++) u[f] > a[f] && (a[f] = u[f]), u[f] < o[f] && (o[f] = u[f])
                }
                e && (n.add(this.lowerBound, this.lowerBound, e), n.add(this.upperBound, this.upperBound, e)), s && (this.lowerBound[0] -= s, this.lowerBound[1] -= s, this.upperBound[0] += s, this.upperBound[1] += s)
            }, s.prototype.copy = function(t) {
                n.copy(this.lowerBound, t.lowerBound), n.copy(this.upperBound, t.upperBound)
            }, s.prototype.extend = function(t) {
                for (var e = 2; e--;) {
                    var i = t.lowerBound[e];
                    this.lowerBound[e] > i && (this.lowerBound[e] = i);
                    var n = t.upperBound[e];
                    this.upperBound[e] < n && (this.upperBound[e] = n)
                }
            }, s.prototype.overlaps = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound,
                    n = t.lowerBound,
                    s = t.upperBound;
                return (n[0] <= i[0] && i[0] <= s[0] || e[0] <= s[0] && s[0] <= i[0]) && (n[1] <= i[1] && i[1] <= s[1] || e[1] <= s[1] && s[1] <= i[1])
            }, s.prototype.containsPoint = function(t) {
                var e = this.lowerBound,
                    i = this.upperBound;
                return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1]
            }, s.prototype.overlapsRay = function(t) {
                var e = 1 / t.direction[0],
                    i = 1 / t.direction[1],
                    n = (this.lowerBound[0] - t.from[0]) * e,
                    s = (this.upperBound[0] - t.from[0]) * e,
                    r = (this.lowerBound[1] - t.from[1]) * i,
                    o = (this.upperBound[1] - t.from[1]) * i,
                    a = Math.max(Math.max(Math.min(n, s), Math.min(r, o))),
                    h = Math.min(Math.min(Math.max(n, s), Math.max(r, o)));
                return h < 0 ? -1 : a > h ? -1 : a
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        8: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = t("../objects/Body");

            function r(t) {
                this.type = t, this.result = [], this.world = null, this.boundingVolumeType = r.AABB
            }
            e.exports = r, r.AABB = 1, r.BOUNDING_CIRCLE = 2, r.prototype.setWorld = function(t) {
                this.world = t
            }, r.prototype.getCollisionPairs = function(t) {};
            var o = n.create();
            r.boundingRadiusCheck = function(t, e) {
                n.sub(o, t.position, e.position);
                var i = n.squaredLength(o),
                    s = t.boundingRadius + e.boundingRadius;
                return i <= s * s
            }, r.aabbCheck = function(t, e) {
                return t.getAABB().overlaps(e.getAABB())
            }, r.prototype.boundingVolumeCheck = function(t, e) {
                var i;
                switch (this.boundingVolumeType) {
                    case r.BOUNDING_CIRCLE:
                        i = r.boundingRadiusCheck(t, e);
                        break;
                    case r.AABB:
                        i = r.aabbCheck(t, e);
                        break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                }
                return i
            }, r.canCollide = function(t, e) {
                var i = s.KINEMATIC,
                    n = s.STATIC;
                return (t.type !== n || e.type !== n) && (!(t.type === i && e.type === n || t.type === n && e.type === i) && ((t.type !== i || e.type !== i) && ((t.sleepState !== s.SLEEPING || e.sleepState !== s.SLEEPING) && !(t.sleepState === s.SLEEPING && e.type === n || e.sleepState === s.SLEEPING && t.type === n))))
            }, r.NAIVE = 1, r.SAP = 2
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31
        }],
        9: [function(t, e, i) {
            t("../shapes/Circle"), t("../shapes/Plane"), t("../shapes/Shape"), t("../shapes/Particle");
            var n = t("../collision/Broadphase");
            t("../math/vec2");

            function s() {
                n.call(this, n.NAIVE)
            }
            e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.getCollisionPairs = function(t) {
                var e = t.bodies,
                    i = this.result;
                i.length = 0;
                for (var s = 0, r = e.length; s !== r; s++)
                    for (var o = e[s], a = 0; a < s; a++) {
                        var h = e[a];
                        n.canCollide(o, h) && this.boundingVolumeCheck(o, h) && i.push(o, h)
                    }
                return i
            }, s.prototype.aabbQuery = function(t, e, i) {
                i = i || [];
                for (var n = t.bodies, s = 0; s < n.length; s++) {
                    var r = n[s];
                    r.aabbNeedsUpdate && r.updateAABB(), r.aabb.overlaps(e) && i.push(r)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../math/vec2": 30,
            "../shapes/Circle": 39,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45
        }],
        10: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = n.sub,
                r = n.add,
                o = n.dot,
                a = (t("../utils/Utils"), t("../utils/ContactEquationPool")),
                h = t("../utils/FrictionEquationPool"),
                l = t("../utils/TupleDictionary"),
                c = t("../equations/Equation"),
                u = (t("../equations/ContactEquation"), t("../equations/FrictionEquation"), t("../shapes/Circle")),
                d = t("../shapes/Convex"),
                p = t("../shapes/Shape"),
                f = (t("../objects/Body"), t("../shapes/Box"));
            e.exports = B;
            var g = n.fromValues(0, 1),
                m = n.fromValues(0, 0),
                y = n.fromValues(0, 0),
                v = n.fromValues(0, 0),
                b = n.fromValues(0, 0),
                x = n.fromValues(0, 0),
                w = n.fromValues(0, 0),
                _ = n.fromValues(0, 0),
                P = n.fromValues(0, 0),
                T = n.fromValues(0, 0),
                S = n.fromValues(0, 0),
                C = n.fromValues(0, 0),
                A = n.fromValues(0, 0),
                E = n.fromValues(0, 0),
                M = n.fromValues(0, 0),
                I = n.fromValues(0, 0),
                O = n.fromValues(0, 0),
                k = n.fromValues(0, 0),
                R = n.fromValues(0, 0),
                L = [];

            function B() {
                this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new a({
                    size: 32
                }), this.frictionEquationPool = new h({
                    size: 64
                }), this.restitution = 0, this.stiffness = c.DEFAULT_STIFFNESS, this.relaxation = c.DEFAULT_RELAXATION, this.frictionStiffness = c.DEFAULT_STIFFNESS, this.frictionRelaxation = c.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new l, this.contactSkinSize = .01
            }
            var F = n.create(),
                D = n.create();

            function U(t, e) {
                n.set(t.vertices[0], .5 * -e.length, -e.radius), n.set(t.vertices[1], .5 * e.length, -e.radius), n.set(t.vertices[2], .5 * e.length, e.radius), n.set(t.vertices[3], .5 * -e.length, e.radius)
            }
            B.prototype.bodiesOverlap = function(t, e) {
                for (var i = F, n = D, s = 0, r = t.shapes.length; s !== r; s++) {
                    var o = t.shapes[s];
                    t.toWorldFrame(i, o.position);
                    for (var a = 0, h = e.shapes.length; a !== h; a++) {
                        var l = e.shapes[a];
                        if (e.toWorldFrame(n, l.position), this[o.type | l.type](t, o, i, o.angle + t.angle, e, l, n, l.angle + e.angle, !0)) return !0
                    }
                }
                return !1
            }, B.prototype.collidedLastStep = function(t, e) {
                var i = 0 | t.id,
                    n = 0 | e.id;
                return !!this.collidingBodiesLastStep.get(i, n)
            }, B.prototype.reset = function() {
                this.collidingBodiesLastStep.reset();
                for (var t = this.contactEquations, e = t.length; e--;) {
                    var i = t[e],
                        n = i.bodyA.id,
                        s = i.bodyB.id;
                    this.collidingBodiesLastStep.set(n, s, !0)
                }
                for (var r = this.contactEquations, o = this.frictionEquations, a = 0; a < r.length; a++) this.contactEquationPool.release(r[a]);
                for (a = 0; a < o.length; a++) this.frictionEquationPool.release(o[a]);
                this.contactEquations.length = this.frictionEquations.length = 0
            }, B.prototype.createContactEquation = function(t, e, i, n) {
                var s = this.contactEquationPool.get();
                return s.bodyA = t, s.bodyB = e, s.shapeA = i, s.shapeB = n, s.restitution = this.restitution, s.firstImpact = !this.collidedLastStep(t, e), s.stiffness = this.stiffness, s.relaxation = this.relaxation, s.needsUpdate = !0, s.enabled = this.enabledEquations, s.offset = this.contactSkinSize, s
            }, B.prototype.createFrictionEquation = function(t, e, i, n) {
                var s = this.frictionEquationPool.get();
                return s.bodyA = t, s.bodyB = e, s.shapeA = i, s.shapeB = n, s.setSlipForce(this.slipForce), s.frictionCoefficient = this.frictionCoefficient, s.relativeVelocity = this.surfaceVelocity, s.enabled = this.enabledEquations, s.needsUpdate = !0, s.stiffness = this.frictionStiffness, s.relaxation = this.frictionRelaxation, s.contactEquations.length = 0, s
            }, B.prototype.createFrictionFromContact = function(t) {
                var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                return n.copy(e.contactPointA, t.contactPointA), n.copy(e.contactPointB, t.contactPointB), n.rotate90cw(e.t, t.normalA), e.contactEquations.push(t), e
            }, B.prototype.createFrictionFromAverage = function(t) {
                var e = this.contactEquations[this.contactEquations.length - 1],
                    i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB),
                    s = e.bodyA;
                e.bodyB;
                n.set(i.contactPointA, 0, 0), n.set(i.contactPointB, 0, 0), n.set(i.t, 0, 0);
                for (var r = 0; r !== t; r++)(e = this.contactEquations[this.contactEquations.length - 1 - r]).bodyA === s ? (n.add(i.t, i.t, e.normalA), n.add(i.contactPointA, i.contactPointA, e.contactPointA), n.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (n.sub(i.t, i.t, e.normalA), n.add(i.contactPointA, i.contactPointA, e.contactPointB), n.add(i.contactPointB, i.contactPointB, e.contactPointA)), i.contactEquations.push(e);
                var o = 1 / t;
                return n.scale(i.contactPointA, i.contactPointA, o), n.scale(i.contactPointB, i.contactPointB, o), n.normalize(i.t, i.t), n.rotate90cw(i.t, i.t), i
            }, B.prototype[p.LINE | p.CONVEX] = B.prototype.convexLine = function(t, e, i, n, s, r, o, a, h) {
                return !h && 0
            }, B.prototype[p.LINE | p.BOX] = B.prototype.lineBox = function(t, e, i, n, s, r, o, a, h) {
                return !h && 0
            };
            var G = new f({
                    width: 1,
                    height: 1
                }),
                N = n.create();
            B.prototype[p.CAPSULE | p.CONVEX] = B.prototype[p.CAPSULE | p.BOX] = B.prototype.convexCapsule = function(t, e, i, s, r, o, a, h, l) {
                var c = N;
                n.set(c, o.length / 2, 0), n.rotate(c, c, h), n.add(c, c, a);
                var u = this.circleConvex(r, o, c, h, t, e, i, s, l, o.radius);
                n.set(c, -o.length / 2, 0), n.rotate(c, c, h), n.add(c, c, a);
                var d = this.circleConvex(r, o, c, h, t, e, i, s, l, o.radius);
                if (l && (u || d)) return !0;
                var p = G;
                return U(p, o), this.convexConvex(t, e, i, s, r, p, a, h, l) + u + d
            }, B.prototype[p.CAPSULE | p.LINE] = B.prototype.lineCapsule = function(t, e, i, n, s, r, o, a, h) {
                return !h && 0
            };
            var X = n.create(),
                j = n.create(),
                W = new f({
                    width: 1,
                    height: 1
                });
            B.prototype[p.CAPSULE | p.CAPSULE] = B.prototype.capsuleCapsule = function(t, e, i, s, r, o, a, h, l) {
                for (var c = X, u = j, d = 0, p = 0; p < 2; p++) {
                    n.set(c, (0 === p ? -1 : 1) * e.length / 2, 0), n.rotate(c, c, s), n.add(c, c, i);
                    for (var f = 0; f < 2; f++) {
                        n.set(u, (0 === f ? -1 : 1) * o.length / 2, 0), n.rotate(u, u, h), n.add(u, u, a), this.enableFrictionReduction && (v = this.enableFriction, this.enableFriction = !1);
                        var g = this.circleCircle(t, e, c, s, r, o, u, h, l, e.radius, o.radius);
                        if (this.enableFrictionReduction && (this.enableFriction = v), l && g) return !0;
                        d += g
                    }
                }
                this.enableFrictionReduction && (v = this.enableFriction, this.enableFriction = !1);
                var m = W;
                U(m, e);
                var y = this.convexCapsule(t, m, i, s, r, o, a, h, l);
                if (this.enableFrictionReduction && (this.enableFriction = v), l && y) return !0;
                if (d += y, this.enableFrictionReduction) {
                    var v = this.enableFriction;
                    this.enableFriction = !1
                }
                U(m, o);
                var b = this.convexCapsule(r, m, a, h, t, e, i, s, l);
                return this.enableFrictionReduction && (this.enableFriction = v), !(!l || !b) || (d += b, this.enableFrictionReduction && d && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(d)), d)
            }, B.prototype[p.LINE | p.LINE] = B.prototype.lineLine = function(t, e, i, n, s, r, o, a, h) {
                return !h && 0
            }, B.prototype[p.PLANE | p.LINE] = B.prototype.planeLine = function(t, e, i, a, h, l, c, u, d) {
                var p = m,
                    f = y,
                    S = v,
                    C = b,
                    A = x,
                    E = w,
                    M = _,
                    I = P,
                    O = T,
                    k = L,
                    R = 0;
                n.set(p, -l.length / 2, 0), n.set(f, l.length / 2, 0), n.rotate(S, p, u), n.rotate(C, f, u), r(S, S, c), r(C, C, c), n.copy(p, S), n.copy(f, C), s(A, f, p), n.normalize(E, A), n.rotate90cw(O, E), n.rotate(I, g, a), k[0] = p, k[1] = f;
                for (var B = 0; B < k.length; B++) {
                    var F = k[B];
                    s(M, F, i);
                    var D = o(M, I);
                    if (D < 0) {
                        if (d) return !0;
                        var U = this.createContactEquation(t, h, e, l);
                        R++, n.copy(U.normalA, I), n.normalize(U.normalA, U.normalA), n.scale(M, I, D), s(U.contactPointA, F, M), s(U.contactPointA, U.contactPointA, t.position), s(U.contactPointB, F, c), r(U.contactPointB, U.contactPointB, c), s(U.contactPointB, U.contactPointB, h.position), this.contactEquations.push(U), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(U))
                    }
                }
                return !d && (this.enableFrictionReduction || R && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(R)), R)
            }, B.prototype[p.PARTICLE | p.CAPSULE] = B.prototype.particleCapsule = function(t, e, i, n, s, r, o, a, h) {
                return this.circleLine(t, e, i, n, s, r, o, a, h, r.radius, 0)
            }, B.prototype[p.CIRCLE | p.LINE] = B.prototype.circleLine = function(t, e, i, a, h, l, c, u, d, p, f) {
                p = p || 0, f = void 0 !== f ? f : e.radius;
                var g = m,
                    I = y,
                    O = v,
                    k = b,
                    R = x,
                    B = w,
                    F = _,
                    D = P,
                    U = T,
                    G = S,
                    N = C,
                    X = A,
                    j = E,
                    W = M,
                    V = L;
                n.set(D, -l.length / 2, 0), n.set(U, l.length / 2, 0), n.rotate(G, D, u), n.rotate(N, U, u), r(G, G, c), r(N, N, c), n.copy(D, G), n.copy(U, N), s(B, U, D), n.normalize(F, B), n.rotate90cw(R, F), s(X, i, D);
                var Y = o(X, R);
                s(k, D, c), s(j, i, c);
                var H = f + p;
                if (Math.abs(Y) < H) {
                    n.scale(g, R, Y), s(O, i, g), n.scale(I, R, o(R, j)), n.normalize(I, I), n.scale(I, I, p), r(O, O, I);
                    var q = o(F, O),
                        z = o(F, D),
                        K = o(F, U);
                    if (q > z && q < K) {
                        if (d) return !0;
                        var J = this.createContactEquation(t, h, e, l);
                        return n.scale(J.normalA, g, -1), n.normalize(J.normalA, J.normalA), n.scale(J.contactPointA, J.normalA, f), r(J.contactPointA, J.contactPointA, i), s(J.contactPointA, J.contactPointA, t.position), s(J.contactPointB, O, c), r(J.contactPointB, J.contactPointB, c), s(J.contactPointB, J.contactPointB, h.position), this.contactEquations.push(J), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(J)), 1
                    }
                }
                V[0] = D, V[1] = U;
                for (var Q = 0; Q < V.length; Q++) {
                    var Z = V[Q];
                    if (s(X, Z, i), n.squaredLength(X) < Math.pow(H, 2)) {
                        if (d) return !0;
                        J = this.createContactEquation(t, h, e, l);
                        return n.copy(J.normalA, X), n.normalize(J.normalA, J.normalA), n.scale(J.contactPointA, J.normalA, f), r(J.contactPointA, J.contactPointA, i), s(J.contactPointA, J.contactPointA, t.position), s(J.contactPointB, Z, c), n.scale(W, J.normalA, -p), r(J.contactPointB, J.contactPointB, W), r(J.contactPointB, J.contactPointB, c), s(J.contactPointB, J.contactPointB, h.position), this.contactEquations.push(J), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(J)), 1
                    }
                }
                return 0
            }, B.prototype[p.CIRCLE | p.CAPSULE] = B.prototype.circleCapsule = function(t, e, i, n, s, r, o, a, h) {
                return this.circleLine(t, e, i, n, s, r, o, a, h, r.radius)
            }, B.prototype[p.CIRCLE | p.CONVEX] = B.prototype[p.CIRCLE | p.BOX] = B.prototype.circleConvex = function(t, e, i, o, a, h, l, c, u, d) {
                d = "number" == typeof d ? d : e.radius;
                for (var p = m, f = y, g = v, w = b, _ = x, P = S, T = C, A = E, k = M, R = I, L = O, B = !1, F = Number.MAX_VALUE, D = h.vertices, U = 0; U !== D.length + 1; U++) {
                    var G = D[U % D.length],
                        N = D[(U + 1) % D.length];
                    if (n.rotate(p, G, c), n.rotate(f, N, c), r(p, p, l), r(f, f, l), s(g, f, p), n.normalize(w, g), n.rotate90cw(_, w), n.scale(k, _, -e.radius), r(k, k, i), z(k, h, l, c)) {
                        n.sub(R, p, k);
                        var X = Math.abs(n.dot(R, _));
                        X < F && (n.copy(L, k), F = X, n.scale(A, _, X), n.add(A, A, k), B = !0)
                    }
                }
                if (B) {
                    if (u) return !0;
                    var j = this.createContactEquation(t, a, e, h);
                    return n.sub(j.normalA, L, i), n.normalize(j.normalA, j.normalA), n.scale(j.contactPointA, j.normalA, d), r(j.contactPointA, j.contactPointA, i), s(j.contactPointA, j.contactPointA, t.position), s(j.contactPointB, A, l), r(j.contactPointB, j.contactPointB, l), s(j.contactPointB, j.contactPointB, a.position), this.contactEquations.push(j), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(j)), 1
                }
                if (d > 0)
                    for (U = 0; U < D.length; U++) {
                        var W = D[U];
                        if (n.rotate(T, W, c), r(T, T, l), s(P, T, i), n.squaredLength(P) < Math.pow(d, 2)) {
                            if (u) return !0;
                            j = this.createContactEquation(t, a, e, h);
                            return n.copy(j.normalA, P), n.normalize(j.normalA, j.normalA), n.scale(j.contactPointA, j.normalA, d), r(j.contactPointA, j.contactPointA, i), s(j.contactPointA, j.contactPointA, t.position), s(j.contactPointB, T, l), r(j.contactPointB, j.contactPointB, l), s(j.contactPointB, j.contactPointB, a.position), this.contactEquations.push(j), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(j)), 1
                        }
                    }
                return 0
            };
            var V = n.create(),
                Y = n.create(),
                H = n.create(),
                q = n.create();

            function z(t, e, i, o) {
                for (var a = V, h = Y, l = H, c = q, u = t, d = e.vertices, p = null, f = 0; f !== d.length + 1; f++) {
                    var g = d[f % d.length],
                        m = d[(f + 1) % d.length];
                    n.rotate(a, g, o), n.rotate(h, m, o), r(a, a, i), r(h, h, i), s(l, a, u), s(c, h, u);
                    var y = n.crossLength(l, c);
                    if (null === p && (p = y), y * p <= 0) return !1;
                    p = y
                }
                return !0
            }
            B.prototype[p.PARTICLE | p.CONVEX] = B.prototype[p.PARTICLE | p.BOX] = B.prototype.particleConvex = function(t, e, i, a, h, l, c, u, d) {
                var p = m,
                    f = y,
                    g = v,
                    P = b,
                    T = x,
                    C = w,
                    A = _,
                    M = S,
                    I = E,
                    O = k,
                    L = R,
                    B = Number.MAX_VALUE,
                    F = !1,
                    D = l.vertices;
                if (!z(i, l, c, u)) return 0;
                if (d) return !0;
                for (var U = 0; U !== D.length + 1; U++) {
                    var G = D[U % D.length],
                        N = D[(U + 1) % D.length];
                    n.rotate(p, G, u), n.rotate(f, N, u), r(p, p, c), r(f, f, c), s(g, f, p), n.normalize(P, g), n.rotate90cw(T, P), s(M, i, p);
                    o(M, T);
                    s(C, p, c), s(A, i, c), n.sub(O, p, i);
                    var X = Math.abs(n.dot(O, T));
                    X < B && (B = X, n.scale(I, T, X), n.add(I, I, i), n.copy(L, T), F = !0)
                }
                if (F) {
                    var j = this.createContactEquation(t, h, e, l);
                    return n.scale(j.normalA, L, -1), n.normalize(j.normalA, j.normalA), n.set(j.contactPointA, 0, 0), r(j.contactPointA, j.contactPointA, i), s(j.contactPointA, j.contactPointA, t.position), s(j.contactPointB, I, c), r(j.contactPointB, j.contactPointB, c), s(j.contactPointB, j.contactPointB, h.position), this.contactEquations.push(j), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(j)), 1
                }
                return 0
            }, B.prototype[p.CIRCLE] = B.prototype.circleCircle = function(t, e, i, o, a, h, l, c, u, d, p) {
                var f = m;
                d = d || e.radius, p = p || h.radius;
                s(f, i, l);
                var g = d + p;
                if (n.squaredLength(f) > Math.pow(g, 2)) return 0;
                if (u) return !0;
                var y = this.createContactEquation(t, a, e, h);
                return s(y.normalA, l, i), n.normalize(y.normalA, y.normalA), n.scale(y.contactPointA, y.normalA, d), n.scale(y.contactPointB, y.normalA, -p), r(y.contactPointA, y.contactPointA, i), s(y.contactPointA, y.contactPointA, t.position), r(y.contactPointB, y.contactPointB, l), s(y.contactPointB, y.contactPointB, a.position), this.contactEquations.push(y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(y)), 1
            }, B.prototype[p.PLANE | p.CONVEX] = B.prototype[p.PLANE | p.BOX] = B.prototype.planeConvex = function(t, e, i, a, h, l, c, u, d) {
                var p = m,
                    f = y,
                    b = v,
                    x = 0;
                n.rotate(f, g, a);
                for (var w = 0; w !== l.vertices.length; w++) {
                    var _ = l.vertices[w];
                    if (n.rotate(p, _, u), r(p, p, c), s(b, p, i), o(b, f) <= 0) {
                        if (d) return !0;
                        x++;
                        var P = this.createContactEquation(t, h, e, l);
                        s(b, p, i), n.copy(P.normalA, f);
                        var T = o(b, P.normalA);
                        n.scale(b, P.normalA, T), s(P.contactPointB, p, h.position), s(P.contactPointA, p, b), s(P.contactPointA, P.contactPointA, t.position), this.contactEquations.push(P), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(P))
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && x && this.frictionEquations.push(this.createFrictionFromAverage(x)), x
            }, B.prototype[p.PARTICLE | p.PLANE] = B.prototype.particlePlane = function(t, e, i, r, a, h, l, c, u) {
                var d = m,
                    p = y;
                c = c || 0, s(d, i, l), n.rotate(p, g, c);
                var f = o(d, p);
                if (f > 0) return 0;
                if (u) return !0;
                var v = this.createContactEquation(a, t, h, e);
                return n.copy(v.normalA, p), n.scale(d, v.normalA, f), s(v.contactPointA, i, d), s(v.contactPointA, v.contactPointA, a.position), s(v.contactPointB, i, t.position), this.contactEquations.push(v), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(v)), 1
            }, B.prototype[p.CIRCLE | p.PARTICLE] = B.prototype.circleParticle = function(t, e, i, o, a, h, l, c, u) {
                var d = m;
                if (s(d, l, i), n.squaredLength(d) > Math.pow(e.radius, 2)) return 0;
                if (u) return !0;
                var p = this.createContactEquation(t, a, e, h);
                return n.copy(p.normalA, d), n.normalize(p.normalA, p.normalA), n.scale(p.contactPointA, p.normalA, e.radius), r(p.contactPointA, p.contactPointA, i), s(p.contactPointA, p.contactPointA, t.position), s(p.contactPointB, l, a.position), this.contactEquations.push(p), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)), 1
            };
            var K = new u({
                    radius: 1
                }),
                J = n.create(),
                Q = n.create();
            n.create();
            B.prototype[p.PLANE | p.CAPSULE] = B.prototype.planeCapsule = function(t, e, i, s, o, a, h, l, c) {
                var u, d = J,
                    p = Q,
                    f = K;
                n.set(d, -a.length / 2, 0), n.rotate(d, d, l), r(d, d, h), n.set(p, a.length / 2, 0), n.rotate(p, p, l), r(p, p, h), f.radius = a.radius, this.enableFrictionReduction && (u = this.enableFriction, this.enableFriction = !1);
                var g = this.circlePlane(o, f, d, 0, t, e, i, s, c),
                    m = this.circlePlane(o, f, p, 0, t, e, i, s, c);
                if (this.enableFrictionReduction && (this.enableFriction = u), c) return g || m;
                var y = g + m;
                return this.enableFrictionReduction && y && this.frictionEquations.push(this.createFrictionFromAverage(y)), y
            }, B.prototype[p.CIRCLE | p.PLANE] = B.prototype.circlePlane = function(t, e, i, a, h, l, c, u, d) {
                var p = t,
                    f = e,
                    b = i,
                    x = h,
                    w = c,
                    _ = u;
                _ = _ || 0;
                var P = m,
                    T = y,
                    S = v;
                s(P, b, w), n.rotate(T, g, _);
                var C = o(T, P);
                if (C > f.radius) return 0;
                if (d) return !0;
                var A = this.createContactEquation(x, p, l, e);
                return n.copy(A.normalA, T), n.scale(A.contactPointB, A.normalA, -f.radius), r(A.contactPointB, A.contactPointB, b), s(A.contactPointB, A.contactPointB, p.position), n.scale(S, A.normalA, C), s(A.contactPointA, P, S), r(A.contactPointA, A.contactPointA, w), s(A.contactPointA, A.contactPointA, x.position), this.contactEquations.push(A), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(A)), 1
            }, B.prototype[p.CONVEX] = B.prototype[p.CONVEX | p.BOX] = B.prototype[p.BOX] = B.prototype.convexConvex = function(t, e, i, a, h, l, c, u, d, p) {
                var f = m,
                    g = y,
                    w = v,
                    S = b,
                    C = x,
                    A = _,
                    E = P,
                    M = T,
                    I = 0;
                p = "number" == typeof p ? p : 0;
                if (!B.findSeparatingAxis(e, i, a, l, c, u, f)) return 0;
                s(E, c, i), o(f, E) > 0 && n.scale(f, f, -1);
                var O = B.getClosestEdge(e, a, f, !0),
                    k = B.getClosestEdge(l, u, f);
                if (-1 === O || -1 === k) return 0;
                for (var R = 0; R < 2; R++) {
                    var L, F = O,
                        D = k,
                        U = e,
                        G = l,
                        N = i,
                        X = c,
                        j = a,
                        W = u,
                        V = t,
                        Y = h;
                    if (0 === R) L = F, F = D, D = L, L = U, U = G, G = L, L = N, N = X, X = L, L = j, j = W, W = L, L = V, V = Y, Y = L;
                    for (var H = D; H < D + 2; H++) {
                        var q = G.vertices[(H + G.vertices.length) % G.vertices.length];
                        n.rotate(g, q, W), r(g, g, X);
                        for (var z = 0, K = F - 1; K < F + 2; K++) {
                            var J = U.vertices[(K + U.vertices.length) % U.vertices.length],
                                Q = U.vertices[(K + 1 + U.vertices.length) % U.vertices.length];
                            n.rotate(w, J, j), n.rotate(S, Q, j), r(w, w, N), r(S, S, N), s(C, S, w), n.rotate90cw(M, C), n.normalize(M, M), s(E, g, w);
                            var Z = o(M, E);
                            (K === F && Z <= p || K !== F && Z <= 0) && z++
                        }
                        if (z >= 3) {
                            if (d) return !0;
                            var $ = this.createContactEquation(V, Y, U, G);
                            I++;
                            J = U.vertices[F % U.vertices.length], Q = U.vertices[(F + 1) % U.vertices.length];
                            n.rotate(w, J, j), n.rotate(S, Q, j), r(w, w, N), r(S, S, N), s(C, S, w), n.rotate90cw($.normalA, C), n.normalize($.normalA, $.normalA), s(E, g, w);
                            Z = o($.normalA, E);
                            n.scale(A, $.normalA, Z), s($.contactPointA, g, N), s($.contactPointA, $.contactPointA, A), r($.contactPointA, $.contactPointA, N), s($.contactPointA, $.contactPointA, V.position), s($.contactPointB, g, X), r($.contactPointB, $.contactPointB, X), s($.contactPointB, $.contactPointB, Y.position), this.contactEquations.push($), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact($))
                        }
                    }
                }
                return this.enableFrictionReduction && this.enableFriction && I && this.frictionEquations.push(this.createFrictionFromAverage(I)), I
            };
            var Z = n.fromValues(0, 0);
            B.projectConvexOntoAxis = function(t, e, i, s, r) {
                var a, h, l = null,
                    c = null,
                    u = Z;
                n.rotate(u, s, -i);
                for (var d = 0; d < t.vertices.length; d++) a = t.vertices[d], h = o(a, u), (null === l || h > l) && (l = h), (null === c || h < c) && (c = h);
                if (c > l) {
                    var p = c;
                    c = l, l = p
                }
                var f = o(e, s);
                n.set(r, c + f, l + f)
            };
            var $ = n.fromValues(0, 0),
                tt = n.fromValues(0, 0),
                et = n.fromValues(0, 0),
                it = n.fromValues(0, 0),
                nt = n.fromValues(0, 0),
                st = n.fromValues(0, 0);
            B.findSeparatingAxis = function(t, e, i, r, o, a, h) {
                var l = null,
                    c = !1,
                    u = !1,
                    d = $,
                    p = tt,
                    g = et,
                    m = it,
                    y = nt,
                    v = st;
                if (t instanceof f && r instanceof f)
                    for (var b = 0; 2 !== b; b++) {
                        var x = t,
                            w = i;
                        1 === b && (x = r, w = a);
                        for (var _ = 0; 2 !== _; _++) {
                            0 === _ ? n.set(m, 0, 1) : 1 === _ && n.set(m, 1, 0), 0 !== w && n.rotate(m, m, w), B.projectConvexOntoAxis(t, e, i, m, y), B.projectConvexOntoAxis(r, o, a, m, v);
                            var P = y,
                                T = v;
                            y[0] > v[0] && (T = y, P = v, !0), c = (S = T[0] - P[1]) <= 0, (null === l || S > l) && (n.copy(h, m), l = S, u = c)
                        }
                    } else
                        for (b = 0; 2 !== b; b++) {
                            x = t, w = i;
                            1 === b && (x = r, w = a);
                            for (_ = 0; _ !== x.vertices.length; _++) {
                                n.rotate(p, x.vertices[_], w), n.rotate(g, x.vertices[(_ + 1) % x.vertices.length], w), s(d, g, p), n.rotate90cw(m, d), n.normalize(m, m), B.projectConvexOntoAxis(t, e, i, m, y), B.projectConvexOntoAxis(r, o, a, m, v);
                                var S;
                                P = y, T = v;
                                y[0] > v[0] && (T = y, P = v, !0), c = (S = T[0] - P[1]) <= 0, (null === l || S > l) && (n.copy(h, m), l = S, u = c)
                            }
                        }
                return u
            };
            var rt = n.fromValues(0, 0),
                ot = n.fromValues(0, 0),
                at = n.fromValues(0, 0);
            B.getClosestEdge = function(t, e, i, r) {
                var a = rt,
                    h = ot,
                    l = at;
                n.rotate(a, i, -e), r && n.scale(a, a, -1);
                for (var c = -1, u = t.vertices.length, d = -1, p = 0; p !== u; p++) {
                    s(h, t.vertices[(p + 1) % u], t.vertices[p % u]), n.rotate90cw(l, h), n.normalize(l, l);
                    var f = o(l, a);
                    (-1 === c || f > d) && (c = p % u, d = f)
                }
                return c
            };
            var ht = n.create(),
                lt = n.create(),
                ct = n.create(),
                ut = n.create(),
                dt = n.create(),
                pt = n.create(),
                ft = n.create();
            B.prototype[p.CIRCLE | p.HEIGHTFIELD] = B.prototype.circleHeightfield = function(t, e, i, o, a, h, l, c, u, d) {
                var p = h.heights,
                    f = (d = d || e.radius, h.elementWidth),
                    g = lt,
                    m = ht,
                    y = dt,
                    v = ft,
                    b = pt,
                    x = ct,
                    w = ut,
                    _ = Math.floor((i[0] - d - l[0]) / f),
                    P = Math.ceil((i[0] + d - l[0]) / f);
                _ < 0 && (_ = 0), P >= p.length && (P = p.length - 1);
                for (var T = p[_], S = p[P], C = _; C < P; C++) p[C] < S && (S = p[C]), p[C] > T && (T = p[C]);
                if (i[1] - d > T) return !u && 0;
                var A = !1;
                for (C = _; C < P; C++) {
                    n.set(x, C * f, p[C]), n.set(w, (C + 1) * f, p[C + 1]), n.add(x, x, l), n.add(w, w, l), n.sub(b, w, x), n.rotate(b, b, Math.PI / 2), n.normalize(b, b), n.scale(m, b, -d), n.add(m, m, i), n.sub(g, m, x);
                    var E = n.dot(g, b);
                    if (m[0] >= x[0] && m[0] < w[0] && E <= 0) {
                        if (u) return !0;
                        A = !0, n.scale(g, b, -E), n.add(y, m, g), n.copy(v, b);
                        var M = this.createContactEquation(a, t, h, e);
                        n.copy(M.normalA, v), n.scale(M.contactPointB, M.normalA, -d), r(M.contactPointB, M.contactPointB, i), s(M.contactPointB, M.contactPointB, t.position), n.copy(M.contactPointA, y), n.sub(M.contactPointA, M.contactPointA, a.position), this.contactEquations.push(M), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                    }
                }
                if (A = !1, d > 0)
                    for (C = _; C <= P; C++)
                        if (n.set(x, C * f, p[C]), n.add(x, x, l), n.sub(g, i, x), n.squaredLength(g) < Math.pow(d, 2)) {
                            if (u) return !0;
                            A = !0;
                            M = this.createContactEquation(a, t, h, e);
                            n.copy(M.normalA, g), n.normalize(M.normalA, M.normalA), n.scale(M.contactPointB, M.normalA, -d), r(M.contactPointB, M.contactPointB, i), s(M.contactPointB, M.contactPointB, t.position), s(M.contactPointA, x, l), r(M.contactPointA, M.contactPointA, l), s(M.contactPointA, M.contactPointA, a.position), this.contactEquations.push(M), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M))
                        }
                return A ? 1 : 0
            };
            var gt = n.create(),
                mt = n.create(),
                yt = n.create(),
                vt = new d({
                    vertices: [n.create(), n.create(), n.create(), n.create()]
                });
            B.prototype[p.BOX | p.HEIGHTFIELD] = B.prototype[p.CONVEX | p.HEIGHTFIELD] = B.prototype.convexHeightfield = function(t, e, i, s, r, o, a, h, l) {
                var c = o.heights,
                    u = o.elementWidth,
                    d = gt,
                    p = mt,
                    f = yt,
                    g = vt,
                    m = Math.floor((t.aabb.lowerBound[0] - a[0]) / u),
                    y = Math.ceil((t.aabb.upperBound[0] - a[0]) / u);
                m < 0 && (m = 0), y >= c.length && (y = c.length - 1);
                for (var v = c[m], b = c[y], x = m; x < y; x++) c[x] < b && (b = c[x]), c[x] > v && (v = c[x]);
                if (t.aabb.lowerBound[1] > v) return !l && 0;
                var w = 0;
                for (x = m; x < y; x++) {
                    n.set(d, x * u, c[x]), n.set(p, (x + 1) * u, c[x + 1]), n.add(d, d, a), n.add(p, p, a);
                    n.set(f, .5 * (p[0] + d[0]), .5 * (p[1] + d[1] - 100)), n.sub(g.vertices[0], p, f), n.sub(g.vertices[1], d, f), n.copy(g.vertices[2], g.vertices[1]), n.copy(g.vertices[3], g.vertices[0]), g.vertices[2][1] -= 100, g.vertices[3][1] -= 100, w += this.convexConvex(t, e, i, s, r, g, f, 0, l)
                }
                return w
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../shapes/Box": 37,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Shape": 45,
            "../utils/ContactEquationPool": 48,
            "../utils/FrictionEquationPool": 49,
            "../utils/TupleDictionary": 56,
            "../utils/Utils": 57
        }],
        11: [function(t, e, i) {
            e.exports = s;
            var n = t("../math/vec2");
            t("../collision/RaycastResult"), t("../shapes/Shape"), t("../collision/AABB");

            function s(t) {
                t = t || {}, this.from = t.from ? n.fromValues(t.from[0], t.from[1]) : n.create(), this.to = t.to ? n.fromValues(t.to[0], t.to[1]) : n.create(), this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse, this.skipBackfaces = !!t.skipBackfaces, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1, this.mode = void 0 !== t.mode ? t.mode : s.ANY, this.callback = t.callback || function(t) {}, this.direction = n.create(), this.length = 1, this.update()
            }
            s.prototype.constructor = s, s.CLOSEST = 1, s.ANY = 2, s.ALL = 4, s.prototype.update = function() {
                var t = this.direction;
                n.sub(t, this.to, this.from), this.length = n.length(t), n.normalize(t, t)
            }, s.prototype.intersectBodies = function(t, e) {
                for (var i = 0, n = e.length; !t.shouldStop(this) && i < n; i++) {
                    var s = e[i],
                        r = s.getAABB();
                    (r.overlapsRay(this) >= 0 || r.containsPoint(this.from)) && this.intersectBody(t, s)
                }
            };
            var r = n.create();
            s.prototype.intersectBody = function(t, e) {
                var i = this.checkCollisionResponse;
                if (!i || e.collisionResponse)
                    for (var s = r, o = 0, a = e.shapes.length; o < a; o++) {
                        var h = e.shapes[o];
                        if ((!i || h.collisionResponse) && (0 != (this.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & this.collisionMask))) {
                            n.rotate(s, h.position, e.angle), n.add(s, s, e.position);
                            var l = h.angle + e.angle;
                            if (this.intersectShape(t, h, l, s, e), t.shouldStop(this)) break
                        }
                    }
            }, s.prototype.intersectShape = function(t, e, i, s, r) {
                (function(t, e, i) {
                    n.sub(o, i, t);
                    var s = n.dot(o, e);
                    return n.scale(a, e, s), n.add(a, a, t), n.squaredDistance(i, a)
                })(this.from, this.direction, s) > e.boundingRadius * e.boundingRadius || (this._currentBody = r, this._currentShape = e, e.raycast(t, this, s, i), this._currentBody = this._currentShape = null)
            }, s.prototype.getAABB = function(t) {
                var e = this.to,
                    i = this.from;
                n.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])), n.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1]))
            };
            n.create();
            s.prototype.reportIntersection = function(t, e, i, r) {
                this.from, this.to;
                var o = this._currentShape,
                    a = this._currentBody;
                if (!(this.skipBackfaces && n.dot(i, this.direction) > 0)) switch (this.mode) {
                    case s.ALL:
                        t.set(i, o, a, e, r), this.callback(t);
                        break;
                    case s.CLOSEST:
                        (e < t.fraction || !t.hasHit()) && t.set(i, o, a, e, r);
                        break;
                    case s.ANY:
                        t.set(i, o, a, e, r)
                }
            };
            var o = n.create(),
                a = n.create()
        }, {
            "../collision/AABB": 7,
            "../collision/RaycastResult": 12,
            "../math/vec2": 30,
            "../shapes/Shape": 45
        }],
        12: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = t("../collision/Ray");

            function r() {
                this.normal = n.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }
            e.exports = r, r.prototype.reset = function() {
                n.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
            }, r.prototype.getHitDistance = function(t) {
                return n.distance(t.from, t.to) * this.fraction
            }, r.prototype.hasHit = function() {
                return -1 !== this.fraction
            }, r.prototype.getHitPoint = function(t, e) {
                n.lerp(t, e.from, e.to, this.fraction)
            }, r.prototype.stop = function() {
                this.isStopped = !0
            }, r.prototype.shouldStop = function(t) {
                return this.isStopped || -1 !== this.fraction && t.mode === s.ANY
            }, r.prototype.set = function(t, e, i, s, r) {
                n.copy(this.normal, t), this.shape = e, this.body = i, this.fraction = s, this.faceIndex = r
            }
        }, {
            "../collision/Ray": 11,
            "../math/vec2": 30
        }],
        13: [function(t, e, i) {
            var n = t("../utils/Utils"),
                s = t("../collision/Broadphase");

            function r() {
                s.call(this, s.SAP), this.axisList = [], this.axisIndex = 0;
                var t = this;
                this._addBodyHandler = function(e) {
                    t.axisList.push(e.body)
                }, this._removeBodyHandler = function(e) {
                    var i = t.axisList.indexOf(e.body); - 1 !== i && t.axisList.splice(i, 1)
                }
            }
            e.exports = r, r.prototype = new s, r.prototype.constructor = r, r.prototype.setWorld = function(t) {
                this.axisList.length = 0, n.appendArray(this.axisList, t.bodies), t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = t
            }, r.sortAxisList = function(t, e) {
                e |= 0;
                for (var i = 1, n = t.length; i < n; i++) {
                    for (var s = t[i], r = i - 1; r >= 0 && !(t[r].aabb.lowerBound[e] <= s.aabb.lowerBound[e]); r--) t[r + 1] = t[r];
                    t[r + 1] = s
                }
                return t
            }, r.prototype.sortList = function() {
                var t = this.axisList,
                    e = this.axisIndex;
                r.sortAxisList(t, e)
            }, r.prototype.getCollisionPairs = function(t) {
                var e = this.axisList,
                    i = this.result,
                    n = this.axisIndex;
                i.length = 0;
                for (var r = e.length; r--;) {
                    var o = e[r];
                    o.aabbNeedsUpdate && o.updateAABB()
                }
                this.sortList();
                for (var a = 0, h = 0 | e.length; a !== h; a++)
                    for (var l = e[a], c = a + 1; c < h; c++) {
                        var u = e[c];
                        if (!(u.aabb.lowerBound[n] <= l.aabb.upperBound[n])) break;
                        s.canCollide(l, u) && this.boundingVolumeCheck(l, u) && i.push(l, u)
                    }
                return i
            }, r.prototype.aabbQuery = function(t, e, i) {
                i = i || [], this.sortList();
                var n = this.axisIndex,
                    s = "x";
                1 === n && (s = "y"), 2 === n && (s = "z");
                for (var r = this.axisList, o = (e.lowerBound[s], e.upperBound[s], 0); o < r.length; o++) {
                    var a = r[o];
                    a.aabbNeedsUpdate && a.updateAABB(), a.aabb.overlaps(e) && i.push(a)
                }
                return i
            }
        }, {
            "../collision/Broadphase": 8,
            "../utils/Utils": 57
        }],
        14: [function(t, e, i) {
            e.exports = s;
            var n = t("../utils/Utils");

            function s(t, e, i, s) {
                this.type = i, s = n.defaults(s, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                }), this.equations = [], this.bodyA = t, this.bodyB = e, this.collideConnected = s.collideConnected, s.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
            }
            s.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!")
            }, s.DISTANCE = 1, s.GEAR = 2, s.LOCK = 3, s.PRISMATIC = 4, s.REVOLUTE = 5, s.prototype.setStiffness = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var n = e[i];
                    n.stiffness = t, n.needsUpdate = !0
                }
            }, s.prototype.setRelaxation = function(t) {
                for (var e = this.equations, i = 0; i !== e.length; i++) {
                    var n = e[i];
                    n.relaxation = t, n.needsUpdate = !0
                }
            }
        }, {
            "../utils/Utils": 57
        }],
        15: [function(t, e, i) {
            var n = t("./Constraint"),
                s = t("../equations/Equation"),
                r = t("../math/vec2"),
                o = t("../utils/Utils");

            function a(t, e, i) {
                i = o.defaults(i, {
                    localAnchorA: [0, 0],
                    localAnchorB: [0, 0]
                }), n.call(this, t, e, n.DISTANCE, i), this.localAnchorA = r.fromValues(i.localAnchorA[0], i.localAnchorA[1]), this.localAnchorB = r.fromValues(i.localAnchorB[0], i.localAnchorB[1]);
                var a, h = this.localAnchorA,
                    l = this.localAnchorB;
                if (this.distance = 0, "number" == typeof i.distance) this.distance = i.distance;
                else {
                    var c = r.create(),
                        u = r.create(),
                        d = r.create();
                    r.rotate(c, h, t.angle), r.rotate(u, l, e.angle), r.add(d, e.position, u), r.sub(d, d, c), r.sub(d, d, t.position), this.distance = r.length(d)
                }
                a = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce;
                var p = new s(t, e, -a, a);
                this.equations = [p], this.maxForce = a;
                d = r.create();
                var f = r.create(),
                    g = r.create(),
                    m = this;
                p.computeGq = function() {
                    var t = this.bodyA,
                        e = this.bodyB,
                        i = t.position,
                        n = e.position;
                    return r.rotate(f, h, t.angle), r.rotate(g, l, e.angle), r.add(d, n, g), r.sub(d, d, f), r.sub(d, d, i), r.length(d) - m.distance
                }, this.setMaxForce(a), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0
            }
            e.exports = a, a.prototype = new n, a.prototype.constructor = a;
            var h = r.create(),
                l = r.create(),
                c = r.create();
            a.prototype.update = function() {
                var t = this.equations[0],
                    e = this.bodyA,
                    i = this.bodyB,
                    n = (this.distance, e.position),
                    s = i.position,
                    o = this.equations[0],
                    a = t.G;
                r.rotate(l, this.localAnchorA, e.angle), r.rotate(c, this.localAnchorB, i.angle), r.add(h, s, c), r.sub(h, h, l), r.sub(h, h, n), this.position = r.length(h);
                var u = !1;
                if (this.upperLimitEnabled && this.position > this.upperLimit && (o.maxForce = 0, o.minForce = -this.maxForce, this.distance = this.upperLimit, u = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (o.maxForce = this.maxForce, o.minForce = 0, this.distance = this.lowerLimit, u = !0), !this.lowerLimitEnabled && !this.upperLimitEnabled || u) {
                    o.enabled = !0, r.normalize(h, h);
                    var d = r.crossLength(l, h),
                        p = r.crossLength(c, h);
                    a[0] = -h[0], a[1] = -h[1], a[2] = -d, a[3] = h[0], a[4] = h[1], a[5] = p
                } else o.enabled = !1
            }, a.prototype.setMaxForce = function(t) {
                var e = this.equations[0];
                e.minForce = -t, e.maxForce = t
            }, a.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Constraint": 14
        }],
        16: [function(t, e, i) {
            var n = t("./Constraint"),
                s = (t("../equations/Equation"), t("../equations/AngleLockEquation"));
            t("../math/vec2");

            function r(t, e, i) {
                i = i || {}, n.call(this, t, e, n.GEAR, i), this.ratio = void 0 !== i.ratio ? i.ratio : 1, this.angle = void 0 !== i.angle ? i.angle : e.angle - this.ratio * t.angle, i.angle = this.angle, i.ratio = this.ratio, this.equations = [new s(t, e, i)], void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque)
            }
            e.exports = r, r.prototype = new n, r.prototype.constructor = r, r.prototype.update = function() {
                var t = this.equations[0];
                t.ratio !== this.ratio && t.setRatio(this.ratio), t.angle = this.angle
            }, r.prototype.setMaxTorque = function(t) {
                this.equations[0].setMaxTorque(t)
            }, r.prototype.getMaxTorque = function(t) {
                return this.equations[0].maxForce
            }
        }, {
            "../equations/AngleLockEquation": 20,
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        17: [function(t, e, i) {
            var n = t("./Constraint"),
                s = t("../math/vec2"),
                r = t("../equations/Equation");

            function o(t, e, i) {
                i = i || {}, n.call(this, t, e, n.LOCK, i);
                var o = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce,
                    a = (i.localAngleB, new r(t, e, -o, o)),
                    h = new r(t, e, -o, o),
                    l = new r(t, e, -o, o),
                    c = s.create(),
                    u = s.create(),
                    d = this;
                a.computeGq = function() {
                    return s.rotate(c, d.localOffsetB, t.angle), s.sub(u, e.position, t.position), s.sub(u, u, c), u[0]
                }, h.computeGq = function() {
                    return s.rotate(c, d.localOffsetB, t.angle), s.sub(u, e.position, t.position), s.sub(u, u, c), u[1]
                };
                var p = s.create(),
                    f = s.create();
                l.computeGq = function() {
                    return s.rotate(p, d.localOffsetB, e.angle - d.localAngleB), s.scale(p, p, -1), s.sub(u, t.position, e.position), s.add(u, u, p), s.rotate(f, p, -Math.PI / 2), s.normalize(f, f), s.dot(u, f)
                }, this.localOffsetB = s.create(), i.localOffsetB ? s.copy(this.localOffsetB, i.localOffsetB) : (s.sub(this.localOffsetB, e.position, t.position), s.rotate(this.localOffsetB, this.localOffsetB, -t.angle)), this.localAngleB = 0, "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB : this.localAngleB = e.angle - t.angle, this.equations.push(a, h, l), this.setMaxForce(o)
            }
            e.exports = o, o.prototype = new n, o.prototype.constructor = o, o.prototype.setMaxForce = function(t) {
                for (var e = this.equations, i = 0; i < this.equations.length; i++) e[i].maxForce = t, e[i].minForce = -t
            }, o.prototype.getMaxForce = function() {
                return this.equations[0].maxForce
            };
            var a = s.create(),
                h = s.create(),
                l = s.create(),
                c = s.fromValues(1, 0),
                u = s.fromValues(0, 1);
            o.prototype.update = function() {
                var t = this.equations[0],
                    e = this.equations[1],
                    i = this.equations[2],
                    n = this.bodyA,
                    r = this.bodyB;
                s.rotate(a, this.localOffsetB, n.angle), s.rotate(h, this.localOffsetB, r.angle - this.localAngleB), s.scale(h, h, -1), s.rotate(l, h, Math.PI / 2), s.normalize(l, l), t.G[0] = -1, t.G[1] = 0, t.G[2] = -s.crossLength(a, c), t.G[3] = 1, e.G[0] = 0, e.G[1] = -1, e.G[2] = -s.crossLength(a, u), e.G[4] = 1, i.G[0] = -l[0], i.G[1] = -l[1], i.G[3] = l[0], i.G[4] = l[1], i.G[5] = s.crossLength(h, l)
            }
        }, {
            "../equations/Equation": 22,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        18: [function(t, e, i) {
            var n = t("./Constraint"),
                s = t("../equations/ContactEquation"),
                r = t("../equations/Equation"),
                o = t("../math/vec2"),
                a = t("../equations/RotationalLockEquation");

            function h(t, e, i) {
                i = i || {}, n.call(this, t, e, n.PRISMATIC, i);
                var h = o.fromValues(0, 0),
                    l = o.fromValues(1, 0),
                    c = o.fromValues(0, 0);
                i.localAnchorA && o.copy(h, i.localAnchorA), i.localAxisA && o.copy(l, i.localAxisA), i.localAnchorB && o.copy(c, i.localAnchorB), this.localAnchorA = h, this.localAnchorB = c, this.localAxisA = l;
                var u = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE,
                    d = new r(t, e, -u, u),
                    p = new o.create,
                    f = new o.create,
                    g = new o.create,
                    m = new o.create;
                if (d.computeGq = function() {
                        return o.dot(g, m)
                    }, d.updateJacobian = function() {
                        var i = this.G,
                            n = t.position,
                            s = e.position;
                        o.rotate(p, h, t.angle), o.rotate(f, c, e.angle), o.add(g, s, f), o.sub(g, g, n), o.sub(g, g, p), o.rotate(m, l, t.angle + Math.PI / 2), i[0] = -m[0], i[1] = -m[1], i[2] = -o.crossLength(p, m) + o.crossLength(m, g), i[3] = m[0], i[4] = m[1], i[5] = o.crossLength(f, m)
                    }, this.equations.push(d), !i.disableRotationalLock) {
                    var y = new a(t, e, -u, u);
                    this.equations.push(y)
                }
                this.position = 0, this.velocity = 0, this.lowerLimitEnabled = void 0 !== i.lowerLimit, this.upperLimitEnabled = void 0 !== i.upperLimit, this.lowerLimit = void 0 !== i.lowerLimit ? i.lowerLimit : 0, this.upperLimit = void 0 !== i.upperLimit ? i.upperLimit : 1, this.upperLimitEquation = new s(t, e), this.lowerLimitEquation = new s(t, e), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = u, this.motorEquation = new r(t, e), this.motorEnabled = !1, this.motorSpeed = 0;
                var v = this,
                    b = this.motorEquation;
                b.computeGW;
                b.computeGq = function() {
                    return 0
                }, b.computeGW = function() {
                    var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        n = e.velocity,
                        s = i.velocity,
                        r = e.angularVelocity,
                        o = i.angularVelocity;
                    return this.gmult(t, n, r, s, o) + v.motorSpeed
                }
            }
            e.exports = h, h.prototype = new n, h.prototype.constructor = h;
            var l = o.create(),
                c = o.create(),
                u = o.create(),
                d = o.create(),
                p = o.create(),
                f = o.create();
            h.prototype.update = function() {
                var t = this.equations,
                    e = t[0],
                    i = this.upperLimit,
                    n = this.lowerLimit,
                    s = this.upperLimitEquation,
                    r = this.lowerLimitEquation,
                    a = this.bodyA,
                    h = this.bodyB,
                    g = this.localAxisA,
                    m = this.localAnchorA,
                    y = this.localAnchorB;
                e.updateJacobian(), o.rotate(l, g, a.angle), o.rotate(d, m, a.angle), o.add(c, d, a.position), o.rotate(p, y, h.angle), o.add(u, p, h.position);
                var v, b = this.position = o.dot(u, l) - o.dot(c, l);
                if (this.motorEnabled) {
                    var x = this.motorEquation.G;
                    x[0] = l[0], x[1] = l[1], x[2] = o.crossLength(l, p), x[3] = -l[0], x[4] = -l[1], x[5] = -o.crossLength(l, d)
                }
                this.upperLimitEnabled && b > i ? (o.scale(s.normalA, l, -1), o.sub(s.contactPointA, c, a.position), o.sub(s.contactPointB, u, h.position), o.scale(f, l, i), o.add(s.contactPointA, s.contactPointA, f), -1 === t.indexOf(s) && t.push(s)) : -1 !== (v = t.indexOf(s)) && t.splice(v, 1);
                this.lowerLimitEnabled && b < n ? (o.scale(r.normalA, l, 1), o.sub(r.contactPointA, c, a.position), o.sub(r.contactPointB, u, h.position), o.scale(f, l, n), o.sub(r.contactPointB, r.contactPointB, f), -1 === t.indexOf(r) && t.push(r)) : -1 !== (v = t.indexOf(r)) && t.splice(v, 1)
            }, h.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, h.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, h.prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            }
        }, {
            "../equations/ContactEquation": 21,
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        19: [function(t, e, i) {
            var n = t("./Constraint"),
                s = t("../equations/Equation"),
                r = t("../equations/RotationalVelocityEquation"),
                o = t("../equations/RotationalLockEquation"),
                a = t("../math/vec2");
            e.exports = p;
            var h = a.create(),
                l = a.create(),
                c = a.fromValues(1, 0),
                u = a.fromValues(0, 1),
                d = a.create();

            function p(t, e, i) {
                i = i || {}, n.call(this, t, e, n.REVOLUTE, i);
                var p = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE;
                this.pivotA = a.create(), this.pivotB = a.create(), i.worldPivot ? (a.sub(this.pivotA, i.worldPivot, t.position), a.sub(this.pivotB, i.worldPivot, e.position), a.rotate(this.pivotA, this.pivotA, -t.angle), a.rotate(this.pivotB, this.pivotB, -e.angle)) : (a.copy(this.pivotA, i.localPivotA), a.copy(this.pivotB, i.localPivotB));
                var f = this.equations = [new s(t, e, -p, p), new s(t, e, -p, p)],
                    g = f[0],
                    m = f[1],
                    y = this;
                g.computeGq = function() {
                    return a.rotate(h, y.pivotA, t.angle), a.rotate(l, y.pivotB, e.angle), a.add(d, e.position, l), a.sub(d, d, t.position), a.sub(d, d, h), a.dot(d, c)
                }, m.computeGq = function() {
                    return a.rotate(h, y.pivotA, t.angle), a.rotate(l, y.pivotB, e.angle), a.add(d, e.position, l), a.sub(d, d, t.position), a.sub(d, d, h), a.dot(d, u)
                }, m.minForce = g.minForce = -p, m.maxForce = g.maxForce = p, this.motorEquation = new r(t, e), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new o(t, e), this.lowerLimitEquation = new o(t, e), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
            }
            p.prototype = new n, p.prototype.constructor = p, p.prototype.setLimits = function(t, e) {
                "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
            }, p.prototype.update = function() {
                var t, e = this.bodyA,
                    i = this.bodyB,
                    n = this.pivotA,
                    s = this.pivotB,
                    r = this.equations,
                    o = (r[0], r[1], r[0]),
                    d = r[1],
                    p = this.upperLimit,
                    f = this.lowerLimit,
                    g = this.upperLimitEquation,
                    m = this.lowerLimitEquation,
                    y = this.angle = i.angle - e.angle;
                this.upperLimitEnabled && y > p ? (g.angle = p, -1 === r.indexOf(g) && r.push(g)) : -1 !== (t = r.indexOf(g)) && r.splice(t, 1);
                this.lowerLimitEnabled && y < f ? (m.angle = f, -1 === r.indexOf(m) && r.push(m)) : -1 !== (t = r.indexOf(m)) && r.splice(t, 1);
                a.rotate(h, n, e.angle), a.rotate(l, s, i.angle), o.G[0] = -1, o.G[1] = 0, o.G[2] = -a.crossLength(h, c), o.G[3] = 1, o.G[4] = 0, o.G[5] = a.crossLength(l, c), d.G[0] = 0, d.G[1] = -1, d.G[2] = -a.crossLength(h, u), d.G[3] = 0, d.G[4] = 1, d.G[5] = a.crossLength(l, u)
            }, p.prototype.enableMotor = function() {
                this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
            }, p.prototype.disableMotor = function() {
                if (this.motorEnabled) {
                    var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1
                }
            }, p.prototype.motorIsEnabled = function() {
                return !!this.motorEnabled
            }, p.prototype.setMotorSpeed = function(t) {
                if (this.motorEnabled) {
                    var e = this.equations.indexOf(this.motorEquation);
                    this.equations[e].relativeVelocity = t
                }
            }, p.prototype.getMotorSpeed = function() {
                return !!this.motorEnabled && this.motorEquation.relativeVelocity
            }
        }, {
            "../equations/Equation": 22,
            "../equations/RotationalLockEquation": 24,
            "../equations/RotationalVelocityEquation": 25,
            "../math/vec2": 30,
            "./Constraint": 14
        }],
        20: [function(t, e, i) {
            var n = t("./Equation");
            t("../math/vec2");

            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, this.setRatio(this.ratio)
            }
            e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeGq = function() {
                return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
            }, s.prototype.setRatio = function(t) {
                var e = this.G;
                e[2] = t, e[5] = -1, this.ratio = t
            }, s.prototype.setMaxTorque = function(t) {
                this.maxForce = t, this.minForce = -t
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        21: [function(t, e, i) {
            var n = t("./Equation"),
                s = t("../math/vec2");

            function r(t, e) {
                n.call(this, t, e, 0, Number.MAX_VALUE), this.contactPointA = s.create(), this.penetrationVec = s.create(), this.contactPointB = s.create(), this.normalA = s.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null
            }
            e.exports = r, r.prototype = new n, r.prototype.constructor = r, r.prototype.computeB = function(t, e, i) {
                var n, r, o = this.bodyA,
                    a = this.bodyB,
                    h = this.contactPointA,
                    l = this.contactPointB,
                    c = o.position,
                    u = a.position,
                    d = this.penetrationVec,
                    p = this.normalA,
                    f = this.G,
                    g = s.crossLength(h, p),
                    m = s.crossLength(l, p);
                return f[0] = -p[0], f[1] = -p[1], f[2] = -g, f[3] = p[0], f[4] = p[1], f[5] = m, s.add(d, u, l), s.sub(d, d, c), s.sub(d, d, h), this.firstImpact && 0 !== this.restitution ? (r = 0, n = 1 / e * (1 + this.restitution) * this.computeGW()) : (r = s.dot(p, d) + this.offset, n = this.computeGW()), -r * t - n * e - i * this.computeGiMf()
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        22: [function(t, e, i) {
            e.exports = r;
            var n = t("../math/vec2"),
                s = t("../utils/Utils");
            t("../objects/Body");

            function r(t, e, i, n) {
                this.minForce = void 0 === i ? -Number.MAX_VALUE : i, this.maxForce = void 0 === n ? Number.MAX_VALUE : n, this.bodyA = t, this.bodyB = e, this.stiffness = r.DEFAULT_STIFFNESS, this.relaxation = r.DEFAULT_RELAXATION, this.G = new s.ARRAY_TYPE(6);
                for (var o = 0; o < 6; o++) this.G[o] = 0;
                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
            }
            r.prototype.constructor = r, r.DEFAULT_STIFFNESS = 1e6, r.DEFAULT_RELAXATION = 4, r.prototype.update = function() {
                var t = this.stiffness,
                    e = this.relaxation,
                    i = this.timeStep;
                this.a = 4 / (i * (1 + 4 * e)), this.b = 4 * e / (1 + 4 * e), this.epsilon = 4 / (i * i * t * (1 + 4 * e)), this.needsUpdate = !1
            }, r.prototype.gmult = function(t, e, i, n, s) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * n[0] + t[4] * n[1] + t[5] * s
            }, r.prototype.computeB = function(t, e, i) {
                var n = this.computeGW();
                return -this.computeGq() * t - n * e - this.computeGiMf() * i
            };
            var o = n.create(),
                a = n.create();
            r.prototype.computeGq = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    n = (e.position, i.position, e.angle),
                    s = i.angle;
                return this.gmult(t, o, n, a, s) + this.offset
            }, r.prototype.computeGW = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    n = e.velocity,
                    s = i.velocity,
                    r = e.angularVelocity,
                    o = i.angularVelocity;
                return this.gmult(t, n, r, s, o) + this.relativeVelocity
            }, r.prototype.computeGWlambda = function() {
                var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    n = e.vlambda,
                    s = i.vlambda,
                    r = e.wlambda,
                    o = i.wlambda;
                return this.gmult(t, n, r, s, o)
            };
            var h = n.create(),
                l = n.create();
            r.prototype.computeGiMf = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.force,
                    s = t.angularForce,
                    r = e.force,
                    o = e.angularForce,
                    a = t.invMassSolve,
                    c = e.invMassSolve,
                    u = t.invInertiaSolve,
                    d = e.invInertiaSolve,
                    p = this.G;
                return n.scale(h, i, a), n.multiply(h, t.massMultiplier, h), n.scale(l, r, c), n.multiply(l, e.massMultiplier, l), this.gmult(p, h, s * u, l, o * d)
            }, r.prototype.computeGiMGt = function() {
                var t = this.bodyA,
                    e = this.bodyB,
                    i = t.invMassSolve,
                    n = e.invMassSolve,
                    s = t.invInertiaSolve,
                    r = e.invInertiaSolve,
                    o = this.G;
                return o[0] * o[0] * i * t.massMultiplier[0] + o[1] * o[1] * i * t.massMultiplier[1] + o[2] * o[2] * s + o[3] * o[3] * n * e.massMultiplier[0] + o[4] * o[4] * n * e.massMultiplier[1] + o[5] * o[5] * r
            };
            var c = n.create(),
                u = n.create(),
                d = n.create();
            n.create(), n.create(), n.create();
            r.prototype.addToWlambda = function(t) {
                var e = this.bodyA,
                    i = this.bodyB,
                    s = c,
                    r = u,
                    o = d,
                    a = e.invMassSolve,
                    h = i.invMassSolve,
                    l = e.invInertiaSolve,
                    p = i.invInertiaSolve,
                    f = this.G;
                r[0] = f[0], r[1] = f[1], o[0] = f[3], o[1] = f[4], n.scale(s, r, a * t), n.multiply(s, s, e.massMultiplier), n.add(e.vlambda, e.vlambda, s), e.wlambda += l * f[2] * t, n.scale(s, o, h * t), n.multiply(s, s, i.massMultiplier), n.add(i.vlambda, i.vlambda, s), i.wlambda += p * f[5] * t
            }, r.prototype.computeInvC = function(t) {
                return 1 / (this.computeGiMGt() + t)
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        23: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = t("./Equation");
            t("../utils/Utils");

            function r(t, e, i) {
                s.call(this, t, e, -i, i), this.contactPointA = n.create(), this.contactPointB = n.create(), this.t = n.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3
            }
            e.exports = r, r.prototype = new s, r.prototype.constructor = r, r.prototype.setSlipForce = function(t) {
                this.maxForce = t, this.minForce = -t
            }, r.prototype.getSlipForce = function() {
                return this.maxForce
            }, r.prototype.computeB = function(t, e, i) {
                this.bodyA, this.bodyB;
                var s = this.contactPointA,
                    r = this.contactPointB,
                    o = this.t,
                    a = this.G;
                return a[0] = -o[0], a[1] = -o[1], a[2] = -n.crossLength(s, o), a[3] = o[0], a[4] = o[1], a[5] = n.crossLength(r, o), -this.computeGW() * e - i * this.computeGiMf()
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Equation": 22
        }],
        24: [function(t, e, i) {
            var n = t("./Equation"),
                s = t("../math/vec2");

            function r(t, e, i) {
                i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0;
                var s = this.G;
                s[2] = 1, s[5] = -1
            }
            e.exports = r, r.prototype = new n, r.prototype.constructor = r;
            var o = s.create(),
                a = s.create(),
                h = s.fromValues(1, 0),
                l = s.fromValues(0, 1);
            r.prototype.computeGq = function() {
                return s.rotate(o, h, this.bodyA.angle + this.angle), s.rotate(a, l, this.bodyB.angle), s.dot(o, a)
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        25: [function(t, e, i) {
            var n = t("./Equation");
            t("../math/vec2");

            function s(t, e) {
                n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1
            }
            e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeB = function(t, e, i) {
                var n = this.G;
                n[2] = -1, n[5] = this.ratio;
                var s = this.computeGiMf();
                return -this.computeGW() * e - i * s
            }
        }, {
            "../math/vec2": 30,
            "./Equation": 22
        }],
        26: [function(t, e, i) {
            var n = function() {};
            e.exports = n, n.prototype = {
                constructor: n,
                on: function(t, e, i) {
                    e.context = i || this, void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    return void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e), this
                },
                has: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    if (e) {
                        if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return !0
                    } else if (void 0 !== i[t]) return !0;
                    return !1
                },
                off: function(t, e) {
                    if (void 0 === this._listeners) return this;
                    var i = this._listeners,
                        n = i[t].indexOf(e);
                    return -1 !== n && i[t].splice(n, 1), this
                },
                emit: function(t) {
                    if (void 0 === this._listeners) return this;
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = 0, n = e.length; i < n; i++) {
                            var s = e[i];
                            s.call(s.context, t)
                        }
                    }
                    return this
                }
            }
        }, {}],
        27: [function(t, e, i) {
            var n = t("./Material"),
                s = t("../equations/Equation");

            function r(t, e, i) {
                if (i = i || {}, !(t instanceof n && e instanceof n)) throw new Error("First two arguments must be Material instances.");
                this.id = r.idCounter++, this.materialA = t, this.materialB = e, this.friction = void 0 !== i.friction ? Number(i.friction) : .3, this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0, this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : s.DEFAULT_STIFFNESS, this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : s.DEFAULT_RELAXATION, this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : s.DEFAULT_STIFFNESS, this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : s.DEFAULT_RELAXATION, this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0, this.contactSkinSize = .005
            }
            e.exports = r, r.idCounter = 0
        }, {
            "../equations/Equation": 22,
            "./Material": 28
        }],
        28: [function(t, e, i) {
            function n(t) {
                this.id = t || n.idCounter++
            }
            e.exports = n, n.idCounter = 0
        }, {}],
        29: [function(t, e, i) {
            var n = {
                GetArea: function(t) {
                    if (t.length < 6) return 0;
                    for (var e = t.length - 2, i = 0, n = 0; n < e; n += 2) i += (t[n + 2] - t[n]) * (t[n + 1] + t[n + 3]);
                    return .5 * -(i += (t[0] - t[e]) * (t[e + 1] + t[1]))
                },
                Triangulate: function(t) {
                    var e = t.length >> 1;
                    if (e < 3) return [];
                    for (var i = [], s = [], r = 0; r < e; r++) s.push(r);
                    r = 0;
                    for (var o = e; o > 3;) {
                        var a = s[(r + 0) % o],
                            h = s[(r + 1) % o],
                            l = s[(r + 2) % o],
                            c = t[2 * a],
                            u = t[2 * a + 1],
                            d = t[2 * h],
                            p = t[2 * h + 1],
                            f = t[2 * l],
                            g = t[2 * l + 1],
                            m = !1;
                        if (n._convex(c, u, d, p, f, g)) {
                            m = !0;
                            for (var y = 0; y < o; y++) {
                                var v = s[y];
                                if (v != a && v != h && v != l && n._PointInTriangle(t[2 * v], t[2 * v + 1], c, u, d, p, f, g)) {
                                    m = !1;
                                    break
                                }
                            }
                        }
                        if (m) i.push(a, h, l), s.splice((r + 1) % o, 1), o--, r = 0;
                        else if (r++ > 3 * o) break
                    }
                    return i.push(s[0], s[1], s[2]), i
                },
                _PointInTriangle: function(t, e, i, n, s, r, o, a) {
                    var h = o - i,
                        l = a - n,
                        c = s - i,
                        u = r - n,
                        d = t - i,
                        p = e - n,
                        f = h * h + l * l,
                        g = h * c + l * u,
                        m = h * d + l * p,
                        y = c * c + u * u,
                        v = c * d + u * p,
                        b = 1 / (f * y - g * g),
                        x = (y * m - g * v) * b,
                        w = (f * v - g * m) * b;
                    return x >= 0 && w >= 0 && x + w < 1
                },
                _convex: function(t, e, i, n, s, r) {
                    return (e - n) * (s - i) + (i - t) * (r - n) >= 0
                }
            };
            e.exports = n
        }, {}],
        30: [function(t, e, i) {
            var n = e.exports = {},
                s = t("../utils/Utils");
            n.crossLength = function(t, e) {
                return t[0] * e[1] - t[1] * e[0]
            }, n.crossVZ = function(t, e, i) {
                return n.rotate(t, e, -Math.PI / 2), n.scale(t, t, i), t
            }, n.crossZV = function(t, e, i) {
                return n.rotate(t, i, Math.PI / 2), n.scale(t, t, e), t
            }, n.rotate = function(t, e, i) {
                if (0 !== i) {
                    var n = Math.cos(i),
                        s = Math.sin(i),
                        r = e[0],
                        o = e[1];
                    t[0] = n * r - s * o, t[1] = s * r + n * o
                } else t[0] = e[0], t[1] = e[1]
            }, n.rotate90cw = function(t, e) {
                var i = e[0],
                    n = e[1];
                t[0] = n, t[1] = -i
            }, n.toLocalFrame = function(t, e, i, s) {
                n.copy(t, e), n.sub(t, t, i), n.rotate(t, t, -s)
            }, n.toGlobalFrame = function(t, e, i, s) {
                n.copy(t, e), n.rotate(t, t, s), n.add(t, t, i)
            }, n.vectorToLocalFrame = function(t, e, i) {
                n.rotate(t, e, -i)
            }, n.vectorToGlobalFrame = function(t, e, i) {
                n.rotate(t, e, i)
            }, n.centroid = function(t, e, i, s) {
                return n.add(t, e, i), n.add(t, t, s), n.scale(t, t, 1 / 3), t
            }, n.create = function() {
                var t = new s.ARRAY_TYPE(2);
                return t[0] = 0, t[1] = 0, t
            }, n.clone = function(t) {
                var e = new s.ARRAY_TYPE(2);
                return e[0] = t[0], e[1] = t[1], e
            }, n.fromValues = function(t, e) {
                var i = new s.ARRAY_TYPE(2);
                return i[0] = t, i[1] = e, i
            }, n.copy = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t
            }, n.set = function(t, e, i) {
                return t[0] = e, t[1] = i, t
            }, n.add = function(t, e, i) {
                return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
            }, n.subtract = function(t, e, i) {
                return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
            }, n.sub = n.subtract, n.multiply = function(t, e, i) {
                return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
            }, n.mul = n.multiply, n.divide = function(t, e, i) {
                return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
            }, n.div = n.divide, n.scale = function(t, e, i) {
                return t[0] = e[0] * i, t[1] = e[1] * i, t
            }, n.distance = function(t, e) {
                var i = e[0] - t[0],
                    n = e[1] - t[1];
                return Math.sqrt(i * i + n * n)
            }, n.dist = n.distance, n.squaredDistance = function(t, e) {
                var i = e[0] - t[0],
                    n = e[1] - t[1];
                return i * i + n * n
            }, n.sqrDist = n.squaredDistance, n.length = function(t) {
                var e = t[0],
                    i = t[1];
                return Math.sqrt(e * e + i * i)
            }, n.len = n.length, n.squaredLength = function(t) {
                var e = t[0],
                    i = t[1];
                return e * e + i * i
            }, n.sqrLen = n.squaredLength, n.negate = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t
            }, n.normalize = function(t, e) {
                var i = e[0],
                    n = e[1],
                    s = i * i + n * n;
                return s > 0 && (s = 1 / Math.sqrt(s), t[0] = e[0] * s, t[1] = e[1] * s), t
            }, n.dot = function(t, e) {
                return t[0] * e[0] + t[1] * e[1]
            }, n.str = function(t) {
                return "vec2(" + t[0] + ", " + t[1] + ")"
            }, n.lerp = function(t, e, i, n) {
                var s = e[0],
                    r = e[1];
                return t[0] = s + n * (i[0] - s), t[1] = r + n * (i[1] - r), t
            }, n.reflect = function(t, e, i) {
                var n = e[0] * i[0] + e[1] * i[1];
                t[0] = e[0] - 2 * i[0] * n, t[1] = e[1] - 2 * i[1] * n
            }, n.getLineSegmentsIntersection = function(t, e, i, s, r) {
                var o = n.getLineSegmentsIntersectionFraction(e, i, s, r);
                return !(o < 0) && (t[0] = e[0] + o * (i[0] - e[0]), t[1] = e[1] + o * (i[1] - e[1]), !0)
            }, n.getLineSegmentsIntersectionFraction = function(t, e, i, n) {
                var s, r, o = e[0] - t[0],
                    a = e[1] - t[1],
                    h = n[0] - i[0],
                    l = n[1] - i[1];
                return s = (-a * (t[0] - i[0]) + o * (t[1] - i[1])) / (-h * a + o * l), r = (h * (t[1] - i[1]) - l * (t[0] - i[0])) / (-h * a + o * l), s >= 0 && s <= 1 && r >= 0 && r <= 1 ? r : -1
            }
        }, {
            "../utils/Utils": 57
        }],
        31: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = t("poly-decomp"),
                r = t("../shapes/Convex"),
                o = t("../collision/RaycastResult"),
                a = t("../collision/Ray"),
                h = t("../collision/AABB"),
                l = t("../events/EventEmitter");

            function c(t) {
                t = t || {}, l.call(this), this.id = t.id || ++c._idCounter, this.world = null, this.shapes = [], this.mass = t.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!t.fixedRotation, this.fixedX = !!t.fixedX, this.fixedY = !!t.fixedY, this.massMultiplier = n.create(), this.position = n.fromValues(0, 0), t.position && n.copy(this.position, t.position), this.interpolatedPosition = n.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = n.fromValues(0, 0), this.previousAngle = 0, this.velocity = n.fromValues(0, 0), t.velocity && n.copy(this.velocity, t.velocity), this.vlambda = n.fromValues(0, 0), this.wlambda = 0, this.angle = t.angle || 0, this.angularVelocity = t.angularVelocity || 0, this.force = n.create(), t.force && n.copy(this.force, t.force), this.angularForce = t.angularForce || 0, this.damping = "number" == typeof t.damping ? t.damping : .1, this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1, this.type = c.STATIC, void 0 !== t.type ? this.type = t.type : t.mass ? this.type = c.DYNAMIC : this.type = c.STATIC, this.boundingRadius = 0, this.aabb = new h, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.wantsToSleep = !1, this.sleepState = c.AWAKE, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties()
            }
            e.exports = c, c.prototype = new l, c.prototype.constructor = c, c._idCounter = 0, c.prototype.updateSolveMassProperties = function() {
                this.sleepState === c.SLEEPING || this.type === c.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia)
            }, c.prototype.setDensity = function(t) {
                var e = this.getArea();
                this.mass = e * t, this.updateMassProperties()
            }, c.prototype.getArea = function() {
                for (var t = 0, e = 0; e < this.shapes.length; e++) t += this.shapes[e].area;
                return t
            }, c.prototype.getAABB = function() {
                return this.aabbNeedsUpdate && this.updateAABB(), this.aabb
            };
            var u = new h,
                d = n.create();
            c.prototype.updateAABB = function() {
                for (var t = this.shapes, e = t.length, i = d, s = this.angle, r = 0; r !== e; r++) {
                    var o = t[r],
                        a = o.angle + s;
                    n.rotate(i, o.position, s), n.add(i, i, this.position), o.computeAABB(u, i, a), 0 === r ? this.aabb.copy(u) : this.aabb.extend(u)
                }
                this.aabbNeedsUpdate = !1
            }, c.prototype.updateBoundingRadius = function() {
                for (var t = this.shapes, e = t.length, i = 0, s = 0; s !== e; s++) {
                    var r = t[s],
                        o = n.length(r.position),
                        a = r.boundingRadius;
                    o + a > i && (i = o + a)
                }
                this.boundingRadius = i
            }, c.prototype.addShape = function(t, e, i) {
                if (t.body) throw new Error("A shape can only be added to one body.");
                t.body = this, e ? n.copy(t.position, e) : n.set(t.position, 0, 0), t.angle = i || 0, this.shapes.push(t), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
            }, c.prototype.removeShape = function(t) {
                var e = this.shapes.indexOf(t);
                return -1 !== e && (this.shapes.splice(e, 1), this.aabbNeedsUpdate = !0, t.body = null, !0)
            }, c.prototype.updateMassProperties = function() {
                if (this.type === c.STATIC || this.type === c.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                else {
                    var t = this.shapes,
                        e = t.length,
                        i = this.mass / e,
                        s = 0;
                    if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        for (var r = 0; r < e; r++) {
                            var o = t[r],
                                a = n.squaredLength(o.position);
                            s += o.computeMomentOfInertia(i) + i * a
                        }
                        this.inertia = s, this.invInertia = s > 0 ? 1 / s : 0
                    }
                    this.invMass = 1 / this.mass, n.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                }
            };
            n.create();
            c.prototype.applyForce = function(t, e) {
                if (n.add(this.force, this.force, t), e) {
                    var i = n.crossLength(e, t);
                    this.angularForce += i
                }
            };
            var p = n.create(),
                f = n.create(),
                g = n.create();
            c.prototype.applyForceLocal = function(t, e) {
                e = e || g;
                var i = p,
                    n = f;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(n, e), this.applyForce(i, n)
            };
            var m = n.create();
            c.prototype.applyImpulse = function(t, e) {
                if (this.type === c.DYNAMIC) {
                    var i = m;
                    if (n.scale(i, t, this.invMass), n.multiply(i, this.massMultiplier, i), n.add(this.velocity, i, this.velocity), e) {
                        var s = n.crossLength(e, t);
                        s *= this.invInertia, this.angularVelocity += s
                    }
                }
            };
            var y = n.create(),
                v = n.create(),
                b = n.create();
            c.prototype.applyImpulseLocal = function(t, e) {
                e = e || b;
                var i = y,
                    n = v;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(n, e), this.applyImpulse(i, n)
            }, c.prototype.toLocalFrame = function(t, e) {
                n.toLocalFrame(t, e, this.position, this.angle)
            }, c.prototype.toWorldFrame = function(t, e) {
                n.toGlobalFrame(t, e, this.position, this.angle)
            }, c.prototype.vectorToLocalFrame = function(t, e) {
                n.vectorToLocalFrame(t, e, this.angle)
            }, c.prototype.vectorToWorldFrame = function(t, e) {
                n.vectorToGlobalFrame(t, e, this.angle)
            }, c.prototype.fromPolygon = function(t, e) {
                e = e || {};
                for (var i = this.shapes.length; i >= 0; --i) this.removeShape(this.shapes[i]);
                var o, a = new s.Polygon;
                if (a.vertices = t, a.makeCCW(), "number" == typeof e.removeCollinearPoints && a.removeCollinearPoints(e.removeCollinearPoints), void 0 === e.skipSimpleCheck && !a.isSimple()) return !1;
                this.concavePath = a.vertices.slice(0);
                for (i = 0; i < this.concavePath.length; i++) {
                    var h = [0, 0];
                    n.copy(h, this.concavePath[i]), this.concavePath[i] = h
                }
                o = e.optimalDecomp ? a.decomp() : a.quickDecomp();
                var l = n.create();
                for (i = 0; i !== o.length; i++) {
                    for (var c = new r({
                            vertices: o[i].vertices
                        }), u = 0; u !== c.vertices.length; u++) {
                        h = c.vertices[u];
                        n.sub(h, h, c.centerOfMass)
                    }
                    n.scale(l, c.centerOfMass, 1), c.updateTriangles(), c.updateCenterOfMass(), c.updateBoundingRadius(), this.addShape(c, l)
                }
                return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0
            };
            n.fromValues(0, 0);
            var x = n.fromValues(0, 0),
                w = n.fromValues(0, 0),
                _ = n.fromValues(0, 0);
            c.prototype.adjustCenterOfMass = function() {
                var t = x,
                    e = w,
                    i = _,
                    s = 0;
                n.set(e, 0, 0);
                for (var r = 0; r !== this.shapes.length; r++) {
                    var o = this.shapes[r];
                    n.scale(t, o.position, o.area), n.add(e, e, t), s += o.area
                }
                n.scale(i, e, 1 / s);
                for (r = 0; r !== this.shapes.length; r++) {
                    o = this.shapes[r];
                    n.sub(o.position, o.position, i)
                }
                n.add(this.position, this.position, i);
                for (r = 0; this.concavePath && r < this.concavePath.length; r++) n.sub(this.concavePath[r], this.concavePath[r], i);
                this.updateMassProperties(), this.updateBoundingRadius()
            }, c.prototype.setZeroForce = function() {
                n.set(this.force, 0, 0), this.angularForce = 0
            }, c.prototype.resetConstraintVelocity = function() {
                var t = this.vlambda;
                n.set(t, 0, 0), this.wlambda = 0
            }, c.prototype.addConstraintVelocity = function() {
                var t = this,
                    e = t.velocity;
                n.add(e, e, t.vlambda), t.angularVelocity += t.wlambda
            }, c.prototype.applyDamping = function(t) {
                if (this.type === c.DYNAMIC) {
                    var e = this.velocity;
                    n.scale(e, e, Math.pow(1 - this.damping, t)), this.angularVelocity *= Math.pow(1 - this.angularDamping, t)
                }
            }, c.prototype.wakeUp = function() {
                var t = this.sleepState;
                this.sleepState = c.AWAKE, this.idleTime = 0, t !== c.AWAKE && this.emit(c.wakeUpEvent)
            }, c.prototype.sleep = function() {
                this.sleepState = c.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, n.set(this.velocity, 0, 0), n.set(this.force, 0, 0), this.emit(c.sleepEvent)
            }, c.prototype.sleepTick = function(t, e, i) {
                if (this.allowSleep && this.type !== c.SLEEPING) {
                    this.wantsToSleep = !1;
                    this.sleepState;
                    n.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2) >= Math.pow(this.sleepSpeedLimit, 2) ? (this.idleTime = 0, this.sleepState = c.AWAKE) : (this.idleTime += i, this.sleepState = c.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep())
                }
            }, c.prototype.overlaps = function(t) {
                return this.world.overlapKeeper.bodiesAreOverlapping(this, t)
            };
            var P = n.create(),
                T = n.create();
            c.prototype.integrate = function(t) {
                var e = this.invMass,
                    i = this.force,
                    s = this.position,
                    r = this.velocity;
                n.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t), n.scale(P, i, t * e), n.multiply(P, this.massMultiplier, P), n.add(r, P, r), this.integrateToTimeOfImpact(t) || (n.scale(T, r, t), n.add(s, s, T), this.fixedRotation || (this.angle += this.angularVelocity * t)), this.aabbNeedsUpdate = !0
            };
            var S = new o,
                C = new a({
                    mode: a.ALL
                }),
                A = n.create(),
                E = n.create(),
                M = n.create(),
                I = n.create();
            c.prototype.integrateToTimeOfImpact = function(t) {
                if (this.ccdSpeedThreshold < 0 || n.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                n.normalize(A, this.velocity), n.scale(E, this.velocity, t), n.add(E, E, this.position), n.sub(M, E, this.position);
                var e, i = this.angularVelocity * t,
                    s = n.length(M),
                    r = 1,
                    o = this;
                if (S.reset(), C.callback = function(t) {
                        t.body !== o && (e = t.body, t.getHitPoint(E, C), n.sub(M, E, o.position), r = n.length(M) / s, t.stop())
                    }, n.copy(C.from, this.position), n.copy(C.to, E), C.update(), this.world.raycast(S, C), !e) return !1;
                var a = this.angle;
                n.copy(I, this.position);
                for (var h = 0, l = 0, c = 0, u = r; u >= l && h < this.ccdIterations;) {
                    h++, c = (u - l) / 2, n.scale(T, M, r), n.add(this.position, I, T), this.angle = a + i * r, this.updateAABB(), this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? l = c : u = c
                }
                return r = c, n.copy(this.position, I), this.angle = a, n.scale(T, M, r), n.add(this.position, this.position, T), this.fixedRotation || (this.angle += i * r), !0
            }, c.prototype.getVelocityAtPoint = function(t, e) {
                return n.crossVZ(t, e, this.angularVelocity), n.subtract(t, this.velocity, t), t
            }, c.sleepyEvent = {
                type: "sleepy"
            }, c.sleepEvent = {
                type: "sleep"
            }, c.wakeUpEvent = {
                type: "wakeup"
            }, c.DYNAMIC = 1, c.STATIC = 2, c.KINEMATIC = 4, c.AWAKE = 0, c.SLEEPY = 1, c.SLEEPING = 2
        }, {
            "../collision/AABB": 7,
            "../collision/Ray": 11,
            "../collision/RaycastResult": 12,
            "../events/EventEmitter": 26,
            "../math/vec2": 30,
            "../shapes/Convex": 40,
            "poly-decomp": 5
        }],
        32: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = t("./Spring");
            t("../utils/Utils");

            function r(t, e, i) {
                i = i || {}, s.call(this, t, e, i), this.localAnchorA = n.fromValues(0, 0), this.localAnchorB = n.fromValues(0, 0), i.localAnchorA && n.copy(this.localAnchorA, i.localAnchorA), i.localAnchorB && n.copy(this.localAnchorB, i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                var r = n.create(),
                    o = n.create();
                this.getWorldAnchorA(r), this.getWorldAnchorB(o);
                var a = n.distance(r, o);
                this.restLength = "number" == typeof i.restLength ? i.restLength : a
            }
            e.exports = r, r.prototype = new s, r.prototype.constructor = r, r.prototype.setWorldAnchorA = function(t) {
                this.bodyA.toLocalFrame(this.localAnchorA, t)
            }, r.prototype.setWorldAnchorB = function(t) {
                this.bodyB.toLocalFrame(this.localAnchorB, t)
            }, r.prototype.getWorldAnchorA = function(t) {
                this.bodyA.toWorldFrame(t, this.localAnchorA)
            }, r.prototype.getWorldAnchorB = function(t) {
                this.bodyB.toWorldFrame(t, this.localAnchorB)
            };
            var o = n.create(),
                a = n.create(),
                h = n.create(),
                l = n.create(),
                c = n.create(),
                u = n.create(),
                d = n.create(),
                p = n.create(),
                f = n.create();
            r.prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restLength,
                    s = this.bodyA,
                    r = this.bodyB,
                    g = o,
                    m = a,
                    y = h,
                    v = l,
                    b = f,
                    x = c,
                    w = u,
                    _ = d,
                    P = p;
                this.getWorldAnchorA(x), this.getWorldAnchorB(w), n.sub(_, x, s.position), n.sub(P, w, r.position), n.sub(g, w, x);
                var T = n.len(g);
                n.normalize(m, g), n.sub(y, r.velocity, s.velocity), n.crossZV(b, r.angularVelocity, P), n.add(y, y, b), n.crossZV(b, s.angularVelocity, _), n.sub(y, y, b), n.scale(v, m, -t * (T - i) - e * n.dot(y, m)), n.sub(s.force, s.force, v), n.add(r.force, r.force, v);
                var S = n.crossLength(_, v),
                    C = n.crossLength(P, v);
                s.angularForce -= S, r.angularForce += C
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Spring": 34
        }],
        33: [function(t, e, i) {
            t("../math/vec2");
            var n = t("./Spring");

            function s(t, e, i) {
                i = i || {}, n.call(this, t, e, i), this.restAngle = "number" == typeof i.restAngle ? i.restAngle : e.angle - t.angle
            }
            e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.applyForce = function() {
                var t = this.stiffness,
                    e = this.damping,
                    i = this.restAngle,
                    n = this.bodyA,
                    s = this.bodyB,
                    r = -t * (s.angle - n.angle - i) - e * (s.angularVelocity - n.angularVelocity) * 0;
                n.angularForce -= r, s.angularForce += r
            }
        }, {
            "../math/vec2": 30,
            "./Spring": 34
        }],
        34: [function(t, e, i) {
            t("../math/vec2");
            var n = t("../utils/Utils");

            function s(t, e, i) {
                i = n.defaults(i, {
                    stiffness: 100,
                    damping: 1
                }), this.stiffness = i.stiffness, this.damping = i.damping, this.bodyA = t, this.bodyB = e
            }
            e.exports = s, s.prototype.applyForce = function() {}
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57
        }],
        35: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = (t("../utils/Utils"), t("../constraints/Constraint")),
                r = t("../equations/FrictionEquation"),
                o = t("../objects/Body");

            function a(t, e) {
                e = e || {}, this.chassisBody = t, this.wheels = [], this.groundBody = new o({
                    mass: 0
                }), this.world = null;
                var i = this;
                this.preStepCallback = function() {
                    i.update()
                }
            }

            function h(t, e) {
                e = e || {}, this.vehicle = t, this.forwardEquation = new r(t.chassisBody, t.groundBody), this.sideEquation = new r(t.chassisBody, t.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5), this.localForwardVector = n.fromValues(0, 1), e.localForwardVector && n.copy(this.localForwardVector, e.localForwardVector), this.localPosition = n.fromValues(0, 0), e.localPosition && n.copy(this.localPosition, e.localPosition), s.apply(this, t.chassisBody, t.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0)
            }
            e.exports = a, a.prototype.addToWorld = function(t) {
                this.world = t, t.addBody(this.groundBody), t.on("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.addConstraint(i)
                }
            }, a.prototype.removeFromWorld = function() {
                var t = this.world;
                t.removeBody(this.groundBody), t.off("preStep", this.preStepCallback);
                for (var e = 0; e < this.wheels.length; e++) {
                    var i = this.wheels[e];
                    t.removeConstraint(i)
                }
                this.world = null
            }, a.prototype.addWheel = function(t) {
                var e = new h(this, t);
                return this.wheels.push(e), e
            }, a.prototype.update = function() {
                for (var t = 0; t < this.wheels.length; t++) this.wheels[t].update()
            }, h.prototype = new s, h.prototype.setBrakeForce = function(t) {
                this.forwardEquation.setSlipForce(t)
            }, h.prototype.setSideFriction = function(t) {
                this.sideEquation.setSlipForce(t)
            };
            var l = n.create(),
                c = n.create();
            h.prototype.getSpeed = function() {
                return this.vehicle.chassisBody.vectorToWorldFrame(c, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(l, c), n.dot(l, c)
            };
            var u = n.create();
            h.prototype.update = function() {
                this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), n.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), n.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), n.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), n.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), n.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), n.normalize(u, this.forwardEquation.t), n.scale(u, u, this.engineForce), this.vehicle.chassisBody.applyForce(u, this.forwardEquation.contactPointA)
            }
        }, {
            "../constraints/Constraint": 14,
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../utils/Utils": 57
        }],
        36: [function(t, e, i) {
            var n = e.exports = {
                AABB: t("./collision/AABB"),
                AngleLockEquation: t("./equations/AngleLockEquation"),
                Body: t("./objects/Body"),
                Broadphase: t("./collision/Broadphase"),
                Capsule: t("./shapes/Capsule"),
                Circle: t("./shapes/Circle"),
                Constraint: t("./constraints/Constraint"),
                ContactEquation: t("./equations/ContactEquation"),
                ContactEquationPool: t("./utils/ContactEquationPool"),
                ContactMaterial: t("./material/ContactMaterial"),
                Convex: t("./shapes/Convex"),
                DistanceConstraint: t("./constraints/DistanceConstraint"),
                Equation: t("./equations/Equation"),
                EventEmitter: t("./events/EventEmitter"),
                FrictionEquation: t("./equations/FrictionEquation"),
                FrictionEquationPool: t("./utils/FrictionEquationPool"),
                GearConstraint: t("./constraints/GearConstraint"),
                GSSolver: t("./solver/GSSolver"),
                Heightfield: t("./shapes/Heightfield"),
                Line: t("./shapes/Line"),
                LockConstraint: t("./constraints/LockConstraint"),
                Material: t("./material/Material"),
                Narrowphase: t("./collision/Narrowphase"),
                NaiveBroadphase: t("./collision/NaiveBroadphase"),
                Particle: t("./shapes/Particle"),
                Plane: t("./shapes/Plane"),
                Pool: t("./utils/Pool"),
                RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                Ray: t("./collision/Ray"),
                RaycastResult: t("./collision/RaycastResult"),
                Box: t("./shapes/Box"),
                RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                SAPBroadphase: t("./collision/SAPBroadphase"),
                Shape: t("./shapes/Shape"),
                Solver: t("./solver/Solver"),
                Spring: t("./objects/Spring"),
                TopDownVehicle: t("./objects/TopDownVehicle"),
                LinearSpring: t("./objects/LinearSpring"),
                RotationalSpring: t("./objects/RotationalSpring"),
                Utils: t("./utils/Utils"),
                World: t("./world/World"),
                vec2: t("./math/vec2"),
                version: t("../package.json").version
            };
            Object.defineProperty(n, "Rectangle", {
                get: function() {
                    return this.Box
                }
            })
        }, {
            "../package.json": 6,
            "./collision/AABB": 7,
            "./collision/Broadphase": 8,
            "./collision/NaiveBroadphase": 9,
            "./collision/Narrowphase": 10,
            "./collision/Ray": 11,
            "./collision/RaycastResult": 12,
            "./collision/SAPBroadphase": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/GearConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PrismaticConstraint": 18,
            "./constraints/RevoluteConstraint": 19,
            "./equations/AngleLockEquation": 20,
            "./equations/ContactEquation": 21,
            "./equations/Equation": 22,
            "./equations/FrictionEquation": 23,
            "./equations/RotationalVelocityEquation": 25,
            "./events/EventEmitter": 26,
            "./material/ContactMaterial": 27,
            "./material/Material": 28,
            "./math/vec2": 30,
            "./objects/Body": 31,
            "./objects/LinearSpring": 32,
            "./objects/RotationalSpring": 33,
            "./objects/Spring": 34,
            "./objects/TopDownVehicle": 35,
            "./shapes/Box": 37,
            "./shapes/Capsule": 38,
            "./shapes/Circle": 39,
            "./shapes/Convex": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Line": 42,
            "./shapes/Particle": 43,
            "./shapes/Plane": 44,
            "./shapes/Shape": 45,
            "./solver/GSSolver": 46,
            "./solver/Solver": 47,
            "./utils/ContactEquationPool": 48,
            "./utils/FrictionEquationPool": 49,
            "./utils/Pool": 55,
            "./utils/Utils": 57,
            "./world/World": 61
        }],
        37: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = t("./Shape"),
                r = t("./Convex");

            function o(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    width: arguments[0],
                    height: arguments[1]
                }), t = t || {};
                var e = this.width = t.width || 1,
                    i = this.height = t.height || 1,
                    o = [n.fromValues(-e / 2, -i / 2), n.fromValues(e / 2, -i / 2), n.fromValues(e / 2, i / 2), n.fromValues(-e / 2, i / 2)],
                    a = [n.fromValues(1, 0), n.fromValues(0, 1)];
                t.vertices = o, t.axes = a, t.type = s.BOX, r.call(this, t)
            }
            e.exports = o, o.prototype = new r, o.prototype.constructor = o, o.prototype.computeMomentOfInertia = function(t) {
                var e = this.width,
                    i = this.height;
                return t * (i * i + e * e) / 12
            }, o.prototype.updateBoundingRadius = function() {
                var t = this.width,
                    e = this.height;
                this.boundingRadius = Math.sqrt(t * t + e * e) / 2
            };
            n.create(), n.create(), n.create(), n.create();
            o.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            }, o.prototype.updateArea = function() {
                this.area = this.width * this.height
            }
        }, {
            "../math/vec2": 30,
            "./Convex": 40,
            "./Shape": 45
        }],
        38: [function(t, e, i) {
            var n = t("./Shape"),
                s = t("../math/vec2");

            function r(t) {
                "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                    length: arguments[0],
                    radius: arguments[1]
                }), t = t || {}, this.length = t.length || 1, this.radius = t.radius || 1, t.type = n.CAPSULE, n.call(this, t)
            }
            e.exports = r, r.prototype = new n, r.prototype.constructor = r, r.prototype.computeMomentOfInertia = function(t) {
                var e = this.radius,
                    i = this.length + e,
                    n = 2 * e;
                return t * (n * n + i * i) / 12
            }, r.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius + this.length / 2
            }, r.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
            };
            var o = s.create();
            r.prototype.computeAABB = function(t, e, i) {
                var n = this.radius;
                s.set(o, this.length / 2, 0), 0 !== i && s.rotate(o, o, i), s.set(t.upperBound, Math.max(o[0] + n, -o[0] + n), Math.max(o[1] + n, -o[1] + n)), s.set(t.lowerBound, Math.min(o[0] - n, -o[0] - n), Math.min(o[1] - n, -o[1] - n)), s.add(t.lowerBound, t.lowerBound, e), s.add(t.upperBound, t.upperBound, e)
            };
            var a = s.create(),
                h = s.create(),
                l = s.create(),
                c = s.create(),
                u = s.fromValues(0, 1);
            r.prototype.raycast = function(t, e, i, n) {
                for (var r = e.from, o = e.to, d = (e.direction, a), p = h, f = l, g = c, m = this.length / 2, y = 0; y < 2; y++) {
                    var v = this.radius * (2 * y - 1);
                    if (s.set(f, -m, v), s.set(g, m, v), s.toGlobalFrame(f, f, i, n), s.toGlobalFrame(g, g, i, n), (x = s.getLineSegmentsIntersectionFraction(r, o, f, g)) >= 0 && (s.rotate(p, u, n), s.scale(p, p, 2 * y - 1), e.reportIntersection(t, x, p, -1), t.shouldStop(e))) return
                }
                var b = Math.pow(this.radius, 2) + Math.pow(m, 2);
                for (y = 0; y < 2; y++) {
                    s.set(f, m * (2 * y - 1), 0), s.toGlobalFrame(f, f, i, n);
                    var x, w = Math.pow(o[0] - r[0], 2) + Math.pow(o[1] - r[1], 2),
                        _ = 2 * ((o[0] - r[0]) * (r[0] - f[0]) + (o[1] - r[1]) * (r[1] - f[1])),
                        P = Math.pow(r[0] - f[0], 2) + Math.pow(r[1] - f[1], 2) - Math.pow(this.radius, 2);
                    if (!((x = Math.pow(_, 2) - 4 * w * P) < 0))
                        if (0 === x) {
                            if (s.lerp(d, r, o, x), s.squaredDistance(d, i) > b && (s.sub(p, d, f), s.normalize(p, p), e.reportIntersection(t, x, p, -1), t.shouldStop(e))) return
                        } else {
                            var T = Math.sqrt(x),
                                S = 1 / (2 * w),
                                C = (-_ - T) * S,
                                A = (-_ + T) * S;
                            if (C >= 0 && C <= 1 && (s.lerp(d, r, o, C), s.squaredDistance(d, i) > b && (s.sub(p, d, f), s.normalize(p, p), e.reportIntersection(t, C, p, -1), t.shouldStop(e)))) return;
                            if (A >= 0 && A <= 1 && (s.lerp(d, r, o, A), s.squaredDistance(d, i) > b && (s.sub(p, d, f), s.normalize(p, p), e.reportIntersection(t, A, p, -1), t.shouldStop(e)))) return
                        }
                }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        39: [function(t, e, i) {
            var n = t("./Shape"),
                s = t("../math/vec2");

            function r(t) {
                "number" == typeof arguments[0] && (t = {
                    radius: arguments[0]
                }), t = t || {}, this.radius = t.radius || 1, t.type = n.CIRCLE, n.call(this, t)
            }
            e.exports = r, r.prototype = new n, r.prototype.constructor = r, r.prototype.computeMomentOfInertia = function(t) {
                var e = this.radius;
                return t * e * e / 2
            }, r.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.radius
            }, r.prototype.updateArea = function() {
                this.area = Math.PI * this.radius * this.radius
            }, r.prototype.computeAABB = function(t, e, i) {
                var n = this.radius;
                s.set(t.upperBound, n, n), s.set(t.lowerBound, -n, -n), e && (s.add(t.lowerBound, t.lowerBound, e), s.add(t.upperBound, t.upperBound, e))
            };
            var o = s.create(),
                a = s.create();
            r.prototype.raycast = function(t, e, i, n) {
                var r = e.from,
                    h = e.to,
                    l = this.radius,
                    c = Math.pow(h[0] - r[0], 2) + Math.pow(h[1] - r[1], 2),
                    u = 2 * ((h[0] - r[0]) * (r[0] - i[0]) + (h[1] - r[1]) * (r[1] - i[1])),
                    d = Math.pow(r[0] - i[0], 2) + Math.pow(r[1] - i[1], 2) - Math.pow(l, 2),
                    p = Math.pow(u, 2) - 4 * c * d,
                    f = o,
                    g = a;
                if (!(p < 0))
                    if (0 === p) s.lerp(f, r, h, p), s.sub(g, f, i), s.normalize(g, g), e.reportIntersection(t, p, g, -1);
                    else {
                        var m = Math.sqrt(p),
                            y = 1 / (2 * c),
                            v = (-u - m) * y,
                            b = (-u + m) * y;
                        if (v >= 0 && v <= 1 && (s.lerp(f, r, h, v), s.sub(g, f, i), s.normalize(g, g), e.reportIntersection(t, v, g, -1), t.shouldStop(e))) return;
                        b >= 0 && b <= 1 && (s.lerp(f, r, h, b), s.sub(g, f, i), s.normalize(g, g), e.reportIntersection(t, b, g, -1))
                    }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        40: [function(t, e, i) {
            var n = t("./Shape"),
                s = t("../math/vec2"),
                r = t("../math/polyk");
            t("poly-decomp");

            function o(t) {
                Array.isArray(arguments[0]) && (t = {
                    vertices: arguments[0],
                    axes: arguments[1]
                }), t = t || {}, this.vertices = [];
                for (var e = void 0 !== t.vertices ? t.vertices : [], i = 0; i < e.length; i++) {
                    var r = s.create();
                    s.copy(r, e[i]), this.vertices.push(r)
                }
                if (this.axes = [], t.axes)
                    for (i = 0; i < t.axes.length; i++) {
                        var o = s.create();
                        s.copy(o, t.axes[i]), this.axes.push(o)
                    } else
                        for (i = 0; i < this.vertices.length; i++) {
                            var a = this.vertices[i],
                                h = this.vertices[(i + 1) % this.vertices.length],
                                l = s.create();
                            s.sub(l, h, a), s.rotate90cw(l, l), s.normalize(l, l), this.axes.push(l)
                        }
                if (this.centerOfMass = s.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, t.type = n.CONVEX, n.call(this, t), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
            }
            e.exports = o, o.prototype = new n, o.prototype.constructor = o;
            var a = s.create(),
                h = s.create();
            o.prototype.projectOntoLocalAxis = function(t, e) {
                for (var i, n, r = null, o = null, h = (t = a, 0); h < this.vertices.length; h++) i = this.vertices[h], n = s.dot(i, t), (null === r || n > r) && (r = n), (null === o || n < o) && (o = n);
                if (o > r) {
                    var l = o;
                    o = r, r = l
                }
                s.set(e, o, r)
            }, o.prototype.projectOntoWorldAxis = function(t, e, i, n) {
                var r = h;
                this.projectOntoLocalAxis(t, n), 0 !== i ? s.rotate(r, t, i) : r = t;
                var o = s.dot(e, r);
                s.set(n, n[0] + o, n[1] + o)
            }, o.prototype.updateTriangles = function() {
                this.triangles.length = 0;
                for (var t = [], e = 0; e < this.vertices.length; e++) {
                    var i = this.vertices[e];
                    t.push(i[0], i[1])
                }
                var n = r.Triangulate(t);
                for (e = 0; e < n.length; e += 3) {
                    var s = n[e],
                        o = n[e + 1],
                        a = n[e + 2];
                    this.triangles.push([s, o, a])
                }
            };
            var l = s.create(),
                c = s.create(),
                u = s.create(),
                d = s.create(),
                p = s.create();
            s.create(), s.create(), s.create(), s.create();
            o.prototype.updateCenterOfMass = function() {
                var t = this.triangles,
                    e = this.vertices,
                    i = this.centerOfMass,
                    n = l,
                    r = u,
                    a = d,
                    h = p,
                    f = c;
                s.set(i, 0, 0);
                for (var g = 0, m = 0; m !== t.length; m++) {
                    var y = t[m];
                    r = e[y[0]], a = e[y[1]], h = e[y[2]];
                    s.centroid(n, r, a, h);
                    var v = o.triangleArea(r, a, h);
                    g += v, s.scale(f, n, v), s.add(i, i, f)
                }
                s.scale(i, i, 1 / g)
            }, o.prototype.computeMomentOfInertia = function(t) {
                for (var e = 0, i = 0, n = this.vertices.length, r = n - 1, o = 0; o < n; r = o, o++) {
                    var a = this.vertices[r],
                        h = this.vertices[o],
                        l = Math.abs(s.crossLength(a, h));
                    e += l * (s.dot(h, h) + s.dot(h, a) + s.dot(a, a)), i += l
                }
                return t / 6 * (e / i)
            }, o.prototype.updateBoundingRadius = function() {
                for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) {
                    var n = s.squaredLength(t[i]);
                    n > e && (e = n)
                }
                this.boundingRadius = Math.sqrt(e)
            }, o.triangleArea = function(t, e, i) {
                return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]))
            }, o.prototype.updateArea = function() {
                this.updateTriangles(), this.area = 0;
                for (var t = this.triangles, e = this.vertices, i = 0; i !== t.length; i++) {
                    var n = t[i],
                        s = e[n[0]],
                        r = e[n[1]],
                        a = e[n[2]],
                        h = o.triangleArea(s, r, a);
                    this.area += h
                }
            }, o.prototype.computeAABB = function(t, e, i) {
                t.setFromPoints(this.vertices, e, i, 0)
            };
            var f = s.create(),
                g = s.create(),
                m = s.create();
            o.prototype.raycast = function(t, e, i, n) {
                var r = f,
                    o = g,
                    a = m,
                    h = this.vertices;
                s.toLocalFrame(r, e.from, i, n), s.toLocalFrame(o, e.to, i, n);
                for (var l = h.length, c = 0; c < l && !t.shouldStop(e); c++) {
                    var u = h[c],
                        d = h[(c + 1) % l],
                        p = s.getLineSegmentsIntersectionFraction(r, o, u, d);
                    p >= 0 && (s.sub(a, d, u), s.rotate(a, a, -Math.PI / 2 + n), s.normalize(a, a), e.reportIntersection(t, p, a, c))
                }
            }
        }, {
            "../math/polyk": 29,
            "../math/vec2": 30,
            "./Shape": 45,
            "poly-decomp": 5
        }],
        41: [function(t, e, i) {
            var n = t("./Shape"),
                s = t("../math/vec2");
            t("../utils/Utils");

            function r(t) {
                if (Array.isArray(arguments[0]) && (t = {
                        heights: arguments[0]
                    }, "object" == typeof arguments[1]))
                    for (var e in arguments[1]) t[e] = arguments[1][e];
                t = t || {}, this.heights = t.heights ? t.heights.slice(0) : [], this.maxValue = t.maxValue || null, this.minValue = t.minValue || null, this.elementWidth = t.elementWidth || .1, void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(), t.type = n.HEIGHTFIELD, n.call(this, t)
            }
            e.exports = r, r.prototype = new n, r.prototype.constructor = r, r.prototype.updateMaxMinValues = function() {
                for (var t = this.heights, e = t[0], i = t[0], n = 0; n !== t.length; n++) {
                    var s = t[n];
                    s > e && (e = s), s < i && (i = s)
                }
                this.maxValue = e, this.minValue = i
            }, r.prototype.computeMomentOfInertia = function(t) {
                return Number.MAX_VALUE
            }, r.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, r.prototype.updateArea = function() {
                for (var t = this.heights, e = 0, i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                this.area = e
            };
            var o = [s.create(), s.create(), s.create(), s.create()];
            r.prototype.computeAABB = function(t, e, i) {
                s.set(o[0], 0, this.maxValue), s.set(o[1], this.elementWidth * this.heights.length, this.maxValue), s.set(o[2], this.elementWidth * this.heights.length, this.minValue), s.set(o[3], 0, this.minValue), t.setFromPoints(o, e, i)
            }, r.prototype.getLineSegment = function(t, e, i) {
                var n = this.heights,
                    r = this.elementWidth;
                s.set(t, i * r, n[i]), s.set(e, (i + 1) * r, n[i + 1])
            }, r.prototype.getSegmentIndex = function(t) {
                return Math.floor(t[0] / this.elementWidth)
            }, r.prototype.getClampedSegmentIndex = function(t) {
                var e = this.getSegmentIndex(t);
                return e = Math.min(this.heights.length, Math.max(e, 0))
            };
            s.create();
            var a = s.create(),
                h = s.create(),
                l = s.create(),
                c = s.create(),
                u = s.create();
            s.fromValues(0, 1);
            r.prototype.raycast = function(t, e, i, n) {
                var r = e.from,
                    o = e.to,
                    d = (e.direction, a),
                    p = h,
                    f = l,
                    g = c,
                    m = u;
                s.toLocalFrame(g, r, i, n), s.toLocalFrame(m, o, i, n);
                var y = this.getClampedSegmentIndex(g),
                    v = this.getClampedSegmentIndex(m);
                if (y > v) {
                    var b = y;
                    y = v, v = b
                }
                for (var x = 0; x < this.heights.length - 1; x++) {
                    this.getLineSegment(p, f, x);
                    var w = s.getLineSegmentsIntersectionFraction(g, m, p, f);
                    if (w >= 0 && (s.sub(d, f, p), s.rotate(d, d, n + Math.PI / 2), s.normalize(d, d), e.reportIntersection(t, w, d, -1), t.shouldStop(e))) return
                }
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        42: [function(t, e, i) {
            var n = t("./Shape"),
                s = t("../math/vec2");

            function r(t) {
                "number" == typeof arguments[0] && (t = {
                    length: arguments[0]
                }), t = t || {}, this.length = t.length || 1, t.type = n.LINE, n.call(this, t)
            }
            e.exports = r, r.prototype = new n, r.prototype.constructor = r, r.prototype.computeMomentOfInertia = function(t) {
                return t * Math.pow(this.length, 2) / 12
            }, r.prototype.updateBoundingRadius = function() {
                this.boundingRadius = this.length / 2
            };
            var o = [s.create(), s.create()];
            r.prototype.computeAABB = function(t, e, i) {
                var n = this.length / 2;
                s.set(o[0], -n, 0), s.set(o[1], n, 0), t.setFromPoints(o, e, i, 0)
            };
            s.create();
            var a = s.create(),
                h = s.create(),
                l = s.create(),
                c = s.fromValues(0, 1);
            r.prototype.raycast = function(t, e, i, n) {
                var r = e.from,
                    o = e.to,
                    u = h,
                    d = l,
                    p = this.length / 2;
                s.set(u, -p, 0), s.set(d, p, 0), s.toGlobalFrame(u, u, i, n), s.toGlobalFrame(d, d, i, n);
                var f = s.getLineSegmentsIntersectionFraction(u, d, r, o);
                if (f >= 0) {
                    var g = a;
                    s.rotate(g, c, n), e.reportIntersection(t, f, g, -1)
                }
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        43: [function(t, e, i) {
            var n = t("./Shape"),
                s = t("../math/vec2");

            function r(t) {
                (t = t || {}).type = n.PARTICLE, n.call(this, t)
            }
            e.exports = r, r.prototype = new n, r.prototype.constructor = r, r.prototype.computeMomentOfInertia = function(t) {
                return 0
            }, r.prototype.updateBoundingRadius = function() {
                this.boundingRadius = 0
            }, r.prototype.computeAABB = function(t, e, i) {
                s.copy(t.lowerBound, e), s.copy(t.upperBound, e)
            }
        }, {
            "../math/vec2": 30,
            "./Shape": 45
        }],
        44: [function(t, e, i) {
            var n = t("./Shape"),
                s = t("../math/vec2");
            t("../utils/Utils");

            function r(t) {
                (t = t || {}).type = n.PLANE, n.call(this, t)
            }
            e.exports = r, r.prototype = new n, r.prototype.constructor = r, r.prototype.computeMomentOfInertia = function(t) {
                return 0
            }, r.prototype.updateBoundingRadius = function() {
                this.boundingRadius = Number.MAX_VALUE
            }, r.prototype.computeAABB = function(t, e, i) {
                var n = i % (2 * Math.PI),
                    r = s.set,
                    o = Number.MAX_VALUE,
                    a = t.lowerBound,
                    h = t.upperBound;
                0 === n ? (r(a, -o, -o), r(h, o, 0)) : n === Math.PI / 2 ? (r(a, 0, -o), r(h, o, o)) : n === Math.PI ? (r(a, -o, 0), r(h, o, o)) : n === 3 * Math.PI / 2 ? (r(a, -o, -o), r(h, 0, o)) : (r(a, -o, -o), r(h, o, o)), s.add(a, a, e), s.add(h, h, e)
            }, r.prototype.updateArea = function() {
                this.area = Number.MAX_VALUE
            };
            var o = s.create(),
                a = (s.create(), s.create(), s.create()),
                h = s.create();
            r.prototype.raycast = function(t, e, i, n) {
                var r = e.from,
                    l = e.to,
                    c = e.direction,
                    u = o,
                    d = a,
                    p = h;
                s.set(d, 0, 1), s.rotate(d, d, n), s.sub(p, r, i);
                var f = s.dot(p, d);
                if (s.sub(p, l, i), !(f * s.dot(p, d) > 0 || s.squaredDistance(r, l) < f * f)) {
                    var g = s.dot(d, c);
                    s.sub(u, r, i);
                    var m = -s.dot(d, u) / g / e.length;
                    e.reportIntersection(t, m, d, -1)
                }
            }
        }, {
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Shape": 45
        }],
        45: [function(t, e, i) {
            e.exports = s;
            var n = t("../math/vec2");

            function s(t) {
                t = t || {}, this.body = null, this.position = n.fromValues(0, 0), t.position && n.copy(this.position, t.position), this.angle = t.angle || 0, this.type = t.type || 0, this.id = s.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1, this.material = t.material || null, this.area = 0, this.sensor = void 0 !== t.sensor && t.sensor, this.type && this.updateBoundingRadius(), this.updateArea()
            }
            s.idCounter = 0, s.CIRCLE = 1, s.PARTICLE = 2, s.PLANE = 4, s.CONVEX = 8, s.LINE = 16, s.BOX = 32, Object.defineProperty(s, "RECTANGLE", {
                get: function() {
                    return s.BOX
                }
            }), s.CAPSULE = 64, s.HEIGHTFIELD = 128, s.prototype.computeMomentOfInertia = function(t) {}, s.prototype.updateBoundingRadius = function() {}, s.prototype.updateArea = function() {}, s.prototype.computeAABB = function(t, e, i) {}, s.prototype.raycast = function(t, e, i, n) {}
        }, {
            "../math/vec2": 30
        }],
        46: [function(t, e, i) {
            var n = t("../math/vec2"),
                s = t("./Solver"),
                r = t("../utils/Utils"),
                o = t("../equations/FrictionEquation");

            function a(t) {
                s.call(this, t, s.GS), t = t || {}, this.iterations = t.iterations || 10, this.tolerance = t.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new r.ARRAY_TYPE(this.arrayStep), this.Bs = new r.ARRAY_TYPE(this.arrayStep), this.invCs = new r.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0
            }
            e.exports = a, a.prototype = new s, a.prototype.constructor = a, a.prototype.solve = function(t, e) {
                this.sortEquations();
                var i = 0,
                    s = this.iterations,
                    h = this.frictionIterations,
                    l = this.equations,
                    c = l.length,
                    u = Math.pow(this.tolerance * c, 2),
                    d = e.bodies,
                    p = e.bodies.length,
                    f = (n.add, n.set, this.useZeroRHS),
                    g = this.lambda;
                if (this.usedIterations = 0, c)
                    for (var m = 0; m !== p; m++) {
                        d[m].updateSolveMassProperties()
                    }
                g.length < c && (g = this.lambda = new r.ARRAY_TYPE(c + this.arrayStep), this.Bs = new r.ARRAY_TYPE(c + this.arrayStep), this.invCs = new r.ARRAY_TYPE(c + this.arrayStep)),
                    function(t) {
                        for (var e = t.length; e--;) t[e] = 0
                    }(g);
                var y, v, b = this.invCs,
                    x = this.Bs;
                for (g = this.lambda, m = 0; m !== l.length; m++) {
                    var w;
                    ((w = l[m]).timeStep !== t || w.needsUpdate) && (w.timeStep = t, w.update()), x[m] = w.computeB(w.a, w.b, t), b[m] = w.computeInvC(w.epsilon)
                }
                if (0 !== c) {
                    for (m = 0; m !== p; m++) {
                        d[m].resetConstraintVelocity()
                    }
                    if (h) {
                        for (i = 0; i !== h; i++) {
                            for (y = 0, v = 0; v !== c; v++) {
                                w = l[v];
                                var _ = a.iterateEquation(v, w, w.epsilon, x, b, g, f, t, i);
                                y += Math.abs(_)
                            }
                            if (this.usedIterations++, y * y <= u) break
                        }
                        for (a.updateMultipliers(l, g, 1 / t), v = 0; v !== c; v++) {
                            var P = l[v];
                            if (P instanceof o) {
                                for (var T = 0, S = 0; S !== P.contactEquations.length; S++) T += P.contactEquations[S].multiplier;
                                T *= P.frictionCoefficient / P.contactEquations.length, P.maxForce = T, P.minForce = -T
                            }
                        }
                    }
                    for (i = 0; i !== s; i++) {
                        for (y = 0, v = 0; v !== c; v++) {
                            w = l[v];
                            _ = a.iterateEquation(v, w, w.epsilon, x, b, g, f, t, i);
                            y += Math.abs(_)
                        }
                        if (this.usedIterations++, y * y <= u) break
                    }
                    for (m = 0; m !== p; m++) d[m].addConstraintVelocity();
                    a.updateMultipliers(l, g, 1 / t)
                }
            }, a.updateMultipliers = function(t, e, i) {
                for (var n = t.length; n--;) t[n].multiplier = e[n] * i
            }, a.iterateEquation = function(t, e, i, n, s, r, o, a, h) {
                var l = n[t],
                    c = s[t],
                    u = r[t],
                    d = e.computeGWlambda(),
                    p = e.maxForce,
                    f = e.minForce;
                o && (l = 0);
                var g = c * (l - d - i * u),
                    m = u + g;
                return m < f * a ? g = f * a - u : m > p * a && (g = p * a - u), r[t] += g, e.addToWlambda(g), g
            }
        }, {
            "../equations/FrictionEquation": 23,
            "../math/vec2": 30,
            "../utils/Utils": 57,
            "./Solver": 47
        }],
        47: [function(t, e, i) {
            t("../utils/Utils");
            var n = t("../events/EventEmitter");

            function s(t, e) {
                t = t || {}, n.call(this), this.type = e, this.equations = [], this.equationSortFunction = t.equationSortFunction || !1
            }
            e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.solve = function(t, e) {
                throw new Error("Solver.solve should be implemented by subclasses!")
            };
            var r = {
                bodies: []
            };
            s.prototype.solveIsland = function(t, e) {
                this.removeAllEquations(), e.equations.length && (this.addEquations(e.equations), r.bodies.length = 0, e.getBodies(r.bodies), r.bodies.length && this.solve(t, r))
            }, s.prototype.sortEquations = function() {
                this.equationSortFunction && this.equations.sort(this.equationSortFunction)
            }, s.prototype.addEquation = function(t) {
                t.enabled && this.equations.push(t)
            }, s.prototype.addEquations = function(t) {
                for (var e = 0, i = t.length; e !== i; e++) {
                    var n = t[e];
                    n.enabled && this.equations.push(n)
                }
            }, s.prototype.removeEquation = function(t) {
                var e = this.equations.indexOf(t); - 1 !== e && this.equations.splice(e, 1)
            }, s.prototype.removeAllEquations = function() {
                this.equations.length = 0
            }, s.GS = 1, s.ISLAND = 2
        }, {
            "../events/EventEmitter": 26,
            "../utils/Utils": 57
        }],
        48: [function(t, e, i) {
            var n = t("../equations/ContactEquation"),
                s = t("./Pool");

            function r() {
                s.apply(this, arguments)
            }
            e.exports = r, r.prototype = new s, r.prototype.constructor = r, r.prototype.create = function() {
                return new n
            }, r.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/ContactEquation": 21,
            "./Pool": 55
        }],
        49: [function(t, e, i) {
            var n = t("../equations/FrictionEquation"),
                s = t("./Pool");

            function r() {
                s.apply(this, arguments)
            }
            e.exports = r, r.prototype = new s, r.prototype.constructor = r, r.prototype.create = function() {
                return new n
            }, r.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = null, this
            }
        }, {
            "../equations/FrictionEquation": 23,
            "./Pool": 55
        }],
        50: [function(t, e, i) {
            var n = t("../world/IslandNode"),
                s = t("./Pool");

            function r() {
                s.apply(this, arguments)
            }
            e.exports = r, r.prototype = new s, r.prototype.constructor = r, r.prototype.create = function() {
                return new n
            }, r.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/IslandNode": 60,
            "./Pool": 55
        }],
        51: [function(t, e, i) {
            var n = t("../world/Island"),
                s = t("./Pool");

            function r() {
                s.apply(this, arguments)
            }
            e.exports = r, r.prototype = new s, r.prototype.constructor = r, r.prototype.create = function() {
                return new n
            }, r.prototype.destroy = function(t) {
                return t.reset(), this
            }
        }, {
            "../world/Island": 58,
            "./Pool": 55
        }],
        52: [function(t, e, i) {
            var n = t("./TupleDictionary"),
                s = (t("./OverlapKeeperRecord"), t("./OverlapKeeperRecordPool"));
            t("./Utils");

            function r() {
                this.overlappingShapesLastState = new n, this.overlappingShapesCurrentState = new n, this.recordPool = new s({
                    size: 16
                }), this.tmpDict = new n, this.tmpArray1 = []
            }
            e.exports = r, r.prototype.tick = function() {
                for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, i = t.keys.length; i--;) {
                    var n = t.keys[i],
                        s = t.getByKey(n);
                    e.getByKey(n);
                    s && this.recordPool.release(s)
                }
                t.reset(), t.copy(e), e.reset()
            }, r.prototype.setOverlapping = function(t, e, i, n) {
                this.overlappingShapesLastState;
                var s = this.overlappingShapesCurrentState;
                if (!s.get(e.id, n.id)) {
                    var r = this.recordPool.get();
                    r.set(t, e, i, n), s.set(e.id, n.id, r)
                }
            }, r.prototype.getNewOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t)
            }, r.prototype.getEndOverlaps = function(t) {
                return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t)
            }, r.prototype.bodiesAreOverlapping = function(t, e) {
                for (var i = this.overlappingShapesCurrentState, n = i.keys.length; n--;) {
                    var s = i.keys[n],
                        r = i.data[s];
                    if (r.bodyA === t && r.bodyB === e || r.bodyA === e && r.bodyB === t) return !0
                }
                return !1
            }, r.prototype.getDiff = function(t, e, i) {
                var n = t,
                    s = e;
                (i = i || []).length = 0;
                for (var r = s.keys.length; r--;) {
                    var o = s.keys[r],
                        a = s.data[o];
                    if (!a) throw new Error("Key " + o + " had no data!");
                    n.data[o] || i.push(a)
                }
                return i
            }, r.prototype.isNewOverlap = function(t, e) {
                var i = 0 | t.id,
                    n = 0 | e.id,
                    s = this.overlappingShapesLastState,
                    r = this.overlappingShapesCurrentState;
                return !s.get(i, n) && !!r.get(i, n)
            }, r.prototype.getNewBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getNewOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, r.prototype.getEndBodyOverlaps = function(t) {
                this.tmpArray1.length = 0;
                var e = this.getEndOverlaps(this.tmpArray1);
                return this.getBodyDiff(e, t)
            }, r.prototype.getBodyDiff = function(t, e) {
                e = e || [];
                for (var i = this.tmpDict, n = t.length; n--;) {
                    var s = t[n];
                    i.set(0 | s.bodyA.id, 0 | s.bodyB.id, s)
                }
                for (n = i.keys.length; n--;) {
                    (s = i.getByKey(i.keys[n])) && e.push(s.bodyA, s.bodyB)
                }
                return i.reset(), e
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./OverlapKeeperRecordPool": 54,
            "./TupleDictionary": 56,
            "./Utils": 57
        }],
        53: [function(t, e, i) {
            function n(t, e, i, n) {
                this.shapeA = e, this.shapeB = n, this.bodyA = t, this.bodyB = i
            }
            e.exports = n, n.prototype.set = function(t, e, i, s) {
                n.call(this, t, e, i, s)
            }
        }, {}],
        54: [function(t, e, i) {
            var n = t("./OverlapKeeperRecord"),
                s = t("./Pool");

            function r() {
                s.apply(this, arguments)
            }
            e.exports = r, r.prototype = new s, r.prototype.constructor = r, r.prototype.create = function() {
                return new n
            }, r.prototype.destroy = function(t) {
                return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null, this
            }
        }, {
            "./OverlapKeeperRecord": 53,
            "./Pool": 55
        }],
        55: [function(t, e, i) {
            function n(t) {
                t = t || {}, this.objects = [], void 0 !== t.size && this.resize(t.size)
            }
            e.exports = n, n.prototype.resize = function(t) {
                for (var e = this.objects; e.length > t;) e.pop();
                for (; e.length < t;) e.push(this.create());
                return this
            }, n.prototype.get = function() {
                var t = this.objects;
                return t.length ? t.pop() : this.create()
            }, n.prototype.release = function(t) {
                return this.destroy(t), this.objects.push(t), this
            }
        }, {}],
        56: [function(t, e, i) {
            var n = t("./Utils");

            function s() {
                this.data = {}, this.keys = []
            }
            e.exports = s, s.prototype.getKey = function(t, e) {
                return (0 | (t |= 0)) == (0 | (e |= 0)) ? -1 : 0 | ((0 | t) > (0 | e) ? t << 16 | 65535 & e : e << 16 | 65535 & t)
            }, s.prototype.getByKey = function(t) {
                return t |= 0, this.data[t]
            }, s.prototype.get = function(t, e) {
                return this.data[this.getKey(t, e)]
            }, s.prototype.set = function(t, e, i) {
                if (!i) throw new Error("No data!");
                var n = this.getKey(t, e);
                return this.data[n] || this.keys.push(n), this.data[n] = i, n
            }, s.prototype.reset = function() {
                for (var t = this.data, e = this.keys, i = e.length; i--;) delete t[e[i]];
                e.length = 0
            }, s.prototype.copy = function(t) {
                this.reset(), n.appendArray(this.keys, t.keys);
                for (var e = t.keys.length; e--;) {
                    var i = t.keys[e];
                    this.data[i] = t.data[i]
                }
            }
        }, {
            "./Utils": 57
        }],
        57: [function(t, e, i) {
            function n() {}
            e.exports = n, n.appendArray = function(t, e) {
                if (e.length < 15e4) t.push.apply(t, e);
                else
                    for (var i = 0, n = e.length; i !== n; ++i) t.push(e[i])
            }, n.splice = function(t, e, i) {
                i = i || 1;
                for (var n = e, s = t.length - i; n < s; n++) t[n] = t[n + i];
                t.length = s
            }, "undefined" != typeof P2_ARRAY_TYPE ? n.ARRAY_TYPE = P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? n.ARRAY_TYPE = Float32Array : n.ARRAY_TYPE = Array, n.extend = function(t, e) {
                for (var i in e) t[i] = e[i]
            }, n.defaults = function(t, e) {
                for (var i in t = t || {}, e) i in t || (t[i] = e[i]);
                return t
            }
        }, {}],
        58: [function(t, e, i) {
            var n = t("../objects/Body");

            function s() {
                this.equations = [], this.bodies = []
            }
            e.exports = s, s.prototype.reset = function() {
                this.equations.length = this.bodies.length = 0
            };
            var r = [];
            s.prototype.getBodies = function(t) {
                var e = t || [],
                    i = this.equations;
                r.length = 0;
                for (var n = 0; n !== i.length; n++) {
                    var s = i[n]; - 1 === r.indexOf(s.bodyA.id) && (e.push(s.bodyA), r.push(s.bodyA.id)), -1 === r.indexOf(s.bodyB.id) && (e.push(s.bodyB), r.push(s.bodyB.id))
                }
                return e
            }, s.prototype.wantsToSleep = function() {
                for (var t = 0; t < this.bodies.length; t++) {
                    var e = this.bodies[t];
                    if (e.type === n.DYNAMIC && !e.wantsToSleep) return !1
                }
                return !0
            }, s.prototype.sleep = function() {
                for (var t = 0; t < this.bodies.length; t++) {
                    this.bodies[t].sleep()
                }
                return !0
            }
        }, {
            "../objects/Body": 31
        }],
        59: [function(t, e, i) {
            t("../math/vec2"), t("./Island"), t("./IslandNode");
            var n = t("./../utils/IslandNodePool"),
                s = t("./../utils/IslandPool"),
                r = t("../objects/Body");

            function o(t) {
                this.nodePool = new n({
                    size: 16
                }), this.islandPool = new s({
                    size: 8
                }), this.equations = [], this.islands = [], this.nodes = [], this.queue = []
            }
            e.exports = o, o.getUnvisitedNode = function(t) {
                for (var e = t.length, i = 0; i !== e; i++) {
                    var n = t[i];
                    if (!n.visited && n.body.type === r.DYNAMIC) return n
                }
                return !1
            }, o.prototype.visit = function(t, e, i) {
                e.push(t.body);
                for (var n = t.equations.length, s = 0; s !== n; s++) {
                    var r = t.equations[s]; - 1 === i.indexOf(r) && i.push(r)
                }
            }, o.prototype.bfs = function(t, e, i) {
                var n = this.queue;
                for (n.length = 0, n.push(t), t.visited = !0, this.visit(t, e, i); n.length;)
                    for (var s, a = n.pop(); s = o.getUnvisitedNode(a.neighbors);) s.visited = !0, this.visit(s, e, i), s.body.type === r.DYNAMIC && n.push(s)
            }, o.prototype.split = function(t) {
                for (var e = t.bodies, i = this.nodes, n = this.equations; i.length;) this.nodePool.release(i.pop());
                for (var s = 0; s !== e.length; s++) {
                    var r = this.nodePool.get();
                    r.body = e[s], i.push(r)
                }
                for (var a = 0; a !== n.length; a++) {
                    var h = n[a],
                        l = (s = e.indexOf(h.bodyA), e.indexOf(h.bodyB)),
                        c = i[s],
                        u = i[l];
                    c.neighbors.push(u), u.neighbors.push(c), c.equations.push(h), u.equations.push(h)
                }
                var d, p = this.islands;
                for (s = 0; s < p.length; s++) this.islandPool.release(p[s]);
                for (p.length = 0; d = o.getUnvisitedNode(i);) {
                    var f = this.islandPool.get();
                    this.bfs(d, f.bodies, f.equations), p.push(f)
                }
                return p
            }
        }, {
            "../math/vec2": 30,
            "../objects/Body": 31,
            "./../utils/IslandNodePool": 50,
            "./../utils/IslandPool": 51,
            "./Island": 58,
            "./IslandNode": 60
        }],
        60: [function(t, e, i) {
            function n(t) {
                this.body = t, this.neighbors = [], this.equations = [], this.visited = !1
            }
            e.exports = n, n.prototype.reset = function() {
                this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null
            }
        }, {}],
        61: [function(t, e, i) {
            var n = t("../solver/GSSolver"),
                s = (t("../solver/Solver"), t("../collision/Ray"), t("../math/vec2")),
                r = t("../shapes/Circle"),
                o = t("../shapes/Convex"),
                a = (t("../shapes/Line"), t("../shapes/Plane")),
                h = t("../shapes/Capsule"),
                l = t("../shapes/Particle"),
                c = t("../events/EventEmitter"),
                u = t("../objects/Body"),
                d = (t("../shapes/Shape"), t("../objects/LinearSpring"), t("../material/Material")),
                p = t("../material/ContactMaterial"),
                f = (t("../constraints/DistanceConstraint"), t("../constraints/Constraint"), t("../constraints/LockConstraint"), t("../constraints/RevoluteConstraint"), t("../constraints/PrismaticConstraint"), t("../constraints/GearConstraint"), t("../../package.json"), t("../collision/Broadphase"), t("../collision/AABB")),
                g = t("../collision/SAPBroadphase"),
                m = t("../collision/Narrowphase"),
                y = t("../utils/Utils"),
                v = t("../utils/OverlapKeeper"),
                b = t("./IslandManager");
            t("../objects/RotationalSpring");

            function x(t) {
                c.apply(this), t = t || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = t.solver || new n, this.narrowphase = new m(this), this.islandManager = new b, this.gravity = s.fromValues(0, -9.78), t.gravity && s.copy(this.gravity, t.gravity), this.frictionGravity = s.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = t.broadphase || new g, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new d, this.defaultContactMaterial = new p(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                    type: "postStep"
                }, this.addBodyEvent = {
                    type: "addBody",
                    body: null
                }, this.removeBodyEvent = {
                    type: "removeBody",
                    body: null
                }, this.addSpringEvent = {
                    type: "addSpring",
                    spring: null
                }, this.impactEvent = {
                    type: "impact",
                    bodyA: null,
                    bodyB: null,
                    shapeA: null,
                    shapeB: null,
                    contactEquation: null
                }, this.postBroadphaseEvent = {
                    type: "postBroadphase",
                    pairs: null
                }, this.sleepMode = x.NO_SLEEPING, this.beginContactEvent = {
                    type: "beginContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null,
                    contactEquations: []
                }, this.endContactEvent = {
                    type: "endContact",
                    shapeA: null,
                    shapeB: null,
                    bodyA: null,
                    bodyB: null
                }, this.preSolveEvent = {
                    type: "preSolve",
                    contactEquations: null,
                    frictionEquations: null
                }, this.overlappingShapesLastState = {
                    keys: []
                }, this.overlappingShapesCurrentState = {
                    keys: []
                }, this.overlapKeeper = new v
            }
            e.exports = x, x.prototype = new Object(c.prototype), x.prototype.constructor = x, x.NO_SLEEPING = 1, x.BODY_SLEEPING = 2, x.ISLAND_SLEEPING = 4, x.prototype.addConstraint = function(t) {
                this.constraints.push(t)
            }, x.prototype.addContactMaterial = function(t) {
                this.contactMaterials.push(t)
            }, x.prototype.removeContactMaterial = function(t) {
                var e = this.contactMaterials.indexOf(t); - 1 !== e && y.splice(this.contactMaterials, e, 1)
            }, x.prototype.getContactMaterial = function(t, e) {
                for (var i = this.contactMaterials, n = 0, s = i.length; n !== s; n++) {
                    var r = i[n];
                    if (r.materialA.id === t.id && r.materialB.id === e.id || r.materialA.id === e.id && r.materialB.id === t.id) return r
                }
                return !1
            }, x.prototype.removeConstraint = function(t) {
                var e = this.constraints.indexOf(t); - 1 !== e && y.splice(this.constraints, e, 1)
            };
            s.create(), s.create(), s.create(), s.create(), s.create(), s.create();
            var w = s.create(),
                _ = s.fromValues(0, 0),
                P = s.fromValues(0, 0);
            s.fromValues(0, 0), s.fromValues(0, 0);
            x.prototype.step = function(t, e, i) {
                if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t;
                else {
                    this.accumulator += e;
                    for (var n = 0; this.accumulator >= t && n < i;) this.internalStep(t), this.time += t, this.accumulator -= t, n++;
                    for (var r = this.accumulator % t / t, o = 0; o !== this.bodies.length; o++) {
                        var a = this.bodies[o];
                        s.lerp(a.interpolatedPosition, a.previousPosition, a.position, r), a.interpolatedAngle = a.previousAngle + r * (a.angle - a.previousAngle)
                    }
                }
            };
            var T = [];
            x.prototype.internalStep = function(t) {
                this.stepping = !0;
                var e = this.springs.length,
                    i = this.springs,
                    n = this.bodies,
                    r = this.gravity,
                    o = this.solver,
                    a = this.bodies.length,
                    h = this.broadphase,
                    l = this.narrowphase,
                    c = this.constraints,
                    d = w,
                    p = (s.scale, s.add),
                    f = (s.rotate, this.islandManager);
                if (this.overlapKeeper.tick(), this.lastTimeStep = t, this.useWorldGravityAsFrictionGravity) {
                    var g = s.length(this.gravity);
                    0 === g && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = g)
                }
                if (this.applyGravity)
                    for (var m = 0; m !== a; m++) {
                        var v = (b = n[m]).force;
                        b.type === u.DYNAMIC && b.sleepState !== u.SLEEPING && (s.scale(d, r, b.mass * b.gravityScale), p(v, v, d))
                    }
                if (this.applySpringForces)
                    for (m = 0; m !== e; m++) {
                        i[m].applyForce()
                    }
                if (this.applyDamping)
                    for (m = 0; m !== a; m++) {
                        var b;
                        (b = n[m]).type === u.DYNAMIC && b.applyDamping(t)
                    }
                var _ = h.getCollisionPairs(this),
                    P = this.disabledBodyCollisionPairs;
                for (m = P.length - 2; m >= 0; m -= 2)
                    for (var S = _.length - 2; S >= 0; S -= 2)(P[m] === _[S] && P[m + 1] === _[S + 1] || P[m + 1] === _[S] && P[m] === _[S + 1]) && _.splice(S, 2);
                var C = c.length;
                for (m = 0; m !== C; m++) {
                    var A = c[m];
                    if (!A.collideConnected)
                        for (S = _.length - 2; S >= 0; S -= 2)(A.bodyA === _[S] && A.bodyB === _[S + 1] || A.bodyB === _[S] && A.bodyA === _[S + 1]) && _.splice(S, 2)
                }
                this.postBroadphaseEvent.pairs = _, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, l.reset(this);
                m = 0;
                for (var E = _.length; m !== E; m += 2)
                    for (var M = _[m], I = _[m + 1], O = 0, k = M.shapes.length; O !== k; O++)
                        for (var R = M.shapes[O], L = R.position, B = R.angle, F = 0, D = I.shapes.length; F !== D; F++) {
                            var U = I.shapes[F],
                                G = U.position,
                                N = U.angle,
                                X = this.defaultContactMaterial;
                            if (R.material && U.material) {
                                var j = this.getContactMaterial(R.material, U.material);
                                j && (X = j)
                            }
                            this.runNarrowphase(l, M, R, L, B, I, U, G, N, X, this.frictionGravity)
                        }
                for (m = 0; m !== a; m++) {
                    (H = n[m])._wakeUpAfterNarrowphase && (H.wakeUp(), H._wakeUpAfterNarrowphase = !1)
                }
                if (this.has("endContact")) {
                    this.overlapKeeper.getEndOverlaps(T);
                    var W = this.endContactEvent;
                    for (F = T.length; F--;) {
                        var V = T[F];
                        W.shapeA = V.shapeA, W.shapeB = V.shapeB, W.bodyA = V.bodyA, W.bodyB = V.bodyB, this.emit(W)
                    }
                    T.length = 0
                }
                var Y = this.preSolveEvent;
                Y.contactEquations = l.contactEquations, Y.frictionEquations = l.frictionEquations, this.emit(Y), Y.contactEquations = Y.frictionEquations = null;
                C = c.length;
                for (m = 0; m !== C; m++) c[m].update();
                if (l.contactEquations.length || l.frictionEquations.length || C)
                    if (this.islandSplit) {
                        for (f.equations.length = 0, y.appendArray(f.equations, l.contactEquations), y.appendArray(f.equations, l.frictionEquations), m = 0; m !== C; m++) y.appendArray(f.equations, c[m].equations);
                        f.split(this);
                        for (m = 0; m !== f.islands.length; m++) {
                            (K = f.islands[m]).equations.length && o.solveIsland(t, K)
                        }
                    } else {
                        for (o.addEquations(l.contactEquations), o.addEquations(l.frictionEquations), m = 0; m !== C; m++) o.addEquations(c[m].equations);
                        this.solveConstraints && o.solve(t, this), o.removeAllEquations()
                    }
                for (m = 0; m !== a; m++) {
                    var H;
                    (H = n[m]).integrate(t)
                }
                for (m = 0; m !== a; m++) n[m].setZeroForce();
                if (this.emitImpactEvent && this.has("impact")) {
                    var q = this.impactEvent;
                    for (m = 0; m !== l.contactEquations.length; m++) {
                        var z = l.contactEquations[m];
                        z.firstImpact && (q.bodyA = z.bodyA, q.bodyB = z.bodyB, q.shapeA = z.shapeA, q.shapeB = z.shapeB, q.contactEquation = z, this.emit(q))
                    }
                }
                if (this.sleepMode === x.BODY_SLEEPING)
                    for (m = 0; m !== a; m++) n[m].sleepTick(this.time, !1, t);
                else if (this.sleepMode === x.ISLAND_SLEEPING && this.islandSplit) {
                    for (m = 0; m !== a; m++) n[m].sleepTick(this.time, !0, t);
                    for (m = 0; m < this.islandManager.islands.length; m++) {
                        var K;
                        (K = this.islandManager.islands[m]).wantsToSleep() && K.sleep()
                    }
                }
                this.stepping = !1;
                var J = this.bodiesToBeRemoved;
                for (m = 0; m !== J.length; m++) this.removeBody(J[m]);
                J.length = 0, this.emit(this.postStepEvent)
            }, x.prototype.runNarrowphase = function(t, e, i, n, r, o, a, h, l, c, d) {
                if (0 != (i.collisionGroup & a.collisionMask) && 0 != (a.collisionGroup & i.collisionMask)) {
                    s.rotate(_, n, e.angle), s.rotate(P, h, o.angle), s.add(_, _, e.position), s.add(P, P, o.position);
                    var p, f = r + e.angle,
                        g = l + o.angle;
                    t.enableFriction = c.friction > 0, t.frictionCoefficient = c.friction, p = e.type === u.STATIC || e.type === u.KINEMATIC ? o.mass : o.type === u.STATIC || o.type === u.KINEMATIC ? e.mass : e.mass * o.mass / (e.mass + o.mass), t.slipForce = c.friction * d * p, t.restitution = c.restitution, t.surfaceVelocity = c.surfaceVelocity, t.frictionStiffness = c.frictionStiffness, t.frictionRelaxation = c.frictionRelaxation, t.stiffness = c.stiffness, t.relaxation = c.relaxation, t.contactSkinSize = c.contactSkinSize, t.enabledEquations = e.collisionResponse && o.collisionResponse && i.collisionResponse && a.collisionResponse;
                    var m = t[i.type | a.type],
                        y = 0;
                    if (m) {
                        var v = i.sensor || a.sensor,
                            b = t.frictionEquations.length;
                        y = i.type < a.type ? m.call(t, e, i, _, f, o, a, P, g, v) : m.call(t, o, a, P, g, e, i, _, f, v);
                        var x = t.frictionEquations.length - b;
                        if (y) {
                            if (e.allowSleep && e.type === u.DYNAMIC && e.sleepState === u.SLEEPING && o.sleepState === u.AWAKE && o.type !== u.STATIC) s.squaredLength(o.velocity) + Math.pow(o.angularVelocity, 2) >= 2 * Math.pow(o.sleepSpeedLimit, 2) && (e._wakeUpAfterNarrowphase = !0);
                            if (o.allowSleep && o.type === u.DYNAMIC && o.sleepState === u.SLEEPING && e.sleepState === u.AWAKE && e.type !== u.STATIC) s.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2) >= 2 * Math.pow(e.sleepSpeedLimit, 2) && (o._wakeUpAfterNarrowphase = !0);
                            if (this.overlapKeeper.setOverlapping(e, i, o, a), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, a)) {
                                var w = this.beginContactEvent;
                                if (w.shapeA = i, w.shapeB = a, w.bodyA = e, w.bodyB = o, w.contactEquations.length = 0, "number" == typeof y)
                                    for (var T = t.contactEquations.length - y; T < t.contactEquations.length; T++) w.contactEquations.push(t.contactEquations[T]);
                                this.emit(w)
                            }
                            if ("number" == typeof y && x > 1)
                                for (T = t.frictionEquations.length - x; T < t.frictionEquations.length; T++) {
                                    var S = t.frictionEquations[T];
                                    S.setSlipForce(S.getSlipForce() / x)
                                }
                        }
                    }
                }
            }, x.prototype.addSpring = function(t) {
                this.springs.push(t);
                var e = this.addSpringEvent;
                e.spring = t, this.emit(e), e.spring = null
            }, x.prototype.removeSpring = function(t) {
                var e = this.springs.indexOf(t); - 1 !== e && y.splice(this.springs, e, 1)
            }, x.prototype.addBody = function(t) {
                if (-1 === this.bodies.indexOf(t)) {
                    this.bodies.push(t), t.world = this;
                    var e = this.addBodyEvent;
                    e.body = t, this.emit(e), e.body = null
                }
            }, x.prototype.removeBody = function(t) {
                if (this.stepping) this.bodiesToBeRemoved.push(t);
                else {
                    t.world = null;
                    var e = this.bodies.indexOf(t); - 1 !== e && (y.splice(this.bodies, e, 1), this.removeBodyEvent.body = t, t.resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null)
                }
            }, x.prototype.getBodyById = function(t) {
                for (var e = this.bodies, i = 0; i < e.length; i++) {
                    var n = e[i];
                    if (n.id === t) return n
                }
                return !1
            }, x.prototype.disableBodyCollision = function(t, e) {
                this.disabledBodyCollisionPairs.push(t, e)
            }, x.prototype.enableBodyCollision = function(t, e) {
                for (var i = this.disabledBodyCollisionPairs, n = 0; n < i.length; n += 2)
                    if (i[n] === t && i[n + 1] === e || i[n + 1] === t && i[n] === e) return void i.splice(n, 2)
            }, x.prototype.clear = function() {
                this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                for (var t = this.constraints, e = t.length - 1; e >= 0; e--) this.removeConstraint(t[e]);
                var i = this.bodies;
                for (e = i.length - 1; e >= 0; e--) this.removeBody(i[e]);
                var n = this.springs;
                for (e = n.length - 1; e >= 0; e--) this.removeSpring(n[e]);
                var s = this.contactMaterials;
                for (e = s.length - 1; e >= 0; e--) this.removeContactMaterial(s[e]);
                x.apply(this)
            };
            var S = s.create(),
                C = (s.fromValues(0, 0), s.fromValues(0, 0));
            x.prototype.hitTest = function(t, e, i) {
                i = i || 0;
                var n = new u({
                        position: t
                    }),
                    c = new l,
                    d = t,
                    p = S,
                    f = C;
                n.addShape(c);
                for (var g = this.narrowphase, m = [], y = 0, v = e.length; y !== v; y++)
                    for (var b = e[y], x = 0, w = b.shapes.length; x !== w; x++) {
                        var _ = b.shapes[x];
                        s.rotate(p, _.position, b.angle), s.add(p, p, b.position);
                        var P = _.angle + b.angle;
                        (_ instanceof r && g.circleParticle(b, _, p, P, n, c, d, 0, !0) || _ instanceof o && g.particleConvex(n, c, d, 0, b, _, p, P, !0) || _ instanceof a && g.particlePlane(n, c, d, 0, b, _, p, P, !0) || _ instanceof h && g.particleCapsule(n, c, d, 0, b, _, p, P, !0) || _ instanceof l && s.squaredLength(s.sub(f, p, t)) < i * i) && m.push(b)
                    }
                return m
            }, x.prototype.setGlobalStiffness = function(t) {
                for (var e = this.constraints, i = 0; i !== e.length; i++)
                    for (var n = e[i], s = 0; s !== n.equations.length; s++) {
                        var r = n.equations[s];
                        r.stiffness = t, r.needsUpdate = !0
                    }
                var o = this.contactMaterials;
                for (i = 0; i !== o.length; i++) {
                    (n = o[i]).stiffness = n.frictionStiffness = t
                }(n = this.defaultContactMaterial).stiffness = n.frictionStiffness = t
            }, x.prototype.setGlobalRelaxation = function(t) {
                for (var e = 0; e !== this.constraints.length; e++)
                    for (var i = this.constraints[e], n = 0; n !== i.equations.length; n++) {
                        var s = i.equations[n];
                        s.relaxation = t, s.needsUpdate = !0
                    }
                for (e = 0; e !== this.contactMaterials.length; e++) {
                    (i = this.contactMaterials[e]).relaxation = i.frictionRelaxation = t
                }(i = this.defaultContactMaterial).relaxation = i.frictionRelaxation = t
            };
            var A = new f,
                E = [];
            x.prototype.raycast = function(t, e) {
                return e.getAABB(A), this.broadphase.aabbQuery(this, A, E), e.intersectBodies(t, E), E.length = 0, t.hasHit()
            }
        }, {
            "../../package.json": 6,
            "../collision/AABB": 7,
            "../collision/Broadphase": 8,
            "../collision/Narrowphase": 10,
            "../collision/Ray": 11,
            "../collision/SAPBroadphase": 13,
            "../constraints/Constraint": 14,
            "../constraints/DistanceConstraint": 15,
            "../constraints/GearConstraint": 16,
            "../constraints/LockConstraint": 17,
            "../constraints/PrismaticConstraint": 18,
            "../constraints/RevoluteConstraint": 19,
            "../events/EventEmitter": 26,
            "../material/ContactMaterial": 27,
            "../material/Material": 28,
            "../math/vec2": 30,
            "../objects/Body": 31,
            "../objects/LinearSpring": 32,
            "../objects/RotationalSpring": 33,
            "../shapes/Capsule": 38,
            "../shapes/Circle": 39,
            "../shapes/Convex": 40,
            "../shapes/Line": 42,
            "../shapes/Particle": 43,
            "../shapes/Plane": 44,
            "../shapes/Shape": 45,
            "../solver/GSSolver": 46,
            "../solver/Solver": 47,
            "../utils/OverlapKeeper": 52,
            "../utils/Utils": 57,
            "./IslandManager": 59
        }]
    }, {}, [36])(36)
}),
function() {
    var t = this,
        e = e || {};
    return e.game = null, e.WEBGL_RENDERER = 0, e.CANVAS_RENDERER = 1, e.VERSION = "v2.2.9", e._UID = 0, "undefined" != typeof Float32Array ? (e.Float32Array = Float32Array, e.Uint16Array = Uint16Array, e.Uint32Array = Uint32Array, e.ArrayBuffer = ArrayBuffer) : (e.Float32Array = Array, e.Uint16Array = Array), e.PI_2 = 2 * Math.PI, e.RAD_TO_DEG = 180 / Math.PI, e.DEG_TO_RAD = Math.PI / 180, e.RETINA_PREFIX = "@2x", e.DisplayObject = function() {
        this.position = new e.Point(0, 0), this.scale = new e.Point(1, 1), this.pivot = new e.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new e.Matrix, this.worldPosition = new e.Point(0, 0), this.worldScale = new e.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new e.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
    }, e.DisplayObject.prototype.constructor = e.DisplayObject, e.DisplayObject.prototype = {
        destroy: function() {
            if (this.children) {
                for (var t = this.children.length; t--;) this.children[t].destroy();
                this.children = []
            }
            this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
        },
        updateTransform: function(t) {
            if (!t && !this.parent && !this.game) return this;
            var i = this.parent;
            t ? i = t : this.parent || (i = this.game.world);
            var n, s, r, o, a, h, l = i.worldTransform,
                c = this.worldTransform;
            return this.rotation % e.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), n = this._cr * this.scale.x, s = this._sr * this.scale.x, r = -this._sr * this.scale.y, o = this._cr * this.scale.y, a = this.position.x, h = this.position.y, (this.pivot.x || this.pivot.y) && (a -= this.pivot.x * n + this.pivot.y * r, h -= this.pivot.x * s + this.pivot.y * o), c.a = n * l.a + s * l.c, c.b = n * l.b + s * l.d, c.c = r * l.a + o * l.c, c.d = r * l.b + o * l.d, c.tx = a * l.a + h * l.c + l.tx, c.ty = a * l.b + h * l.d + l.ty) : (n = this.scale.x, o = this.scale.y, a = this.position.x - this.pivot.x * n, h = this.position.y - this.pivot.y * o, c.a = n * l.a, c.b = n * l.b, c.c = o * l.c, c.d = o * l.d, c.tx = a * l.a + h * l.c + l.tx, c.ty = a * l.b + h * l.d + l.ty), this.worldAlpha = this.alpha * i.worldAlpha, this.worldPosition.set(c.tx, c.ty), this.worldScale.set(this.scale.x * Math.sqrt(c.a * c.a + c.c * c.c), this.scale.y * Math.sqrt(c.b * c.b + c.d * c.d)), this.worldRotation = Math.atan2(-c.c, c.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, c, l), this
        },
        preUpdate: function() {},
        generateTexture: function(t, i, n) {
            var s = this.getLocalBounds(),
                r = new e.RenderTexture(0 | s.width, 0 | s.height, n, i, t);
            return e.DisplayObject._tempMatrix.tx = -s.x, e.DisplayObject._tempMatrix.ty = -s.y, r.render(this, e.DisplayObject._tempMatrix), r
        },
        updateCache: function() {
            return this._generateCachedSprite(), this
        },
        toGlobal: function(t) {
            return this.updateTransform(), this.worldTransform.apply(t)
        },
        toLocal: function(t, e) {
            return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
        },
        _renderCachedSprite: function(t) {
            this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? e.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : e.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
        },
        _generateCachedSprite: function() {
            this._cacheAsBitmap = !1;
            var t = this.getLocalBounds();
            if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
            else {
                var i = new e.RenderTexture(t.width, t.height);
                this._cachedSprite = new e.Sprite(i), this._cachedSprite.worldTransform = this.worldTransform
            }
            var n = this._filters;
            this._filters = null, this._cachedSprite.filters = n, e.DisplayObject._tempMatrix.tx = -t.x, e.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, e.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = n, this._cacheAsBitmap = !0
        },
        _destroyCachedSprite: function() {
            this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
        }
    }, e.DisplayObject.prototype.displayObjectUpdateTransform = e.DisplayObject.prototype.updateTransform, Object.defineProperties(e.DisplayObject.prototype, {
        x: {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        },
        y: {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        },
        worldVisible: {
            get: function() {
                if (this.visible) {
                    var t = this.parent;
                    if (!t) return this.visible;
                    do {
                        if (!t.visible) return !1;
                        t = t.parent
                    } while (t);
                    return !0
                }
                return !1
            }
        },
        mask: {
            get: function() {
                return this._mask
            },
            set: function(t) {
                this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
            }
        },
        filters: {
            get: function() {
                return this._filters
            },
            set: function(t) {
                if (Array.isArray(t)) {
                    for (var i = [], n = 0; n < t.length; n++)
                        for (var s = t[n].passes, r = 0; r < s.length; r++) i.push(s[r]);
                    this._filterBlock = {
                        target: this,
                        filterPasses: i
                    }
                }
                this._filters = t, this.blendMode && this.blendMode === e.blendModes.MULTIPLY && (this.blendMode = e.blendModes.NORMAL)
            }
        },
        cacheAsBitmap: {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
            }
        }
    }), e.DisplayObjectContainer = function() {
        e.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
    }, e.DisplayObjectContainer.prototype = Object.create(e.DisplayObject.prototype), e.DisplayObjectContainer.prototype.constructor = e.DisplayObjectContainer, e.DisplayObjectContainer.prototype.addChild = function(t) {
        return this.addChildAt(t, this.children.length)
    }, e.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
        if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
        throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
    }, e.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
        if (t !== e) {
            var i = this.getChildIndex(t),
                n = this.getChildIndex(e);
            if (i < 0 || n < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[i] = e, this.children[n] = t
        }
    }, e.DisplayObjectContainer.prototype.getChildIndex = function(t) {
        var e = this.children.indexOf(t);
        if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
        return e
    }, e.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
        if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
        var i = this.getChildIndex(t);
        this.children.splice(i, 1), this.children.splice(e, 0, t)
    }, e.DisplayObjectContainer.prototype.getChildAt = function(t) {
        if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
        return this.children[t]
    }, e.DisplayObjectContainer.prototype.removeChild = function(t) {
        var e = this.children.indexOf(t);
        if (-1 !== e) return this.removeChildAt(e)
    }, e.DisplayObjectContainer.prototype.removeChildAt = function(t) {
        var e = this.getChildAt(t);
        return e && (e.parent = void 0, this.children.splice(t, 1)), e
    }, e.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
        void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
        var i = e - t;
        if (i > 0 && i <= e) {
            for (var n = this.children.splice(begin, i), s = 0; s < n.length; s++) {
                n[s].parent = void 0
            }
            return n
        }
        if (0 === i && 0 === this.children.length) return [];
        throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
    }, e.DisplayObjectContainer.prototype.updateTransform = function() {
        if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
            for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
    }, e.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = e.DisplayObjectContainer.prototype.updateTransform, e.DisplayObjectContainer.prototype.getBounds = function(t) {
        var i, n = t && t instanceof e.DisplayObject,
            s = !0;
        if (n ? s = t instanceof e.DisplayObjectContainer && t.contains(this) : t = this, n) {
            var r = t.worldTransform;
            for (t.worldTransform = e.identityMatrix, i = 0; i < t.children.length; i++) t.children[i].updateTransform()
        }
        var o, a, h, l = 1 / 0,
            c = 1 / 0,
            u = -1 / 0,
            d = -1 / 0,
            p = !1;
        for (i = 0; i < this.children.length; i++) {
            this.children[i].visible && (p = !0, l = l < (o = this.children[i].getBounds()).x ? l : o.x, c = c < o.y ? c : o.y, a = o.width + o.x, h = o.height + o.y, u = u > a ? u : a, d = d > h ? d : h)
        }
        var f = this._bounds;
        if (!p) {
            var g = (f = new e.Rectangle).x,
                m = f.width + f.x,
                y = f.y,
                v = f.height + f.y,
                b = this.worldTransform,
                x = b.a,
                w = b.b,
                _ = b.c,
                P = b.d,
                T = b.tx,
                S = b.ty,
                C = x * m + _ * v + T,
                A = P * v + w * m + S,
                E = x * g + _ * v + T,
                M = P * v + w * g + S,
                I = x * g + _ * y + T,
                O = P * y + w * g + S,
                k = x * m + _ * y + T,
                R = P * y + w * m + S;
            u = C, d = A, c = A, l = k < (l = I < (l = E < (l = C) ? E : l) ? I : l) ? k : l, c = R < (c = O < (c = M < c ? M : c) ? O : c) ? R : c, u = k > (u = I > (u = E > u ? E : u) ? I : u) ? k : u, d = R > (d = O > (d = M > d ? M : d) ? O : d) ? R : d
        }
        if (f.x = l, f.y = c, f.width = u - l, f.height = d - c, n)
            for (t.worldTransform = r, i = 0; i < t.children.length; i++) t.children[i].updateTransform();
        if (!s) {
            var L = t.getBounds();
            f.x -= L.x, f.y -= L.y
        }
        return f
    }, e.DisplayObjectContainer.prototype.getLocalBounds = function() {
        return this.getBounds(this)
    }, e.DisplayObjectContainer.prototype.contains = function(t) {
        return !!t && (t === this || this.contains(t.parent))
    }, e.DisplayObjectContainer.prototype._renderWebGL = function(t) {
        var e;
        if (this.visible && !(this.alpha <= 0))
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else if (this._mask || this._filters) {
            for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
        } else
            for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
    }, e.DisplayObjectContainer.prototype._renderCanvas = function(t) {
        if (!1 !== this.visible && 0 !== this.alpha)
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else {
                this._mask && t.maskManager.pushMask(this._mask, t);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
    }, Object.defineProperty(e.DisplayObjectContainer.prototype, "width", {
        get: function() {
            return this.getLocalBounds().width * this.scale.x
        },
        set: function(t) {
            var e = this.getLocalBounds().width;
            this.scale.x = 0 !== e ? t / e : 1, this._width = t
        }
    }), Object.defineProperty(e.DisplayObjectContainer.prototype, "height", {
        get: function() {
            return this.getLocalBounds().height * this.scale.y
        },
        set: function(t) {
            var e = this.getLocalBounds().height;
            this.scale.y = 0 !== e ? t / e : 1, this._height = t
        }
    }), e.Sprite = function(t) {
        e.DisplayObjectContainer.call(this), this.anchor = new e.Point, this.texture = t || e.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = e.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
    }, e.Sprite.prototype = Object.create(e.DisplayObjectContainer.prototype), e.Sprite.prototype.constructor = e.Sprite, Object.defineProperty(e.Sprite.prototype, "width", {
        get: function() {
            return this.scale.x * this.texture.frame.width
        },
        set: function(t) {
            this.scale.x = t / this.texture.frame.width, this._width = t
        }
    }), Object.defineProperty(e.Sprite.prototype, "height", {
        get: function() {
            return this.scale.y * this.texture.frame.height
        },
        set: function(t) {
            this.scale.y = t / this.texture.frame.height, this._height = t
        }
    }), e.Sprite.prototype.setTexture = function(t, e) {
        void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
    }, e.Sprite.prototype.onTextureUpdate = function() {
        this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
    }, e.Sprite.prototype.getBounds = function(t) {
        var e = this.texture.frame.width,
            i = this.texture.frame.height,
            n = e * (1 - this.anchor.x),
            s = e * -this.anchor.x,
            r = i * (1 - this.anchor.y),
            o = i * -this.anchor.y,
            a = t || this.worldTransform,
            h = a.a,
            l = a.b,
            c = a.c,
            u = a.d,
            d = a.tx,
            p = a.ty,
            f = -1 / 0,
            g = -1 / 0,
            m = 1 / 0,
            y = 1 / 0;
        if (0 === l && 0 === c) {
            if (h < 0) {
                h *= -1;
                var v = n;
                n = -s, s = -v
            }
            if (u < 0) {
                u *= -1;
                v = r;
                r = -o, o = -v
            }
            m = h * s + d, f = h * n + d, y = u * o + p, g = u * r + p
        } else {
            var b = h * s + c * o + d,
                x = u * o + l * s + p,
                w = h * n + c * o + d,
                _ = u * o + l * n + p,
                P = h * n + c * r + d,
                T = u * r + l * n + p,
                S = h * s + c * r + d,
                C = u * r + l * s + p;
            m = S < (m = P < (m = w < (m = b < m ? b : m) ? w : m) ? P : m) ? S : m, y = C < (y = T < (y = _ < (y = x < y ? x : y) ? _ : y) ? T : y) ? C : y, f = S > (f = P > (f = w > (f = b > f ? b : f) ? w : f) ? P : f) ? S : f, g = C > (g = T > (g = _ > (g = x > g ? x : g) ? _ : g) ? T : g) ? C : g
        }
        var A = this._bounds;
        return A.x = m, A.width = f - m, A.y = y, A.height = g - y, this._currentBounds = A, A
    }, e.Sprite.prototype.getLocalBounds = function() {
        var t = this.worldTransform;
        this.worldTransform = e.identityMatrix;
        for (var i = 0; i < this.children.length; i++) this.children[i].updateTransform();
        var n = this.getBounds();
        for (this.worldTransform = t, i = 0; i < this.children.length; i++) this.children[i].updateTransform();
        return n
    }, e.Sprite.prototype._renderWebGL = function(t, e) {
        if (this.visible && !(this.alpha <= 0) && this.renderable) {
            var i = this.worldTransform;
            if (e && (i = e), this._mask || this._filters) {
                var n = t.spriteBatch;
                this._filters && (n.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (n.stop(), t.maskManager.pushMask(this.mask, t), n.start()), n.render(this);
                for (var s = 0; s < this.children.length; s++) this.children[s]._renderWebGL(t);
                n.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), n.start()
            } else {
                t.spriteBatch.render(this);
                for (s = 0; s < this.children.length; s++) this.children[s]._renderWebGL(t, i)
            }
        }
    }, e.Sprite.prototype._renderCanvas = function(t, i) {
        if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
            var n = this.worldTransform;
            if (i && (n = i), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                var s = this.texture.baseTexture.resolution / t.resolution;
                t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === e.scaleModes.LINEAR);
                var r = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                    o = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                    a = n.tx * t.resolution + t.shakeX,
                    h = n.ty * t.resolution + t.shakeY;
                t.roundPixels ? (t.context.setTransform(n.a, n.b, n.c, n.d, 0 | a, 0 | h), r |= 0, o |= 0) : t.context.setTransform(n.a, n.b, n.c, n.d, a, h);
                var l = this.texture.crop.width,
                    c = this.texture.crop.height;
                if (r /= s, o /= s, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = e.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, c, r, o, l / s, c / s);
                else {
                    var u = this.texture.crop.x,
                        d = this.texture.crop.y;
                    t.context.drawImage(this.texture.baseTexture.source, u, d, l, c, r, o, l / s, c / s)
                }
            }
            for (var p = 0; p < this.children.length; p++) this.children[p]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t)
        }
    }, e.SpriteBatch = function(t) {
        e.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1
    }, e.SpriteBatch.prototype = Object.create(e.DisplayObjectContainer.prototype), e.SpriteBatch.prototype.constructor = e.SpriteBatch, e.SpriteBatch.prototype.initWebGL = function(t) {
        this.fastSpriteBatch = new e.WebGLFastSpriteBatch(t), this.ready = !0
    }, e.SpriteBatch.prototype.updateTransform = function() {
        this.displayObjectUpdateTransform()
    }, e.SpriteBatch.prototype._renderWebGL = function(t) {
        !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
    }, e.SpriteBatch.prototype._renderCanvas = function(t) {
        if (this.visible && !(this.alpha <= 0) && this.children.length) {
            var e = t.context;
            e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
            for (var i = this.worldTransform, n = !0, s = 0; s < this.children.length; s++) {
                var r = this.children[s];
                if (r.visible) {
                    var o = r.texture,
                        a = o.frame;
                    if (e.globalAlpha = this.worldAlpha * r.alpha, r.rotation % (2 * Math.PI) == 0) n && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), n = !1), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * (-a.width * r.scale.x) + r.position.x + .5 + t.shakeX | 0, r.anchor.y * (-a.height * r.scale.y) + r.position.y + .5 + t.shakeY | 0, a.width * r.scale.x, a.height * r.scale.y);
                    else {
                        n || (n = !0), r.displayObjectUpdateTransform();
                        var h = r.worldTransform,
                            l = h.tx * t.resolution + t.shakeX,
                            c = h.ty * t.resolution + t.shakeY;
                        t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * -a.width + .5 | 0, r.anchor.y * -a.height + .5 | 0, a.width, a.height)
                    }
                }
            }
        }
    }, e.hex2rgb = function(t) {
        return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
    }, e.rgb2hex = function(t) {
        return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
    }, e.canUseNewCanvasBlendModes = function() {
        if (void 0 === document) return !1;
        var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
            i = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
            n = new Image;
        n.src = t + "AP804Oa6" + i;
        var s = new Image;
        s.src = t + "/wCKxvRF" + i;
        var r = e.CanvasPool.create(this, 6, 1).getContext("2d");
        if (r.globalCompositeOperation = "multiply", r.drawImage(n, 0, 0), r.drawImage(s, 2, 0), !r.getImageData(2, 0, 1, 1)) return !1;
        var o = r.getImageData(2, 0, 1, 1).data;
        return e.CanvasPool.remove(this), 255 === o[0] && 0 === o[1] && 0 === o[2]
    }, e.getNextPowerOfTwo = function(t) {
        if (t > 0 && 0 == (t & t - 1)) return t;
        for (var e = 1; e < t;) e <<= 1;
        return e
    }, e.isPowerOfTwo = function(t, e) {
        return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1)
    }, e.CanvasPool = {
        create: function(t, i, n) {
            var s, r = e.CanvasPool.getFirst();
            if (-1 === r) {
                var o = {
                    parent: t,
                    canvas: document.createElement("canvas")
                };
                e.CanvasPool.pool.push(o), s = o.canvas
            } else e.CanvasPool.pool[r].parent = t, s = e.CanvasPool.pool[r].canvas;
            return void 0 !== i && (s.width = i, s.height = n), s
        },
        getFirst: function() {
            for (var t = e.CanvasPool.pool, i = 0; i < t.length; i++)
                if (!t[i].parent) return i;
            return -1
        },
        remove: function(t) {
            for (var i = e.CanvasPool.pool, n = 0; n < i.length; n++) i[n].parent === t && (i[n].parent = null, i[n].canvas.width = 1, i[n].canvas.height = 1)
        },
        removeByCanvas: function(t) {
            for (var i = e.CanvasPool.pool, n = 0; n < i.length; n++) i[n].canvas === t && (i[n].parent = null, i[n].canvas.width = 1, i[n].canvas.height = 1)
        },
        getTotal: function() {
            for (var t = e.CanvasPool.pool, i = 0, n = 0; n < t.length; n++) t[n].parent && i++;
            return i
        },
        getFree: function() {
            for (var t = e.CanvasPool.pool, i = 0, n = 0; n < t.length; n++) t[n].parent || i++;
            return i
        }
    }, e.CanvasPool.pool = [], e.initDefaultShaders = function() {}, e.CompileVertexShader = function(t, i) {
        return e._CompileShader(t, i, t.VERTEX_SHADER)
    }, e.CompileFragmentShader = function(t, i) {
        return e._CompileShader(t, i, t.FRAGMENT_SHADER)
    }, e._CompileShader = function(t, e, i) {
        var n = e;
        Array.isArray(e) && (n = e.join("\n"));
        var s = t.createShader(i);
        return t.shaderSource(s, n), t.compileShader(s), t.getShaderParameter(s, t.COMPILE_STATUS) ? s : (window.console.log(t.getShaderInfoLog(s)), null)
    }, e.compileProgram = function(t, i, n) {
        var s = e.CompileFragmentShader(t, n),
            r = e.CompileVertexShader(t, i),
            o = t.createProgram();
        return t.attachShader(o, r), t.attachShader(o, s), t.linkProgram(o), t.getProgramParameter(o, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(o)), window.console.log("Could not initialise shaders")), o
    }, e.PixiShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
    }, e.PixiShader.prototype.constructor = e.PixiShader, e.PixiShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc || e.PixiShader.defaultVertexSrc, this.fragmentSrc);
        for (var n in t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.dimensions = t.getUniformLocation(i, "dimensions"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(i, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute], this.uniforms) this.uniforms[n].uniformLocation = t.getUniformLocation(i, n);
        this.initUniforms(), this.program = i
    }, e.PixiShader.prototype.initUniforms = function() {
        this.textureCount = 1;
        var t, e = this.gl;
        for (var i in this.uniforms) {
            var n = (t = this.uniforms[i]).type;
            "sampler2D" === n ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === n || "mat3" === n || "mat4" === n ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === n ? t.glFunc = e.uniformMatrix2fv : "mat3" === n ? t.glFunc = e.uniformMatrix3fv : "mat4" === n && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + n], t.glValueLength = "2f" === n || "2i" === n ? 2 : "3f" === n || "3i" === n ? 3 : "4f" === n || "4i" === n ? 4 : 1)
        }
    }, e.PixiShader.prototype.initSampler2D = function(t) {
        if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
            var e = this.gl;
            if (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                var i = t.textureData,
                    n = i.magFilter ? i.magFilter : e.LINEAR,
                    s = i.minFilter ? i.minFilter : e.LINEAR,
                    r = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                    o = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                    a = i.luminance ? e.LUMINANCE : e.RGBA;
                if (i.repeat && (r = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                    var h = i.width ? i.width : 512,
                        l = i.height ? i.height : 2,
                        c = i.border ? i.border : 0;
                    e.texImage2D(e.TEXTURE_2D, 0, a, h, l, c, a, e.UNSIGNED_BYTE, null)
                } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
            }
            e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
        }
    }, e.PixiShader.prototype.syncUniforms = function() {
        var t;
        this.textureCount = 1;
        var i = this.gl;
        for (var n in this.uniforms) 1 === (t = this.uniforms[n]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(i, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(i, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (i.activeTexture(i["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[i.id] ? e.instances[i.id].updateTexture(t.value.baseTexture) : i.bindTexture(i.TEXTURE_2D, t.value.baseTexture._glTextures[i.id]), i.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
    }, e.PixiShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, e.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], e.PixiFastShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
    }, e.PixiFastShader.prototype.constructor = e.PixiFastShader, e.PixiFastShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.dimensions = t.getUniformLocation(i, "dimensions"), this.uMatrix = t.getUniformLocation(i, "uMatrix"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(i, "aPositionCoord"), this.aScale = t.getAttribLocation(i, "aScale"), this.aRotation = t.getAttribLocation(i, "aRotation"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(i, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = i
    }, e.PixiFastShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, e.StripShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init()
    }, e.StripShader.prototype.constructor = e.StripShader, e.StripShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.colorAttribute = t.getAttribLocation(i, "aColor"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i
    }, e.StripShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, e.PrimitiveShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
    }, e.PrimitiveShader.prototype.constructor = e.PrimitiveShader, e.PrimitiveShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.tintColor = t.getUniformLocation(i, "tint"), this.flipY = t.getUniformLocation(i, "flipY"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(i, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i
    }, e.PrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
    }, e.ComplexPrimitiveShader = function(t) {
        this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
    }, e.ComplexPrimitiveShader.prototype.constructor = e.ComplexPrimitiveShader, e.ComplexPrimitiveShader.prototype.init = function() {
        var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.tintColor = t.getUniformLocation(i, "tint"), this.color = t.getUniformLocation(i, "color"), this.flipY = t.getUniformLocation(i, "flipY"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i
    }, e.ComplexPrimitiveShader.prototype.destroy = function() {
        this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
    }, e.glContexts = [], e.instances = [], e.WebGLRenderer = function(t) {
        this.game = t, e.defaultRenderer || (e.defaultRenderer = this), this.type = e.WEBGL_RENDERER, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
            alpha: this.transparent,
            antialias: t.antialias,
            premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
            stencil: !0,
            preserveDrawingBuffer: this.preserveDrawingBuffer
        }, this.projection = new e.Point, this.offset = new e.Point, this.shaderManager = new e.WebGLShaderManager, this.spriteBatch = new e.WebGLSpriteBatch, this.maskManager = new e.WebGLMaskManager, this.filterManager = new e.WebGLFilterManager, this.stencilManager = new e.WebGLStencilManager, this.blendModeManager = new e.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes()
    }, e.WebGLRenderer.prototype.constructor = e.WebGLRenderer, e.WebGLRenderer.prototype.initContext = function() {
        var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
        if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.glContextId = t.id = e.WebGLRenderer.glContextId++, e.glContexts[this.glContextId] = t, e.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
    }, e.WebGLRenderer.prototype.render = function(t) {
        if (!this.contextLost) {
            var e = this.gl;
            e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
        }
    }, e.WebGLRenderer.prototype.renderDisplayObject = function(t, i, n, s) {
        this.renderSession.blendModeManager.setBlendMode(e.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = n ? -1 : 1, this.renderSession.projection = i, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, n), t._renderWebGL(this.renderSession, s), this.spriteBatch.end()
    }, e.WebGLRenderer.prototype.resize = function(t, e) {
        this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
    }, e.WebGLRenderer.prototype.updateTexture = function(t) {
        if (!t.hasLoaded) return !1;
        var i = this.gl;
        return t._glTextures[i.id] || (t._glTextures[i.id] = i.createTexture()), i.bindTexture(i.TEXTURE_2D, t._glTextures[i.id]), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, t.source), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR : i.NEAREST), t.mipmap && e.isPowerOfTwo(t.width, t.height) ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST), i.generateMipmap(i.TEXTURE_2D)) : i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR : i.NEAREST), t._powerOf2 ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE)), t._dirty[i.id] = !1, !0
    }, e.WebGLRenderer.prototype.destroy = function() {
        e.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, e.CanvasPool.remove(this), e.instances[this.glContextId] = null, e.WebGLRenderer.glContextId--
    }, e.WebGLRenderer.prototype.mapBlendModes = function() {
        var t = this.gl;
        if (!e.blendModesWebGL) {
            var i = [],
                n = e.blendModes;
            i[n.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], i[n.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], i[n.SCREEN] = [t.SRC_ALPHA, t.ONE], i[n.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[n.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e.blendModesWebGL = i
        }
    }, e.WebGLRenderer.glContextId = 0, e.WebGLBlendModeManager = function() {
        this.currentBlendMode = 99999
    }, e.WebGLBlendModeManager.prototype.constructor = e.WebGLBlendModeManager, e.WebGLBlendModeManager.prototype.setContext = function(t) {
        this.gl = t
    }, e.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
        if (this.currentBlendMode === t) return !1;
        this.currentBlendMode = t;
        var i = e.blendModesWebGL[this.currentBlendMode];
        return i && this.gl.blendFunc(i[0], i[1]), !0
    }, e.WebGLBlendModeManager.prototype.destroy = function() {
        this.gl = null
    }, e.WebGLMaskManager = function() {}, e.WebGLMaskManager.prototype.constructor = e.WebGLMaskManager, e.WebGLMaskManager.prototype.setContext = function(t) {
        this.gl = t
    }, e.WebGLMaskManager.prototype.pushMask = function(t, i) {
        var n = i.gl;
        t.dirty && e.WebGLGraphics.updateGraphics(t, n), void 0 !== t._webGL[n.id] && void 0 !== t._webGL[n.id].data && 0 !== t._webGL[n.id].data.length && i.stencilManager.pushStencil(t, t._webGL[n.id].data[0], i)
    }, e.WebGLMaskManager.prototype.popMask = function(t, e) {
        var i = this.gl;
        void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
    }, e.WebGLMaskManager.prototype.destroy = function() {
        this.gl = null
    }, e.WebGLStencilManager = function() {
        this.stencilStack = [], this.reverse = !0, this.count = 0
    }, e.WebGLStencilManager.prototype.setContext = function(t) {
        this.gl = t
    }, e.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
        var n = this.gl;
        this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (n.enable(n.STENCIL_TEST), n.clear(n.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
        var s = this.count;
        n.colorMask(!1, !1, !1, !1), n.stencilFunc(n.ALWAYS, 0, 255), n.stencilOp(n.KEEP, n.KEEP, n.INVERT), 1 === e.mode ? (n.drawElements(n.TRIANGLE_FAN, e.indices.length - 4, n.UNSIGNED_SHORT, 0), this.reverse ? (n.stencilFunc(n.EQUAL, 255 - s, 255), n.stencilOp(n.KEEP, n.KEEP, n.DECR)) : (n.stencilFunc(n.EQUAL, s, 255), n.stencilOp(n.KEEP, n.KEEP, n.INCR)), n.drawElements(n.TRIANGLE_FAN, 4, n.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? n.stencilFunc(n.EQUAL, 255 - (s + 1), 255) : n.stencilFunc(n.EQUAL, s + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (n.stencilFunc(n.EQUAL, s, 255), n.stencilOp(n.KEEP, n.KEEP, n.INCR)) : (n.stencilFunc(n.EQUAL, 255 - s, 255), n.stencilOp(n.KEEP, n.KEEP, n.DECR)), n.drawElements(n.TRIANGLE_STRIP, e.indices.length, n.UNSIGNED_SHORT, 0), this.reverse ? n.stencilFunc(n.EQUAL, s + 1, 255) : n.stencilFunc(n.EQUAL, 255 - (s + 1), 255)), n.colorMask(!0, !0, !0, !0), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), this.count++
    }, e.WebGLStencilManager.prototype.bindGraphics = function(t, i, n) {
        this._currentGraphics = t;
        var s, r = this.gl,
            o = n.projection,
            a = n.offset;
        1 === i.mode ? (s = n.shaderManager.complexPrimitiveShader, n.shaderManager.setShader(s), r.uniform1f(s.flipY, n.flipY), r.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), r.uniform2f(s.projectionVector, o.x, -o.y), r.uniform2f(s.offsetVector, -a.x, -a.y), r.uniform3fv(s.tintColor, e.hex2rgb(t.tint)), r.uniform3fv(s.color, i.color), r.uniform1f(s.alpha, t.worldAlpha * i.alpha), r.bindBuffer(r.ARRAY_BUFFER, i.buffer), r.vertexAttribPointer(s.aVertexPosition, 2, r.FLOAT, !1, 8, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, i.indexBuffer)) : (s = n.shaderManager.primitiveShader, n.shaderManager.setShader(s), r.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), r.uniform1f(s.flipY, n.flipY), r.uniform2f(s.projectionVector, o.x, -o.y), r.uniform2f(s.offsetVector, -a.x, -a.y), r.uniform3fv(s.tintColor, e.hex2rgb(t.tint)), r.uniform1f(s.alpha, t.worldAlpha), r.bindBuffer(r.ARRAY_BUFFER, i.buffer), r.vertexAttribPointer(s.aVertexPosition, 2, r.FLOAT, !1, 24, 0), r.vertexAttribPointer(s.colorAttribute, 4, r.FLOAT, !1, 24, 8), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, i.indexBuffer))
    }, e.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
        var n = this.gl;
        if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) n.disable(n.STENCIL_TEST);
        else {
            var s = this.count;
            this.bindGraphics(t, e, i), n.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (n.stencilFunc(n.EQUAL, 255 - (s + 1), 255), n.stencilOp(n.KEEP, n.KEEP, n.INCR)) : (n.stencilFunc(n.EQUAL, s + 1, 255), n.stencilOp(n.KEEP, n.KEEP, n.DECR)), n.drawElements(n.TRIANGLE_FAN, 4, n.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), n.stencilFunc(n.ALWAYS, 0, 255), n.stencilOp(n.KEEP, n.KEEP, n.INVERT), n.drawElements(n.TRIANGLE_FAN, e.indices.length - 4, n.UNSIGNED_SHORT, 0), this.reverse ? n.stencilFunc(n.EQUAL, s, 255) : n.stencilFunc(n.EQUAL, 255 - s, 255)) : (this.reverse ? (n.stencilFunc(n.EQUAL, s + 1, 255), n.stencilOp(n.KEEP, n.KEEP, n.DECR)) : (n.stencilFunc(n.EQUAL, 255 - (s + 1), 255), n.stencilOp(n.KEEP, n.KEEP, n.INCR)), n.drawElements(n.TRIANGLE_STRIP, e.indices.length, n.UNSIGNED_SHORT, 0), this.reverse ? n.stencilFunc(n.EQUAL, s, 255) : n.stencilFunc(n.EQUAL, 255 - s, 255)), n.colorMask(!0, !0, !0, !0), n.stencilOp(n.KEEP, n.KEEP, n.KEEP)
        }
    }, e.WebGLStencilManager.prototype.destroy = function() {
        this.stencilStack = null, this.gl = null
    }, e.WebGLShaderManager = function() {
        this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
        for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
        this.stack = []
    }, e.WebGLShaderManager.prototype.constructor = e.WebGLShaderManager, e.WebGLShaderManager.prototype.setContext = function(t) {
        this.gl = t, this.primitiveShader = new e.PrimitiveShader(t), this.complexPrimitiveShader = new e.ComplexPrimitiveShader(t), this.defaultShader = new e.PixiShader(t), this.fastShader = new e.PixiFastShader(t), this.stripShader = new e.StripShader(t), this.setShader(this.defaultShader)
    }, e.WebGLShaderManager.prototype.setAttribs = function(t) {
        var e;
        for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
        for (e = 0; e < t.length; e++) {
            var i = t[e];
            this.tempAttribState[i] = !0
        }
        var n = this.gl;
        for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? n.enableVertexAttribArray(e) : n.disableVertexAttribArray(e))
    }, e.WebGLShaderManager.prototype.setShader = function(t) {
        return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
    }, e.WebGLShaderManager.prototype.destroy = function() {
        this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null
    }, e.WebGLSpriteBatch = function() {
        this.vertSize = 5, this.size = 2e3;
        var t = 4 * this.size * 4 * this.vertSize,
            i = 6 * this.size;
        this.vertices = new e.ArrayBuffer(t), this.positions = new e.Float32Array(this.vertices), this.colors = new e.Uint32Array(this.vertices), this.indices = new e.Uint16Array(i), this.lastIndexCount = 0;
        for (var n = 0, s = 0; n < i; n += 6, s += 4) this.indices[n + 0] = s + 0, this.indices[n + 1] = s + 1, this.indices[n + 2] = s + 2, this.indices[n + 3] = s + 0, this.indices[n + 4] = s + 2, this.indices[n + 5] = s + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new e.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
    }, e.WebGLSpriteBatch.prototype.setContext = function(t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
        var i = new e.PixiShader(t);
        i.fragmentSrc = this.defaultShader.fragmentSrc, i.uniforms = {}, i.init(), this.defaultShader.shaders[t.id] = i
    }, e.WebGLSpriteBatch.prototype.begin = function(t) {
        this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
    }, e.WebGLSpriteBatch.prototype.end = function() {
        this.flush()
    }, e.WebGLSpriteBatch.prototype.render = function(t, e) {
        var i = t.texture,
            n = t.worldTransform;
        e && (n = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
        var s = i._uvs;
        if (s) {
            var r, o, a, h, l = t.anchor.x,
                c = t.anchor.y;
            if (i.trim) {
                var u = i.trim;
                r = (o = u.x - l * u.width) + i.crop.width, a = (h = u.y - c * u.height) + i.crop.height
            } else r = i.frame.width * (1 - l), o = i.frame.width * -l, a = i.frame.height * (1 - c), h = i.frame.height * -c;
            var d = 4 * this.currentBatchSize * this.vertSize,
                p = i.baseTexture.resolution,
                f = n.a / p,
                g = n.b / p,
                m = n.c / p,
                y = n.d / p,
                v = n.tx,
                b = n.ty,
                x = this.colors,
                w = this.positions;
            this.renderSession.roundPixels ? (w[d] = f * o + m * h + v | 0, w[d + 1] = y * h + g * o + b | 0, w[d + 5] = f * r + m * h + v | 0, w[d + 6] = y * h + g * r + b | 0, w[d + 10] = f * r + m * a + v | 0, w[d + 11] = y * a + g * r + b | 0, w[d + 15] = f * o + m * a + v | 0, w[d + 16] = y * a + g * o + b | 0) : (w[d] = f * o + m * h + v, w[d + 1] = y * h + g * o + b, w[d + 5] = f * r + m * h + v, w[d + 6] = y * h + g * r + b, w[d + 10] = f * r + m * a + v, w[d + 11] = y * a + g * r + b, w[d + 15] = f * o + m * a + v, w[d + 16] = y * a + g * o + b), w[d + 2] = s.x0, w[d + 3] = s.y0, w[d + 7] = s.x1, w[d + 8] = s.y1, w[d + 12] = s.x2, w[d + 13] = s.y2, w[d + 17] = s.x3, w[d + 18] = s.y3;
            var _ = t.tint;
            x[d + 4] = x[d + 9] = x[d + 14] = x[d + 19] = (_ >> 16) + (65280 & _) + ((255 & _) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t
        }
    }, e.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
        var i = t.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture), t._uvs || (t._uvs = new e.TextureUvs);
        var n = t._uvs,
            s = i.baseTexture.width,
            r = i.baseTexture.height;
        t.tilePosition.x %= s * t.tileScaleOffset.x, t.tilePosition.y %= r * t.tileScaleOffset.y;
        var o = t.tilePosition.x / (s * t.tileScaleOffset.x),
            a = t.tilePosition.y / (r * t.tileScaleOffset.y),
            h = t.width / s / (t.tileScale.x * t.tileScaleOffset.x),
            l = t.height / r / (t.tileScale.y * t.tileScaleOffset.y);
        n.x0 = 0 - o, n.y0 = 0 - a, n.x1 = 1 * h - o, n.y1 = 0 - a, n.x2 = 1 * h - o, n.y2 = 1 * l - a, n.x3 = 0 - o, n.y3 = 1 * l - a;
        var c = t.tint,
            u = (c >> 16) + (65280 & c) + ((255 & c) << 16) + (255 * t.worldAlpha << 24),
            d = this.positions,
            p = this.colors,
            f = t.width,
            g = t.height,
            m = t.anchor.x,
            y = t.anchor.y,
            v = f * (1 - m),
            b = f * -m,
            x = g * (1 - y),
            w = g * -y,
            _ = 4 * this.currentBatchSize * this.vertSize,
            P = i.baseTexture.resolution,
            T = t.worldTransform,
            S = T.a / P,
            C = T.b / P,
            A = T.c / P,
            E = T.d / P,
            M = T.tx,
            I = T.ty;
        d[_++] = S * b + A * w + M, d[_++] = E * w + C * b + I, d[_++] = n.x0, d[_++] = n.y0, p[_++] = u, d[_++] = S * v + A * w + M, d[_++] = E * w + C * v + I, d[_++] = n.x1, d[_++] = n.y1, p[_++] = u, d[_++] = S * v + A * x + M, d[_++] = E * x + C * v + I, d[_++] = n.x2, d[_++] = n.y2, p[_++] = u, d[_++] = S * b + A * x + M, d[_++] = E * x + C * b + I, d[_++] = n.x3, d[_++] = n.y3, p[_++] = u, this.sprites[this.currentBatchSize++] = t
    }, e.WebGLSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t, i, n, s, r = this.gl;
            if (this.dirty) {
                this.dirty = !1, r.activeTexture(r.TEXTURE0), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t = this.defaultShader.shaders[r.id];
                var o = 4 * this.vertSize;
                r.vertexAttribPointer(t.aVertexPosition, 2, r.FLOAT, !1, o, 0), r.vertexAttribPointer(t.aTextureCoord, 2, r.FLOAT, !1, o, 8), r.vertexAttribPointer(t.colorAttribute, 4, r.UNSIGNED_BYTE, !0, o, 16)
            }
            if (this.currentBatchSize > .5 * this.size) r.bufferSubData(r.ARRAY_BUFFER, 0, this.vertices);
            else {
                var a = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                r.bufferSubData(r.ARRAY_BUFFER, 0, a)
            }
            for (var h, l = 0, c = 0, u = null, d = this.renderSession.blendModeManager.currentBlendMode, p = null, f = !1, g = !1, m = 0, y = this.currentBatchSize; m < y; m++) {
                i = (h = this.sprites[m]).tilingTexture ? h.tilingTexture.baseTexture : h.texture.baseTexture, f = d !== (n = h.blendMode), g = p !== (s = h.shader || this.defaultShader);
                var v = i.skipRender;
                if (v && h.children.length > 0 && (v = !1), (u !== i && !v || f || g) && (this.renderBatch(u, l, c), c = m, l = 0, u = i, f && (d = n, this.renderSession.blendModeManager.setBlendMode(d)), g)) {
                    (t = (p = s).shaders[r.id]) || ((t = new e.PixiShader(r)).fragmentSrc = p.fragmentSrc, t.uniforms = p.uniforms, t.init(), p.shaders[r.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                    var b = this.renderSession.projection;
                    r.uniform2f(t.projectionVector, b.x, b.y);
                    var x = this.renderSession.offset;
                    r.uniform2f(t.offsetVector, x.x, x.y)
                }
                l++
            }
            this.renderBatch(u, l, c), this.currentBatchSize = 0
        }
    }, e.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
        if (0 !== e) {
            var n = this.gl;
            if (t._dirty[n.id]) {
                if (!this.renderSession.renderer.updateTexture(t)) return
            } else n.bindTexture(n.TEXTURE_2D, t._glTextures[n.id]);
            n.drawElements(n.TRIANGLES, 6 * e, n.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
        }
    }, e.WebGLSpriteBatch.prototype.stop = function() {
        this.flush(), this.dirty = !0
    }, e.WebGLSpriteBatch.prototype.start = function() {
        this.dirty = !0
    }, e.WebGLSpriteBatch.prototype.destroy = function() {
        this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
    }, e.WebGLFastSpriteBatch = function(t) {
        this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
        var i = 4 * this.size * this.vertSize,
            n = 6 * this.maxSize;
        this.vertices = new e.Float32Array(i), this.indices = new e.Uint16Array(n), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
        for (var s = 0, r = 0; s < n; s += 6, r += 4) this.indices[s + 0] = r + 0, this.indices[s + 1] = r + 1, this.indices[s + 2] = r + 2, this.indices[s + 3] = r + 0, this.indices[s + 4] = r + 2, this.indices[s + 5] = r + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
    }, e.WebGLFastSpriteBatch.prototype.constructor = e.WebGLFastSpriteBatch, e.WebGLFastSpriteBatch.prototype.setContext = function(t) {
        this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
    }, e.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
        this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
    }, e.WebGLFastSpriteBatch.prototype.end = function() {
        this.flush()
    }, e.WebGLFastSpriteBatch.prototype.render = function(t) {
        var e = t.children,
            i = e[0];
        if (i.texture._uvs) {
            this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
            for (var n = 0, s = e.length; n < s; n++) this.renderSprite(e[n]);
            this.flush()
        }
    }, e.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
        if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs))) {
            var e, i, n, s, r, o, a = this.vertices;
            if (e = t.texture._uvs, t.texture.frame.width, t.texture.frame.height, t.texture.trim) {
                var h = t.texture.trim;
                i = (n = h.x - t.anchor.x * h.width) + t.texture.crop.width, s = (r = h.y - t.anchor.y * h.height) + t.texture.crop.height
            } else i = t.texture.frame.width * (1 - t.anchor.x), n = t.texture.frame.width * -t.anchor.x, s = t.texture.frame.height * (1 - t.anchor.y), r = t.texture.frame.height * -t.anchor.y;
            o = 4 * this.currentBatchSize * this.vertSize, a[o++] = n, a[o++] = r, a[o++] = t.position.x, a[o++] = t.position.y, a[o++] = t.scale.x, a[o++] = t.scale.y, a[o++] = t.rotation, a[o++] = e.x0, a[o++] = e.y1, a[o++] = t.alpha, a[o++] = i, a[o++] = r, a[o++] = t.position.x, a[o++] = t.position.y, a[o++] = t.scale.x, a[o++] = t.scale.y, a[o++] = t.rotation, a[o++] = e.x1, a[o++] = e.y1, a[o++] = t.alpha, a[o++] = i, a[o++] = s, a[o++] = t.position.x, a[o++] = t.position.y, a[o++] = t.scale.x, a[o++] = t.scale.y, a[o++] = t.rotation, a[o++] = e.x2, a[o++] = e.y2, a[o++] = t.alpha, a[o++] = n, a[o++] = s, a[o++] = t.position.x, a[o++] = t.position.y, a[o++] = t.scale.x, a[o++] = t.scale.y, a[o++] = t.rotation, a[o++] = e.x3, a[o++] = e.y3, a[o++] = t.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
        }
    }, e.WebGLFastSpriteBatch.prototype.flush = function() {
        if (0 !== this.currentBatchSize) {
            var t = this.gl;
            if (this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
            else {
                var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                t.bufferSubData(t.ARRAY_BUFFER, 0, e)
            }
            t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
        }
    }, e.WebGLFastSpriteBatch.prototype.stop = function() {
        this.flush()
    }, e.WebGLFastSpriteBatch.prototype.start = function() {
        var t = this.gl;
        t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var e = this.renderSession.projection;
        t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
        var i = 4 * this.vertSize;
        t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36)
    }, e.WebGLFilterManager = function() {
        this.filterStack = [], this.offsetX = 0, this.offsetY = 0
    }, e.WebGLFilterManager.prototype.constructor = e.WebGLFilterManager, e.WebGLFilterManager.prototype.setContext = function(t) {
        this.gl = t, this.texturePool = [], this.initShaderBuffers()
    }, e.WebGLFilterManager.prototype.begin = function(t, e) {
        this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
        var i = this.renderSession.projection;
        this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
    }, e.WebGLFilterManager.prototype.pushFilter = function(t) {
        var i = this.gl,
            n = this.renderSession.projection,
            s = this.renderSession.offset;
        t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new e.WebGLStencilManager, this.renderSession.stencilManager.setContext(i), i.disable(i.STENCIL_TEST), this.filterStack.push(t);
        var r = t.filterPasses[0];
        this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
        var o = this.texturePool.pop();
        o ? o.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : o = new e.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), i.bindTexture(i.TEXTURE_2D, o.texture);
        var a = t._filterArea,
            h = r.padding;
        a.x -= h, a.y -= h, a.width += 2 * h, a.height += 2 * h, a.x < 0 && (a.x = 0), a.width > this.width && (a.width = this.width), a.y < 0 && (a.y = 0), a.height > this.height && (a.height = this.height), i.bindFramebuffer(i.FRAMEBUFFER, o.frameBuffer), i.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution), n.x = a.width / 2, n.y = -a.height / 2, s.x = -a.x, s.y = -a.y, i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), t._glFilterTexture = o
    }, e.WebGLFilterManager.prototype.popFilter = function() {
        var t = this.gl,
            i = this.filterStack.pop(),
            n = i._filterArea,
            s = i._glFilterTexture,
            r = this.renderSession.projection,
            o = this.renderSession.offset;
        if (i.filterPasses.length > 1) {
            t.viewport(0, 0, n.width * this.renderSession.resolution, n.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = n.height, this.vertexArray[2] = n.width, this.vertexArray[3] = n.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = n.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = n.width / this.width, this.uvArray[5] = n.height / this.height, this.uvArray[6] = n.width / this.width, this.uvArray[7] = n.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
            var a = s,
                h = this.texturePool.pop();
            h || (h = new e.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
            for (var l = 0; l < i.filterPasses.length - 1; l++) {
                var c = i.filterPasses[l];
                t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a.texture), this.applyFilterPass(c, n, n.width, n.height);
                var u = a;
                a = h, h = u
            }
            t.enable(t.BLEND), s = a, this.texturePool.push(h)
        }
        var d = i.filterPasses[i.filterPasses.length - 1];
        this.offsetX -= n.x, this.offsetY -= n.y;
        var p = this.width,
            f = this.height,
            g = 0,
            m = 0,
            y = this.buffer;
        if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
        else {
            var v = this.filterStack[this.filterStack.length - 1];
            p = (n = v._filterArea).width, f = n.height, g = n.x, m = n.y, y = v._glFilterTexture.frameBuffer
        }
        r.x = p / 2, r.y = -f / 2, o.x = g, o.y = m;
        var b = (n = i._filterArea).x - g,
            x = n.y - m;
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = b, this.vertexArray[1] = x + n.height, this.vertexArray[2] = b + n.width, this.vertexArray[3] = x + n.height, this.vertexArray[4] = b, this.vertexArray[5] = x, this.vertexArray[6] = b + n.width, this.vertexArray[7] = x, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = n.width / this.width, this.uvArray[5] = n.height / this.height, this.uvArray[6] = n.width / this.width, this.uvArray[7] = n.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, p * this.renderSession.resolution, f * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, y), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, s.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = i._previous_stencil_mgr, i._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(d, n, p, f), this.texturePool.push(s), i._glFilterTexture = null
    }, e.WebGLFilterManager.prototype.applyFilterPass = function(t, i, n, s) {
        var r = this.gl,
            o = t.shaders[r.id];
        o || ((o = new e.PixiShader(r)).fragmentSrc = t.fragmentSrc, o.uniforms = t.uniforms, o.init(), t.shaders[r.id] = o), this.renderSession.shaderManager.setShader(o), r.uniform2f(o.projectionVector, n / 2, -s / 2), r.uniform2f(o.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), o.syncUniforms(), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.vertexAttribPointer(o.aVertexPosition, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.uvBuffer), r.vertexAttribPointer(o.aTextureCoord, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.colorBuffer), r.vertexAttribPointer(o.colorAttribute, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer), r.drawElements(r.TRIANGLES, 6, r.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
    }, e.WebGLFilterManager.prototype.initShaderBuffers = function() {
        var t = this.gl;
        this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new e.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new e.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new e.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
    }, e.WebGLFilterManager.prototype.destroy = function() {
        var t = this.gl;
        this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
        for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
        this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
    }, e.FilterTexture = function(t, i, n, s) {
        this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), s = s || e.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, s === e.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, s === e.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(i, n)
    }, e.FilterTexture.prototype.constructor = e.FilterTexture, e.FilterTexture.prototype.clear = function() {
        var t = this.gl;
        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
    }, e.FilterTexture.prototype.resize = function(t, e) {
        if (this.width !== t || this.height !== e) {
            this.width = t, this.height = e;
            var i = this.gl;
            i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
        }
    }, e.FilterTexture.prototype.destroy = function() {
        var t = this.gl;
        t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
    }, e.CanvasBuffer = function(t, i) {
        this.width = t, this.height = i, this.canvas = e.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = i
    }, e.CanvasBuffer.prototype.constructor = e.CanvasBuffer, e.CanvasBuffer.prototype.clear = function() {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
    }, e.CanvasBuffer.prototype.resize = function(t, e) {
        this.width = this.canvas.width = t, this.height = this.canvas.height = e
    }, e.CanvasBuffer.prototype.destroy = function() {
        e.CanvasPool.remove(this)
    }, e.CanvasMaskManager = function() {}, e.CanvasMaskManager.prototype.constructor = e.CanvasMaskManager, e.CanvasMaskManager.prototype.pushMask = function(t, i) {
        var n = i.context;
        n.save();
        var s = t.alpha,
            r = t.worldTransform,
            o = i.resolution;
        n.setTransform(r.a * o, r.b * o, r.c * o, r.d * o, r.tx * o, r.ty * o), e.CanvasGraphics.renderGraphicsMask(t, n), n.clip(), t.worldAlpha = s
    }, e.CanvasMaskManager.prototype.popMask = function(t) {
        t.context.restore()
    }, e.CanvasTinter = function() {}, e.CanvasTinter.getTintedTexture = function(t, i) {
        var n = t.tintedTexture || e.CanvasPool.create(this);
        return e.CanvasTinter.tintMethod(t.texture, i, n), n
    }, e.CanvasTinter.tintWithMultiply = function(t, e, i) {
        var n = i.getContext("2d"),
            s = t.crop;
        i.width === s.width && i.height === s.height || (i.width = s.width, i.height = s.height), n.clearRect(0, 0, s.width, s.height), n.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), n.fillRect(0, 0, s.width, s.height), n.globalCompositeOperation = "multiply", n.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height), n.globalCompositeOperation = "destination-atop", n.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height)
    }, e.CanvasTinter.tintWithPerPixel = function(t, i, n) {
        var s = n.getContext("2d"),
            r = t.crop;
        n.width = r.width, n.height = r.height, s.globalCompositeOperation = "copy", s.drawImage(t.baseTexture.source, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
        for (var o = e.hex2rgb(i), a = o[0], h = o[1], l = o[2], c = s.getImageData(0, 0, r.width, r.height), u = c.data, d = 0; d < u.length; d += 4)
            if (u[d + 0] *= a, u[d + 1] *= h, u[d + 2] *= l, !e.CanvasTinter.canHandleAlpha) {
                var p = u[d + 3];
                u[d + 0] /= 255 / p, u[d + 1] /= 255 / p, u[d + 2] /= 255 / p
            }
        s.putImageData(c, 0, 0)
    }, e.CanvasTinter.checkInverseAlpha = function() {
        var t = new e.CanvasBuffer(2, 1);
        t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1);
        var i = t.context.getImageData(0, 0, 1, 1);
        if (null === i) return !1;
        t.context.putImageData(i, 1, 0);
        var n = t.context.getImageData(1, 0, 1, 1);
        return n.data[0] === i.data[0] && n.data[1] === i.data[1] && n.data[2] === i.data[2] && n.data[3] === i.data[3]
    }, e.CanvasTinter.canHandleAlpha = e.CanvasTinter.checkInverseAlpha(), e.CanvasTinter.canUseMultiply = e.canUseNewCanvasBlendModes(), e.CanvasTinter.tintMethod = e.CanvasTinter.canUseMultiply ? e.CanvasTinter.tintWithMultiply : e.CanvasTinter.tintWithPerPixel, e.CanvasRenderer = function(t) {
        this.game = t, e.defaultRenderer || (e.defaultRenderer = this), this.type = e.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
            alpha: this.transparent
        }), this.refresh = !0, this.count = 0, this.maskManager = new e.CanvasMaskManager, this.renderSession = {
            context: this.context,
            maskManager: this.maskManager,
            scaleMode: null,
            smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
            roundPixels: !1
        }, this.mapBlendModes(), this.resize(this.width, this.height)
    }, e.CanvasRenderer.prototype.constructor = e.CanvasRenderer, e.CanvasRenderer.prototype.render = function(t) {
        this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
    }, e.CanvasRenderer.prototype.destroy = function(t) {
        void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
    }, e.CanvasRenderer.prototype.resize = function(t, i) {
        this.width = t * this.resolution, this.height = i * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === e.scaleModes.LINEAR)
    }, e.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
        this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
    }, e.CanvasRenderer.prototype.mapBlendModes = function() {
        if (!e.blendModesCanvas) {
            var t = [],
                i = e.blendModes,
                n = e.canUseNewCanvasBlendModes();
            t[i.NORMAL] = "source-over", t[i.ADD] = "lighter", t[i.MULTIPLY] = n ? "multiply" : "source-over", t[i.SCREEN] = n ? "screen" : "source-over", t[i.OVERLAY] = n ? "overlay" : "source-over", t[i.DARKEN] = n ? "darken" : "source-over", t[i.LIGHTEN] = n ? "lighten" : "source-over", t[i.COLOR_DODGE] = n ? "color-dodge" : "source-over", t[i.COLOR_BURN] = n ? "color-burn" : "source-over", t[i.HARD_LIGHT] = n ? "hard-light" : "source-over", t[i.SOFT_LIGHT] = n ? "soft-light" : "source-over", t[i.DIFFERENCE] = n ? "difference" : "source-over", t[i.EXCLUSION] = n ? "exclusion" : "source-over", t[i.HUE] = n ? "hue" : "source-over", t[i.SATURATION] = n ? "saturation" : "source-over", t[i.COLOR] = n ? "color" : "source-over", t[i.LUMINOSITY] = n ? "luminosity" : "source-over", e.blendModesCanvas = t
        }
    }, e.BaseTexture = function(t, i) {
        this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = i || e.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
    }, e.BaseTexture.prototype.constructor = e.BaseTexture, e.BaseTexture.prototype.forceLoaded = function(t, e) {
        this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
    }, e.BaseTexture.prototype.destroy = function() {
        this.source && e.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
    }, e.BaseTexture.prototype.updateSourceImage = function(t) {}, e.BaseTexture.prototype.dirty = function() {
        for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
    }, e.BaseTexture.prototype.unloadFromGPU = function() {
        this.dirty();
        for (var t = this._glTextures.length - 1; t >= 0; t--) {
            var i = this._glTextures[t],
                n = e.glContexts[t];
            n && i && n.deleteTexture(i)
        }
        this._glTextures.length = 0, this.dirty()
    }, e.BaseTexture.fromCanvas = function(t, i) {
        return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new e.BaseTexture(t, i)
    }, e.TextureSilentFail = !1, e.Texture = function(t, i, n, s) {
        this.noFrame = !1, i || (this.noFrame = !0, i = new e.Rectangle(0, 0, 1, 1)), t instanceof e.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = i, this.trim = s, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = n || new e.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (i = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(i))
    }, e.Texture.prototype.constructor = e.Texture, e.Texture.prototype.onBaseTextureLoaded = function() {
        var t = this.baseTexture;
        this.noFrame && (this.frame = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
    }, e.Texture.prototype.destroy = function(t) {
        t && this.baseTexture.destroy(), this.valid = !1
    }, e.Texture.prototype.setFrame = function(t) {
        if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
        else {
            if (!e.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            this.valid = !1
        }
    }, e.Texture.prototype._updateUvs = function() {
        this._uvs || (this._uvs = new e.TextureUvs);
        var t = this.crop,
            i = this.baseTexture.width,
            n = this.baseTexture.height;
        this._uvs.x0 = t.x / i, this._uvs.y0 = t.y / n, this._uvs.x1 = (t.x + t.width) / i, this._uvs.y1 = t.y / n, this._uvs.x2 = (t.x + t.width) / i, this._uvs.y2 = (t.y + t.height) / n, this._uvs.x3 = t.x / i, this._uvs.y3 = (t.y + t.height) / n
    }, e.Texture.fromCanvas = function(t, i) {
        var n = e.BaseTexture.fromCanvas(t, i);
        return new e.Texture(n)
    }, e.TextureUvs = function() {
        this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
    }, e.RenderTexture = function(t, i, n, s, r) {
        if (this.width = t || 100, this.height = i || 100, this.resolution = r || 1, this.frame = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new e.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = s || e.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, e.Texture.call(this, this.baseTexture, new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = n || e.defaultRenderer, this.renderer.type === e.WEBGL_RENDERER) {
            var o = this.renderer.gl;
            this.baseTexture._dirty[o.id] = !1, this.textureBuffer = new e.FilterTexture(o, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[o.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new e.Point(.5 * this.width, .5 * -this.height)
        } else this.render = this.renderCanvas, this.textureBuffer = new e.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
    }, e.RenderTexture.prototype = Object.create(e.Texture.prototype), e.RenderTexture.prototype.constructor = e.RenderTexture, e.RenderTexture.prototype.resize = function(t, i, n) {
        t === this.width && i === this.height || (this.valid = t > 0 && i > 0, this.width = t, this.height = i, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = i * this.resolution, n && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === e.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
    }, e.RenderTexture.prototype.clear = function() {
        this.valid && (this.renderer.type === e.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
    }, e.RenderTexture.prototype.renderWebGL = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var n = t.worldTransform;
            n.identity(), n.translate(0, 2 * this.projection.y), e && n.append(e), n.scale(1, -1);
            for (var s = 0; s < t.children.length; s++) t.children[s].updateTransform();
            var r = this.renderer.gl;
            r.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0
        }
    }, e.RenderTexture.prototype.renderCanvas = function(t, e, i) {
        if (this.valid && 0 !== t.alpha) {
            var n = t.worldTransform;
            n.identity(), e && n.append(e);
            for (var s = 0; s < t.children.length; s++) t.children[s].updateTransform();
            i && this.textureBuffer.clear();
            var r = this.renderer.resolution;
            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = r
        }
    }, e.RenderTexture.prototype.getImage = function() {
        var t = new Image;
        return t.src = this.getBase64(), t
    }, e.RenderTexture.prototype.getBase64 = function() {
        return this.getCanvas().toDataURL()
    }, e.RenderTexture.prototype.getCanvas = function() {
        if (this.renderer.type === e.WEBGL_RENDERER) {
            var t = this.renderer.gl,
                i = this.textureBuffer.width,
                n = this.textureBuffer.height,
                s = new Uint8Array(4 * i * n);
            t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, i, n, t.RGBA, t.UNSIGNED_BYTE, s), t.bindFramebuffer(t.FRAMEBUFFER, null);
            var r = new e.CanvasBuffer(i, n),
                o = r.context.getImageData(0, 0, i, n);
            return o.data.set(s), r.context.putImageData(o, 0, 0), r.canvas
        }
        return this.textureBuffer.canvas
    }, e.AbstractFilter = function(t, e) {
        this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || []
    }, e.AbstractFilter.prototype.constructor = e.AbstractFilter, e.AbstractFilter.prototype.syncUniforms = function() {
        for (var t = 0, e = this.shaders.length; t < e; t++) this.shaders[t].dirty = !0
    }, e.Strip = function(t) {
        e.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new e.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new e.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new e.Float32Array([1, 1, 1, 1]), this.indices = new e.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = e.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = e.Strip.DrawModes.TRIANGLE_STRIP
    }, e.Strip.prototype = Object.create(e.DisplayObjectContainer.prototype), e.Strip.prototype.constructor = e.Strip, e.Strip.prototype._renderWebGL = function(t) {
        !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
    }, e.Strip.prototype._initWebGL = function(t) {
        var e = t.gl;
        this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
    }, e.Strip.prototype._renderStrip = function(t) {
        var i = t.gl,
            n = t.projection,
            s = t.offset,
            r = t.shaderManager.stripShader,
            o = this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? i.TRIANGLE_STRIP : i.TRIANGLES;
        t.blendModeManager.setBlendMode(this.blendMode), i.uniformMatrix3fv(r.translationMatrix, !1, this.worldTransform.toArray(!0)), i.uniform2f(r.projectionVector, n.x, -n.y), i.uniform2f(r.offsetVector, -s.x, -s.y), i.uniform1f(r.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferData(i.ARRAY_BUFFER, this.vertices, i.STATIC_DRAW), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.bufferData(i.ARRAY_BUFFER, this.uvs, i.STATIC_DRAW), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, this.indices, i.STATIC_DRAW)) : (i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices), i.vertexAttribPointer(r.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.vertexAttribPointer(r.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), i.drawElements(o, this.indices.length, i.UNSIGNED_SHORT, 0)
    }, e.Strip.prototype._renderCanvas = function(t) {
        var i = t.context,
            n = this.worldTransform,
            s = n.tx * t.resolution + t.shakeX,
            r = n.ty * t.resolution + t.shakeY;
        t.roundPixels ? i.setTransform(n.a, n.b, n.c, n.d, 0 | s, 0 | r) : i.setTransform(n.a, n.b, n.c, n.d, s, r), this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(i) : this._renderCanvasTriangles(i)
    }, e.Strip.prototype._renderCanvasTriangleStrip = function(t) {
        var e = this.vertices,
            i = this.uvs,
            n = e.length / 2;
        this.count++;
        for (var s = 0; s < n - 2; s++) {
            var r = 2 * s;
            this._renderCanvasDrawTriangle(t, e, i, r, r + 2, r + 4)
        }
    }, e.Strip.prototype._renderCanvasTriangles = function(t) {
        var e = this.vertices,
            i = this.uvs,
            n = this.indices,
            s = n.length;
        this.count++;
        for (var r = 0; r < s; r += 3) {
            var o = 2 * n[r],
                a = 2 * n[r + 1],
                h = 2 * n[r + 2];
            this._renderCanvasDrawTriangle(t, e, i, o, a, h)
        }
    }, e.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, n, s, r) {
        var o = this.texture.baseTexture.source,
            a = this.texture.width,
            h = this.texture.height,
            l = e[n],
            c = e[s],
            u = e[r],
            d = e[n + 1],
            p = e[s + 1],
            f = e[r + 1],
            g = i[n] * a,
            m = i[s] * a,
            y = i[r] * a,
            v = i[n + 1] * h,
            b = i[s + 1] * h,
            x = i[r + 1] * h;
        if (this.canvasPadding > 0) {
            var w = this.canvasPadding / this.worldTransform.a,
                _ = this.canvasPadding / this.worldTransform.d,
                P = (l + c + u) / 3,
                T = (d + p + f) / 3,
                S = l - P,
                C = d - T,
                A = Math.sqrt(S * S + C * C);
            l = P + S / A * (A + w), d = T + C / A * (A + _), C = p - T, c = P + (S = c - P) / (A = Math.sqrt(S * S + C * C)) * (A + w), p = T + C / A * (A + _), C = f - T, u = P + (S = u - P) / (A = Math.sqrt(S * S + C * C)) * (A + w), f = T + C / A * (A + _)
        }
        t.save(), t.beginPath(), t.moveTo(l, d), t.lineTo(c, p), t.lineTo(u, f), t.closePath(), t.clip();
        var E = g * b + v * y + m * x - b * y - v * m - g * x,
            M = l * b + v * u + c * x - b * u - v * c - l * x,
            I = g * c + l * y + m * u - c * y - l * m - g * u,
            O = g * b * u + v * c * y + l * m * x - l * b * y - v * m * u - g * c * x,
            k = d * b + v * f + p * x - b * f - v * p - d * x,
            R = g * p + d * y + m * f - p * y - d * m - g * f,
            L = g * b * f + v * p * y + d * m * x - d * b * y - v * m * f - g * p * x;
        t.transform(M / E, k / E, I / E, R / E, O / E, L / E), t.drawImage(o, 0, 0), t.restore()
    }, e.Strip.prototype.renderStripFlat = function(t) {
        var e = this.context,
            i = t.vertices,
            n = i.length / 2;
        this.count++, e.beginPath();
        for (var s = 1; s < n - 2; s++) {
            var r = 2 * s,
                o = i[r],
                a = i[r + 2],
                h = i[r + 4],
                l = i[r + 1],
                c = i[r + 3],
                u = i[r + 5];
            e.moveTo(o, l), e.lineTo(a, c), e.lineTo(h, u)
        }
        e.fillStyle = "#FF0000", e.fill(), e.closePath()
    }, e.Strip.prototype.onTextureUpdate = function() {
        this.updateFrame = !0
    }, e.Strip.prototype.getBounds = function(t) {
        for (var i = t || this.worldTransform, n = i.a, s = i.b, r = i.c, o = i.d, a = i.tx, h = i.ty, l = -1 / 0, c = -1 / 0, u = 1 / 0, d = 1 / 0, p = this.vertices, f = 0, g = p.length; f < g; f += 2) {
            var m = p[f],
                y = p[f + 1],
                v = n * m + r * y + a,
                b = o * y + s * m + h;
            u = v < u ? v : u, d = b < d ? b : d, l = v > l ? v : l, c = b > c ? b : c
        }
        if (u === -1 / 0 || c === 1 / 0) return e.EmptyRectangle;
        var x = this._bounds;
        return x.x = u, x.width = l - u, x.y = d, x.height = c - d, this._currentBounds = x, x
    }, e.Strip.DrawModes = {
        TRIANGLE_STRIP: 0,
        TRIANGLES: 1
    }, e.Rope = function(t, i) {
        e.Strip.call(this, t), this.points = i, this.vertices = new e.Float32Array(4 * i.length), this.uvs = new e.Float32Array(4 * i.length), this.colors = new e.Float32Array(2 * i.length), this.indices = new e.Uint16Array(2 * i.length), this.refresh()
    }, e.Rope.prototype = Object.create(e.Strip.prototype), e.Rope.prototype.constructor = e.Rope, e.Rope.prototype.refresh = function() {
        var t = this.points;
        if (!(t.length < 1)) {
            var e = this.uvs,
                i = (t[0], this.indices),
                n = this.colors;
            this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, n[0] = 1, n[1] = 1, i[0] = 0, i[1] = 1;
            for (var s, r, o, a = t.length, h = 1; h < a; h++) s = t[h], o = h / (a - 1), e[r = 4 * h] = o, e[r + 1] = 0, e[r + 2] = o, e[r + 3] = 1, n[r = 2 * h] = 1, n[r + 1] = 1, i[r = 2 * h] = r, i[r + 1] = r + 1, s
        }
    }, e.Rope.prototype.updateTransform = function() {
        var t = this.points;
        if (!(t.length < 1)) {
            var i, n = t[0],
                s = {
                    x: 0,
                    y: 0
                };
            this.count -= .2;
            for (var r, o, a, h, l = this.vertices, c = t.length, u = 0; u < c; u++) r = t[u], o = 4 * u, i = u < t.length - 1 ? t[u + 1] : r, s.y = -(i.x - n.x), s.x = i.y - n.y, 10 * (1 - u / (c - 1)) > 1 && 1, a = Math.sqrt(s.x * s.x + s.y * s.y), h = this.texture.height / 2, s.x /= a, s.y /= a, s.x *= h, s.y *= h, l[o] = r.x + s.x, l[o + 1] = r.y + s.y, l[o + 2] = r.x - s.x, l[o + 3] = r.y - s.y, n = r;
            e.DisplayObjectContainer.prototype.updateTransform.call(this)
        }
    }, e.Rope.prototype.setTexture = function(t) {
        this.texture = t
    }, e.TilingSprite = function(t, i, n) {
        e.Sprite.call(this, t), this._width = i || 128, this._height = n || 128, this.tileScale = new e.Point(1, 1), this.tileScaleOffset = new e.Point(1, 1), this.tilePosition = new e.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = e.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0
    }, e.TilingSprite.prototype = Object.create(e.Sprite.prototype), e.TilingSprite.prototype.constructor = e.TilingSprite, e.TilingSprite.prototype.setTexture = function(t) {
        this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215)
    }, e.TilingSprite.prototype._renderWebGL = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                this.tilingTexture.needsUpdate && (t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
            }
            t.spriteBatch.renderTilingSprite(this);
            for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            t.spriteBatch.stop(), this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this._mask, t), t.spriteBatch.start()
        }
    }, e.TilingSprite.prototype._renderCanvas = function(t) {
        if (this.visible && this.renderable && 0 !== this.alpha) {
            var i = t.context;
            this._mask && t.maskManager.pushMask(this._mask, t), i.globalAlpha = this.worldAlpha;
            var n = this.worldTransform,
                s = t.resolution,
                r = n.tx * s + t.shakeX,
                o = n.ty * s + t.shakeY;
            if (i.setTransform(n.a * s, n.b * s, n.c * s, n.d * s, r, o), this.refreshTexture) {
                if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                this.tilePattern = i.createPattern(this.tilingTexture.baseTexture.source, "repeat")
            }
            var a = t.currentBlendMode;
            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, i.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]);
            var h = this.tilePosition,
                l = this.tileScale;
            h.x %= this.tilingTexture.baseTexture.width, h.y %= this.tilingTexture.baseTexture.height, i.scale(l.x, l.y), i.translate(h.x + this.anchor.x * -this._width, h.y + this.anchor.y * -this._height), i.fillStyle = this.tilePattern;
            r = -h.x, o = -h.y;
            var c = this._width / l.x,
                u = this._height / l.y;
            t.roundPixels && (r |= 0, o |= 0, c |= 0, u |= 0), i.fillRect(r, o, c, u), i.scale(1 / l.x, 1 / l.y), i.translate(-h.x + this.anchor.x * this._width, -h.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
            for (var d = 0; d < this.children.length; d++) this.children[d]._renderCanvas(t);
            a !== this.blendMode && (t.currentBlendMode = a, i.globalCompositeOperation = e.blendModesCanvas[a])
        }
    }, e.TilingSprite.prototype.onTextureUpdate = function() {}, e.TilingSprite.prototype.generateTilingTexture = function(t, i) {
        if (this.texture.baseTexture.hasLoaded) {
            var n = this.texture,
                s = n.frame,
                r = this._frame.sourceSizeW || this._frame.width,
                o = this._frame.sourceSizeH || this._frame.height,
                a = 0,
                h = 0;
            this._frame.trimmed && (a = this._frame.spriteSourceSizeX, h = this._frame.spriteSourceSizeY), t && (r = e.getNextPowerOfTwo(r), o = e.getNextPowerOfTwo(o)), this.canvasBuffer ? (this.canvasBuffer.resize(r, o), this.tilingTexture.baseTexture.width = r, this.tilingTexture.baseTexture.height = o, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new e.CanvasBuffer(r, o), this.tilingTexture = e.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, r, o));
            var l = n.crop.width,
                c = n.crop.height;
            l === r && c === o || (l = r, c = o), this.canvasBuffer.context.drawImage(n.baseTexture.source, n.crop.x, n.crop.y, n.crop.width, n.crop.height, a, h, l, c), this.tileScaleOffset.x = s.width / r, this.tileScaleOffset.y = s.height / o, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
        }
    }, e.TilingSprite.prototype.getBounds = function() {
        var t = this._width,
            e = this._height,
            i = t * (1 - this.anchor.x),
            n = t * -this.anchor.x,
            s = e * (1 - this.anchor.y),
            r = e * -this.anchor.y,
            o = this.worldTransform,
            a = o.a,
            h = o.b,
            l = o.c,
            c = o.d,
            u = o.tx,
            d = o.ty,
            p = a * n + l * r + u,
            f = c * r + h * n + d,
            g = a * i + l * r + u,
            m = c * r + h * i + d,
            y = a * i + l * s + u,
            v = c * s + h * i + d,
            b = a * n + l * s + u,
            x = c * s + h * n + d,
            w = -1 / 0,
            _ = -1 / 0,
            P = 1 / 0,
            T = 1 / 0;
        P = b < (P = y < (P = g < (P = p < P ? p : P) ? g : P) ? y : P) ? b : P, T = x < (T = v < (T = m < (T = f < T ? f : T) ? m : T) ? v : T) ? x : T, w = b > (w = y > (w = g > (w = p > w ? p : w) ? g : w) ? y : w) ? b : w, _ = x > (_ = v > (_ = m > (_ = f > _ ? f : _) ? m : _) ? v : _) ? x : _;
        var S = this._bounds;
        return S.x = P, S.width = w - P, S.y = T, S.height = _ - T, this._currentBounds = S, S
    }, e.TilingSprite.prototype.destroy = function() {
        e.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
    }, Object.defineProperty(e.TilingSprite.prototype, "width", {
        get: function() {
            return this._width
        },
        set: function(t) {
            this._width = t
        }
    }), Object.defineProperty(e.TilingSprite.prototype, "height", {
        get: function() {
            return this._height
        },
        set: function(t) {
            this._height = t
        }
    }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = e), exports.PIXI = e) : "undefined" != typeof define && define.amd ? define("PIXI", t.PIXI = e) : t.PIXI = e, e
}.call(this),
    function() {
        var t, e = this,
            i = i || {
                VERSION: "2.6.2",
                GAMES: [],
                AUTO: 0,
                CANVAS: 1,
                WEBGL: 2,
                HEADLESS: 3,
                NONE: 0,
                LEFT: 1,
                RIGHT: 2,
                UP: 3,
                DOWN: 4,
                SPRITE: 0,
                BUTTON: 1,
                IMAGE: 2,
                GRAPHICS: 3,
                TEXT: 4,
                TILESPRITE: 5,
                BITMAPTEXT: 6,
                GROUP: 7,
                RENDERTEXTURE: 8,
                TILEMAP: 9,
                TILEMAPLAYER: 10,
                EMITTER: 11,
                POLYGON: 12,
                BITMAPDATA: 13,
                CANVAS_FILTER: 14,
                WEBGL_FILTER: 15,
                ELLIPSE: 16,
                SPRITEBATCH: 17,
                RETROFONT: 18,
                POINTER: 19,
                ROPE: 20,
                CIRCLE: 21,
                RECTANGLE: 22,
                LINE: 23,
                MATRIX: 24,
                POINT: 25,
                ROUNDEDRECTANGLE: 26,
                CREATURE: 27,
                VIDEO: 28,
                PENDING_ATLAS: -1,
                HORIZONTAL: 0,
                VERTICAL: 1,
                LANDSCAPE: 0,
                PORTRAIT: 1,
                ANGLE_UP: 270,
                ANGLE_DOWN: 90,
                ANGLE_LEFT: 180,
                ANGLE_RIGHT: 0,
                ANGLE_NORTH_EAST: 315,
                ANGLE_NORTH_WEST: 225,
                ANGLE_SOUTH_EAST: 45,
                ANGLE_SOUTH_WEST: 135,
                TOP_LEFT: 0,
                TOP_CENTER: 1,
                TOP_RIGHT: 2,
                LEFT_TOP: 3,
                LEFT_CENTER: 4,
                LEFT_BOTTOM: 5,
                CENTER: 6,
                RIGHT_TOP: 7,
                RIGHT_CENTER: 8,
                RIGHT_BOTTOM: 9,
                BOTTOM_LEFT: 10,
                BOTTOM_CENTER: 11,
                BOTTOM_RIGHT: 12,
                blendModes: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16
                },
                scaleModes: {
                    DEFAULT: 0,
                    LINEAR: 0,
                    NEAREST: 1
                },
                PIXI: PIXI || {}
            };
        if (Math.trunc || (Math.trunc = function(t) {
                return t < 0 ? Math.ceil(t) : Math.floor(t)
            }), Function.prototype.bind || (Function.prototype.bind = (t = Array.prototype.slice, function(e) {
                var i = this,
                    n = t.call(arguments, 1);
                if ("function" != typeof i) throw new TypeError;

                function s() {
                    var r = n.concat(t.call(arguments));
                    i.apply(this instanceof s ? this : e, r)
                }
                return s.prototype = function t(e) {
                    if (e && (t.prototype = e), !(this instanceof t)) return new t
                }(i.prototype), s
            })), Array.isArray || (Array.isArray = function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                "use strict";
                if (void 0 === this || null === this) throw new TypeError;
                var e = Object(this),
                    i = e.length >>> 0;
                if ("function" != typeof t) throw new TypeError;
                for (var n = arguments.length >= 2 ? arguments[1] : void 0, s = 0; s < i; s++) s in e && t.call(n, e[s], s, e)
            }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
            var n = function(t) {
                var e = new Array;
                window[t] = function(t) {
                    if ("number" == typeof t) {
                        Array.call(this, t), this.length = t;
                        for (var e = 0; e < this.length; e++) this[e] = 0
                    } else {
                        Array.call(this, t.length), this.length = t.length;
                        for (e = 0; e < this.length; e++) this[e] = t[e]
                    }
                }, window[t].prototype = e, window[t].constructor = window[t]
            };
            n("Uint32Array"), n("Int16Array")
        }

        function s(t, e) {
            this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null
        }
        for (var r in window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), i.Utils = {
                reverseString: function(t) {
                    return t.split("").reverse().join("")
                },
                getProperty: function(t, e) {
                    for (var i = e.split("."), n = i.pop(), s = i.length, r = 1, o = i[0]; r < s && (t = t[o]);) o = i[r], r++;
                    return t ? t[n] : null
                },
                setProperty: function(t, e, i) {
                    for (var n = e.split("."), s = n.pop(), r = n.length, o = 1, a = n[0]; o < r && (t = t[a]);) a = n[o], o++;
                    return t && (t[s] = i), t
                },
                chanceRoll: function(t) {
                    return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t
                },
                randomChoice: function(t, e) {
                    return Math.random() < .5 ? t : e
                },
                parseDimension: function(t, e) {
                    var i = 0,
                        n = 0;
                    return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, n = 0 === e ? window.innerWidth * i : window.innerHeight * i) : n = parseInt(t, 10) : n = t, n
                },
                pad: function(t, e, i, n) {
                    if (void 0 === e) e = 0;
                    if (void 0 === i) i = " ";
                    if (void 0 === n) n = 3;
                    var s = 0;
                    if (e + 1 >= (t = t.toString()).length) switch (n) {
                        case 1:
                            t = new Array(e + 1 - t.length).join(i) + t;
                            break;
                        case 3:
                            var r = Math.ceil((s = e - t.length) / 2);
                            t = new Array(s - r + 1).join(i) + t + new Array(r + 1).join(i);
                            break;
                        default:
                            t += new Array(e + 1 - t.length).join(i)
                    }
                    return t
                },
                isPlainObject: function(t) {
                    if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                    try {
                        if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                    } catch (t) {
                        return !1
                    }
                    return !0
                },
                extend: function() {
                    var t, e, n, s, r, o, a = arguments[0] || {},
                        h = 1,
                        l = arguments.length,
                        c = !1;
                    for ("boolean" == typeof a && (c = a, a = arguments[1] || {}, h = 2), l === h && (a = this, --h); h < l; h++)
                        if (null != (t = arguments[h]))
                            for (e in t) n = a[e], a !== (s = t[e]) && (c && s && (i.Utils.isPlainObject(s) || (r = Array.isArray(s))) ? (r ? (r = !1, o = n && Array.isArray(n) ? n : []) : o = n && i.Utils.isPlainObject(n) ? n : {}, a[e] = i.Utils.extend(c, o, s)) : void 0 !== s && (a[e] = s));
                    return a
                },
                mixinPrototype: function(t, e, i) {
                    void 0 === i && (i = !1);
                    for (var n = Object.keys(e), s = 0; s < n.length; s++) {
                        var r = n[s],
                            o = e[r];
                        !i && r in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[r] = o : "function" == typeof o.clone ? t[r] = o.clone() : Object.defineProperty(t, r, o))
                    }
                },
                mixin: function(t, e) {
                    if (!t || "object" != typeof t) return e;
                    for (var n in t) {
                        var s = t[n];
                        if (!s.childNodes && !s.cloneNode) {
                            var r = typeof t[n];
                            t[n] && "object" === r ? typeof e[n] === r ? e[n] = i.Utils.mixin(t[n], e[n]) : e[n] = i.Utils.mixin(t[n], new s.constructor) : e[n] = t[n]
                        }
                    }
                    return e
                }
            }, i.Circle = function(t, e, n) {
                t = t || 0, e = e || 0, n = n || 0, this.x = t, this.y = e, this._diameter = n, this._radius = 0, n > 0 && (this._radius = .5 * n), this.type = i.CIRCLE
            }, i.Circle.prototype = {
                circumference: function() {
                    return Math.PI * this._radius * 2
                },
                random: function(t) {
                    void 0 === t && (t = new i.Point);
                    var e = 2 * Math.PI * Math.random(),
                        n = Math.random() + Math.random(),
                        s = n > 1 ? 2 - n : n,
                        r = s * Math.cos(e),
                        o = s * Math.sin(e);
                    return t.x = this.x + r * this.radius, t.y = this.y + o * this.radius, t
                },
                getBounds: function() {
                    return new i.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
                },
                setTo: function(t, e, i) {
                    return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
                },
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y, t.diameter)
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
                },
                distance: function(t, e) {
                    var n = i.Math.distance(this.x, this.y, t.x, t.y);
                    return e ? Math.round(n) : n
                },
                clone: function(t) {
                    return void 0 === t || null === t ? t = new i.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
                },
                contains: function(t, e) {
                    return i.Circle.contains(this, t, e)
                },
                circumferencePoint: function(t, e, n) {
                    return i.Circle.circumferencePoint(this, t, e, n)
                },
                offset: function(t, e) {
                    return this.x += t, this.y += e, this
                },
                offsetPoint: function(t) {
                    return this.offset(t.x, t.y)
                },
                toString: function() {
                    return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
                }
            }, i.Circle.prototype.constructor = i.Circle, Object.defineProperty(i.Circle.prototype, "diameter", {
                get: function() {
                    return this._diameter
                },
                set: function(t) {
                    t > 0 && (this._diameter = t, this._radius = .5 * t)
                }
            }), Object.defineProperty(i.Circle.prototype, "radius", {
                get: function() {
                    return this._radius
                },
                set: function(t) {
                    t > 0 && (this._radius = t, this._diameter = 2 * t)
                }
            }), Object.defineProperty(i.Circle.prototype, "left", {
                get: function() {
                    return this.x - this._radius
                },
                set: function(t) {
                    t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
                }
            }), Object.defineProperty(i.Circle.prototype, "right", {
                get: function() {
                    return this.x + this._radius
                },
                set: function(t) {
                    t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
                }
            }), Object.defineProperty(i.Circle.prototype, "top", {
                get: function() {
                    return this.y - this._radius
                },
                set: function(t) {
                    t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
                }
            }), Object.defineProperty(i.Circle.prototype, "bottom", {
                get: function() {
                    return this.y + this._radius
                },
                set: function(t) {
                    t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
                }
            }), Object.defineProperty(i.Circle.prototype, "area", {
                get: function() {
                    return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
                }
            }), Object.defineProperty(i.Circle.prototype, "empty", {
                get: function() {
                    return 0 === this._diameter
                },
                set: function(t) {
                    !0 === t && this.setTo(0, 0, 0)
                }
            }), i.Circle.contains = function(t, e, i) {
                return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
            }, i.Circle.equals = function(t, e) {
                return t.x === e.x && t.y === e.y && t.diameter === e.diameter
            }, i.Circle.intersects = function(t, e) {
                return i.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
            }, i.Circle.circumferencePoint = function(t, e, n, s) {
                return void 0 === n && (n = !1), void 0 === s && (s = new i.Point), !0 === n && (e = i.Math.degToRad(e)), s.x = t.x + t.radius * Math.cos(e), s.y = t.y + t.radius * Math.sin(e), s
            }, i.Circle.intersectsRectangle = function(t, e) {
                var i = Math.abs(t.x - e.x - e.halfWidth);
                if (i > e.halfWidth + t.radius) return !1;
                var n = Math.abs(t.y - e.y - e.halfHeight);
                if (n > e.halfHeight + t.radius) return !1;
                if (i <= e.halfWidth || n <= e.halfHeight) return !0;
                var s = i - e.halfWidth,
                    r = n - e.halfHeight;
                return s * s + r * r <= t.radius * t.radius
            }, PIXI.Circle = i.Circle, i.Ellipse = function(t, e, n, s) {
                t = t || 0, e = e || 0, n = n || 0, s = s || 0, this.x = t, this.y = e, this.width = n, this.height = s, this.type = i.ELLIPSE
            }, i.Ellipse.prototype = {
                setTo: function(t, e, i, n) {
                    return this.x = t, this.y = e, this.width = i, this.height = n, this
                },
                getBounds: function() {
                    return new i.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                },
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y, t.width, t.height)
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                },
                clone: function(t) {
                    return void 0 === t || null === t ? t = new i.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                },
                contains: function(t, e) {
                    return i.Ellipse.contains(this, t, e)
                },
                random: function(t) {
                    void 0 === t && (t = new i.Point);
                    var e = Math.random() * Math.PI * 2,
                        n = Math.random();
                    return t.x = Math.sqrt(n) * Math.cos(e), t.y = Math.sqrt(n) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
                },
                toString: function() {
                    return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
                }
            }, i.Ellipse.prototype.constructor = i.Ellipse, Object.defineProperty(i.Ellipse.prototype, "left", {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    this.x = t
                }
            }), Object.defineProperty(i.Ellipse.prototype, "right", {
                get: function() {
                    return this.x + this.width
                },
                set: function(t) {
                    t < this.x ? this.width = 0 : this.width = t - this.x
                }
            }), Object.defineProperty(i.Ellipse.prototype, "top", {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    this.y = t
                }
            }), Object.defineProperty(i.Ellipse.prototype, "bottom", {
                get: function() {
                    return this.y + this.height
                },
                set: function(t) {
                    t < this.y ? this.height = 0 : this.height = t - this.y
                }
            }), Object.defineProperty(i.Ellipse.prototype, "empty", {
                get: function() {
                    return 0 === this.width || 0 === this.height
                },
                set: function(t) {
                    !0 === t && this.setTo(0, 0, 0, 0)
                }
            }), i.Ellipse.contains = function(t, e, i) {
                if (t.width <= 0 || t.height <= 0) return !1;
                var n = (e - t.x) / t.width - .5,
                    s = (i - t.y) / t.height - .5;
                return (n *= n) + (s *= s) < .25
            }, PIXI.Ellipse = i.Ellipse, i.Line = function(t, e, n, s) {
                t = t || 0, e = e || 0, n = n || 0, s = s || 0, this.start = new i.Point(t, e), this.end = new i.Point(n, s), this.type = i.LINE
            }, i.Line.prototype = {
                setTo: function(t, e, i, n) {
                    return this.start.setTo(t, e), this.end.setTo(i, n), this
                },
                fromSprite: function(t, e, i) {
                    return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y)
                },
                fromAngle: function(t, e, i, n) {
                    return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * n, e + Math.sin(i) * n), this
                },
                rotate: function(t, e) {
                    var i = (this.start.x + this.end.x) / 2,
                        n = (this.start.y + this.end.y) / 2;
                    return this.start.rotate(i, n, t, e), this.end.rotate(i, n, t, e), this
                },
                rotateAround: function(t, e, i, n) {
                    return this.start.rotate(t, e, i, n), this.end.rotate(t, e, i, n), this
                },
                intersects: function(t, e, n) {
                    return i.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, n)
                },
                reflect: function(t) {
                    return i.Line.reflect(this, t)
                },
                midPoint: function(t) {
                    return void 0 === t && (t = new i.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
                },
                centerOn: function(t, e) {
                    var i = t - (this.start.x + this.end.x) / 2,
                        n = e - (this.start.y + this.end.y) / 2;
                    this.start.add(i, n), this.end.add(i, n)
                },
                pointOnLine: function(t, e) {
                    return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y)
                },
                pointOnSegment: function(t, e) {
                    var i = Math.min(this.start.x, this.end.x),
                        n = Math.max(this.start.x, this.end.x),
                        s = Math.min(this.start.y, this.end.y),
                        r = Math.max(this.start.y, this.end.y);
                    return this.pointOnLine(t, e) && t >= i && t <= n && e >= s && e <= r
                },
                random: function(t) {
                    void 0 === t && (t = new i.Point);
                    var e = Math.random();
                    return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
                },
                coordinatesOnLine: function(t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = []);
                    var i = Math.round(this.start.x),
                        n = Math.round(this.start.y),
                        s = Math.round(this.end.x),
                        r = Math.round(this.end.y),
                        o = Math.abs(s - i),
                        a = Math.abs(r - n),
                        h = i < s ? 1 : -1,
                        l = n < r ? 1 : -1,
                        c = o - a;
                    e.push([i, n]);
                    for (var u = 1; i !== s || n !== r;) {
                        var d = c << 1;
                        d > -a && (c -= a, i += h), d < o && (c += o, n += l), u % t == 0 && e.push([i, n]), u++
                    }
                    return e
                },
                clone: function(t) {
                    return void 0 === t || null === t ? t = new i.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
                }
            }, Object.defineProperty(i.Line.prototype, "length", {
                get: function() {
                    return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
                }
            }), Object.defineProperty(i.Line.prototype, "angle", {
                get: function() {
                    return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
                }
            }), Object.defineProperty(i.Line.prototype, "slope", {
                get: function() {
                    return (this.end.y - this.start.y) / (this.end.x - this.start.x)
                }
            }), Object.defineProperty(i.Line.prototype, "perpSlope", {
                get: function() {
                    return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
                }
            }), Object.defineProperty(i.Line.prototype, "x", {
                get: function() {
                    return Math.min(this.start.x, this.end.x)
                }
            }), Object.defineProperty(i.Line.prototype, "y", {
                get: function() {
                    return Math.min(this.start.y, this.end.y)
                }
            }), Object.defineProperty(i.Line.prototype, "left", {
                get: function() {
                    return Math.min(this.start.x, this.end.x)
                }
            }), Object.defineProperty(i.Line.prototype, "right", {
                get: function() {
                    return Math.max(this.start.x, this.end.x)
                }
            }), Object.defineProperty(i.Line.prototype, "top", {
                get: function() {
                    return Math.min(this.start.y, this.end.y)
                }
            }), Object.defineProperty(i.Line.prototype, "bottom", {
                get: function() {
                    return Math.max(this.start.y, this.end.y)
                }
            }), Object.defineProperty(i.Line.prototype, "width", {
                get: function() {
                    return Math.abs(this.start.x - this.end.x)
                }
            }), Object.defineProperty(i.Line.prototype, "height", {
                get: function() {
                    return Math.abs(this.start.y - this.end.y)
                }
            }), Object.defineProperty(i.Line.prototype, "normalX", {
                get: function() {
                    return Math.cos(this.angle - 1.5707963267948966)
                }
            }), Object.defineProperty(i.Line.prototype, "normalY", {
                get: function() {
                    return Math.sin(this.angle - 1.5707963267948966)
                }
            }), Object.defineProperty(i.Line.prototype, "normalAngle", {
                get: function() {
                    return i.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
                }
            }), i.Line.intersectsPoints = function(t, e, n, s, r, o) {
                void 0 === r && (r = !0), void 0 === o && (o = new i.Point);
                var a = e.y - t.y,
                    h = s.y - n.y,
                    l = t.x - e.x,
                    c = n.x - s.x,
                    u = e.x * t.y - t.x * e.y,
                    d = s.x * n.y - n.x * s.y,
                    p = a * c - h * l;
                if (0 === p) return null;
                if (o.x = (l * d - c * u) / p, o.y = (h * u - a * d) / p, r) {
                    var f = (s.y - n.y) * (e.x - t.x) - (s.x - n.x) * (e.y - t.y),
                        g = ((s.x - n.x) * (t.y - n.y) - (s.y - n.y) * (t.x - n.x)) / f,
                        m = ((e.x - t.x) * (t.y - n.y) - (e.y - t.y) * (t.x - n.x)) / f;
                    return g >= 0 && g <= 1 && m >= 0 && m <= 1 ? o : null
                }
                return o
            }, i.Line.intersects = function(t, e, n, s) {
                return i.Line.intersectsPoints(t.start, t.end, e.start, e.end, n, s)
            }, i.Line.intersectsRectangle = function(t, e) {
                if (!i.Rectangle.intersects(t, e)) return !1;
                var n = t.start.x,
                    s = t.start.y,
                    r = t.end.x,
                    o = t.end.y,
                    a = e.x,
                    h = e.y,
                    l = e.right,
                    c = e.bottom,
                    u = 0;
                if (n >= a && n <= l && s >= h && s <= c || r >= a && r <= l && o >= h && o <= c) return !0;
                if (n < a && r >= a) {
                    if ((u = s + (o - s) * (a - n) / (r - n)) > h && u <= c) return !0
                } else if (n > l && r <= l && (u = s + (o - s) * (l - n) / (r - n)) >= h && u <= c) return !0;
                if (s < h && o >= h) {
                    if ((u = n + (r - n) * (h - s) / (o - s)) >= a && u <= l) return !0
                } else if (s > c && o <= c && (u = n + (r - n) * (c - s) / (o - s)) >= a && u <= l) return !0;
                return !1
            }, i.Line.reflect = function(t, e) {
                return 2 * e.normalAngle - 3.141592653589793 - t.angle
            }, i.Matrix = function(t, e, n, s, r, o) {
                void 0 !== t && null !== t || (t = 1), void 0 !== e && null !== e || (e = 0), void 0 !== n && null !== n || (n = 0), void 0 !== s && null !== s || (s = 1), void 0 !== r && null !== r || (r = 0), void 0 !== o && null !== o || (o = 0), this.a = t, this.b = e, this.c = n, this.d = s, this.tx = r, this.ty = o, this.type = i.MATRIX
            }, i.Matrix.prototype = {
                fromArray: function(t) {
                    return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
                },
                setTo: function(t, e, i, n, s, r) {
                    return this.a = t, this.b = e, this.c = i, this.d = n, this.tx = s, this.ty = r, this
                },
                clone: function(t) {
                    return void 0 === t || null === t ? t = new i.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
                },
                copyTo: function(t) {
                    return t.copyFrom(this), t
                },
                copyFrom: function(t) {
                    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                },
                toArray: function(t, e) {
                    return void 0 === e && (e = new PIXI.Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
                },
                apply: function(t, e) {
                    return void 0 === e && (e = new i.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
                },
                applyInverse: function(t, e) {
                    void 0 === e && (e = new i.Point);
                    var n = 1 / (this.a * this.d + this.c * -this.b),
                        s = t.x,
                        r = t.y;
                    return e.x = this.d * n * s + -this.c * n * r + (this.ty * this.c - this.tx * this.d) * n, e.y = this.a * n * r + -this.b * n * s + (-this.ty * this.a + this.tx * this.b) * n, e
                },
                translate: function(t, e) {
                    return this.tx += t, this.ty += e, this
                },
                scale: function(t, e) {
                    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t),
                        n = this.a,
                        s = this.c,
                        r = this.tx;
                    return this.a = n * e - this.b * i, this.b = n * i + this.b * e, this.c = s * e - this.d * i, this.d = s * i + this.d * e, this.tx = r * e - this.ty * i, this.ty = r * i + this.ty * e, this
                },
                append: function(t) {
                    var e = this.a,
                        i = this.b,
                        n = this.c,
                        s = this.d;
                    return this.a = t.a * e + t.b * n, this.b = t.a * i + t.b * s, this.c = t.c * e + t.d * n, this.d = t.c * i + t.d * s, this.tx = t.tx * e + t.ty * n + this.tx, this.ty = t.tx * i + t.ty * s + this.ty, this
                },
                identity: function() {
                    return this.setTo(1, 0, 0, 1, 0, 0)
                }
            }, i.identityMatrix = new i.Matrix, PIXI.Matrix = i.Matrix, PIXI.identityMatrix = i.identityMatrix, i.Point = function(t, e) {
                t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = i.POINT
            }, i.Point.prototype = {
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y)
                },
                invert: function() {
                    return this.setTo(this.y, this.x)
                },
                setTo: function(t, e) {
                    return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                },
                set: function(t, e) {
                    return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                },
                add: function(t, e) {
                    return this.x += t, this.y += e, this
                },
                subtract: function(t, e) {
                    return this.x -= t, this.y -= e, this
                },
                multiply: function(t, e) {
                    return this.x *= t, this.y *= e, this
                },
                divide: function(t, e) {
                    return this.x /= t, this.y /= e, this
                },
                clampX: function(t, e) {
                    return this.x = i.Math.clamp(this.x, t, e), this
                },
                clampY: function(t, e) {
                    return this.y = i.Math.clamp(this.y, t, e), this
                },
                clamp: function(t, e) {
                    return this.x = i.Math.clamp(this.x, t, e), this.y = i.Math.clamp(this.y, t, e), this
                },
                clone: function(t) {
                    return void 0 === t || null === t ? t = new i.Point(this.x, this.y) : t.setTo(this.x, this.y), t
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t
                },
                distance: function(t, e) {
                    return i.Point.distance(this, t, e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                angle: function(t, e) {
                    return void 0 === e && (e = !1), e ? i.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
                },
                rotate: function(t, e, n, s, r) {
                    return i.Point.rotate(this, t, e, n, s, r)
                },
                getMagnitude: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                getMagnitudeSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                setMagnitude: function(t) {
                    return this.normalize().multiply(t, t)
                },
                normalize: function() {
                    if (!this.isZero()) {
                        var t = this.getMagnitude();
                        this.x /= t, this.y /= t
                    }
                    return this
                },
                isZero: function() {
                    return 0 === this.x && 0 === this.y
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                cross: function(t) {
                    return this.x * t.y - this.y * t.x
                },
                perp: function() {
                    return this.setTo(-this.y, this.x)
                },
                rperp: function() {
                    return this.setTo(this.y, -this.x)
                },
                normalRightHand: function() {
                    return this.setTo(-1 * this.y, this.x)
                },
                floor: function() {
                    return this.setTo(Math.floor(this.x), Math.floor(this.y))
                },
                ceil: function() {
                    return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
                },
                toString: function() {
                    return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
                }
            }, i.Point.prototype.constructor = i.Point, i.Point.add = function(t, e, n) {
                return void 0 === n && (n = new i.Point), n.x = t.x + e.x, n.y = t.y + e.y, n
            }, i.Point.subtract = function(t, e, n) {
                return void 0 === n && (n = new i.Point), n.x = t.x - e.x, n.y = t.y - e.y, n
            }, i.Point.multiply = function(t, e, n) {
                return void 0 === n && (n = new i.Point), n.x = t.x * e.x, n.y = t.y * e.y, n
            }, i.Point.divide = function(t, e, n) {
                return void 0 === n && (n = new i.Point), n.x = t.x / e.x, n.y = t.y / e.y, n
            }, i.Point.equals = function(t, e) {
                return t.x === e.x && t.y === e.y
            }, i.Point.angle = function(t, e) {
                return Math.atan2(t.y - e.y, t.x - e.x)
            }, i.Point.negative = function(t, e) {
                return void 0 === e && (e = new i.Point), e.setTo(-t.x, -t.y)
            }, i.Point.multiplyAdd = function(t, e, n, s) {
                return void 0 === s && (s = new i.Point), s.setTo(t.x + e.x * n, t.y + e.y * n)
            }, i.Point.interpolate = function(t, e, n, s) {
                return void 0 === s && (s = new i.Point), s.setTo(t.x + (e.x - t.x) * n, t.y + (e.y - t.y) * n)
            }, i.Point.perp = function(t, e) {
                return void 0 === e && (e = new i.Point), e.setTo(-t.y, t.x)
            }, i.Point.rperp = function(t, e) {
                return void 0 === e && (e = new i.Point), e.setTo(t.y, -t.x)
            }, i.Point.distance = function(t, e, n) {
                var s = i.Math.distance(t.x, t.y, e.x, e.y);
                return n ? Math.round(s) : s
            }, i.Point.project = function(t, e, n) {
                void 0 === n && (n = new i.Point);
                var s = t.dot(e) / e.getMagnitudeSq();
                return 0 !== s && n.setTo(s * e.x, s * e.y), n
            }, i.Point.projectUnit = function(t, e, n) {
                void 0 === n && (n = new i.Point);
                var s = t.dot(e);
                return 0 !== s && n.setTo(s * e.x, s * e.y), n
            }, i.Point.normalRightHand = function(t, e) {
                return void 0 === e && (e = new i.Point), e.setTo(-1 * t.y, t.x)
            }, i.Point.normalize = function(t, e) {
                void 0 === e && (e = new i.Point);
                var n = t.getMagnitude();
                return 0 !== n && e.setTo(t.x / n, t.y / n), e
            }, i.Point.rotate = function(t, e, n, s, r, o) {
                if (r && (s = i.Math.degToRad(s)), void 0 === o) {
                    t.subtract(e, n);
                    var a = Math.sin(s),
                        h = Math.cos(s),
                        l = h * t.x - a * t.y,
                        c = a * t.x + h * t.y;
                    t.x = l + e, t.y = c + n
                } else {
                    var u = s + Math.atan2(t.y - n, t.x - e);
                    t.x = e + o * Math.cos(u), t.y = n + o * Math.sin(u)
                }
                return t
            }, i.Point.centroid = function(t, e) {
                if (void 0 === e && (e = new i.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                var n = t.length;
                if (n < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                if (1 === n) return e.copyFrom(t[0]), e;
                for (var s = 0; s < n; s++) i.Point.add(e, t[s], e);
                return e.divide(n, n), e
            }, i.Point.parse = function(t, e, n) {
                e = e || "x", n = n || "y";
                var s = new i.Point;
                return t[e] && (s.x = parseInt(t[e], 10)), t[n] && (s.y = parseInt(t[n], 10)), s
            }, PIXI.Point = i.Point, i.Polygon = function() {
                this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = i.POLYGON
            }, i.Polygon.prototype = {
                toNumberArray: function(t) {
                    void 0 === t && (t = []);
                    for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                    return t
                },
                flatten: function() {
                    return this._points = this.toNumberArray(), this.flattened = !0, this
                },
                clone: function(t) {
                    var e = this._points.slice();
                    return void 0 === t || null === t ? t = new i.Polygon(e) : t.setTo(e), t
                },
                contains: function(t, e) {
                    var i = !1;
                    if (this.flattened)
                        for (var n = -2, s = this._points.length - 2;
                            (n += 2) < this._points.length; s = n) {
                            var r = this._points[n],
                                o = this._points[n + 1],
                                a = this._points[s],
                                h = this._points[s + 1];
                            (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                        } else
                            for (n = -1, s = this._points.length - 1; ++n < this._points.length; s = n) {
                                r = this._points[n].x, o = this._points[n].y, a = this._points[s].x, h = this._points[s].y;
                                (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                            }
                    return i
                },
                setTo: function(t) {
                    if (this.area = 0, this._points = [], arguments.length > 0) {
                        Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                        for (var e = Number.MAX_VALUE, i = 0, n = t.length; i < n; i++) {
                            if ("number" == typeof t[i]) {
                                var s = new PIXI.Point(t[i], t[i + 1]);
                                i++
                            } else if (Array.isArray(t[i])) s = new PIXI.Point(t[i][0], t[i][1]);
                            else s = new PIXI.Point(t[i].x, t[i].y);
                            this._points.push(s), s.y < e && (e = s.y)
                        }
                        this.calculateArea(e)
                    }
                    return this
                },
                calculateArea: function(t) {
                    for (var e, i, n, s, r = 0, o = this._points.length; r < o; r++) e = this._points[r], i = r === o - 1 ? this._points[0] : this._points[r + 1], n = (e.y - t + (i.y - t)) / 2, s = e.x - i.x, this.area += n * s;
                    return this.area
                }
            }, i.Polygon.prototype.constructor = i.Polygon, Object.defineProperty(i.Polygon.prototype, "points", {
                get: function() {
                    return this._points
                },
                set: function(t) {
                    null != t ? this.setTo(t) : this.setTo()
                }
            }), PIXI.Polygon = i.Polygon, i.Rectangle = function(t, e, n, s) {
                t = t || 0, e = e || 0, n = n || 0, s = s || 0, this.x = t, this.y = e, this.width = n, this.height = s, this.type = i.RECTANGLE
            }, i.Rectangle.prototype = {
                offset: function(t, e) {
                    return this.x += t, this.y += e, this
                },
                offsetPoint: function(t) {
                    return this.offset(t.x, t.y)
                },
                setTo: function(t, e, i, n) {
                    return this.x = t, this.y = e, this.width = i, this.height = n, this
                },
                scale: function(t, e) {
                    return void 0 === e && (e = t), this.width *= t, this.height *= e, this
                },
                centerOn: function(t, e) {
                    return this.centerX = t, this.centerY = e, this
                },
                floor: function() {
                    this.x = Math.floor(this.x), this.y = Math.floor(this.y)
                },
                floorAll: function() {
                    this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
                },
                ceil: function() {
                    this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
                },
                ceilAll: function() {
                    this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
                },
                copyFrom: function(t) {
                    return this.setTo(t.x, t.y, t.width, t.height)
                },
                copyTo: function(t) {
                    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                },
                inflate: function(t, e) {
                    return i.Rectangle.inflate(this, t, e)
                },
                size: function(t) {
                    return i.Rectangle.size(this, t)
                },
                resize: function(t, e) {
                    return this.width = t, this.height = e, this
                },
                clone: function(t) {
                    return i.Rectangle.clone(this, t)
                },
                contains: function(t, e) {
                    return i.Rectangle.contains(this, t, e)
                },
                containsRect: function(t) {
                    return i.Rectangle.containsRect(t, this)
                },
                equals: function(t) {
                    return i.Rectangle.equals(this, t)
                },
                intersection: function(t, e) {
                    return i.Rectangle.intersection(this, t, e)
                },
                intersects: function(t) {
                    return i.Rectangle.intersects(this, t)
                },
                intersectsRaw: function(t, e, n, s, r) {
                    return i.Rectangle.intersectsRaw(this, t, e, n, s, r)
                },
                union: function(t, e) {
                    return i.Rectangle.union(this, t, e)
                },
                random: function(t) {
                    return void 0 === t && (t = new i.Point), t.x = this.randomX, t.y = this.randomY, t
                },
                getPoint: function(t, e) {
                    switch (void 0 === e && (e = new i.Point), t) {
                        default:
                            case i.TOP_LEFT:
                            return e.set(this.x, this.y);
                        case i.TOP_CENTER:
                                return e.set(this.centerX, this.y);
                        case i.TOP_RIGHT:
                                return e.set(this.right, this.y);
                        case i.LEFT_CENTER:
                                return e.set(this.x, this.centerY);
                        case i.CENTER:
                                return e.set(this.centerX, this.centerY);
                        case i.RIGHT_CENTER:
                                return e.set(this.right, this.centerY);
                        case i.BOTTOM_LEFT:
                                return e.set(this.x, this.bottom);
                        case i.BOTTOM_CENTER:
                                return e.set(this.centerX, this.bottom);
                        case i.BOTTOM_RIGHT:
                                return e.set(this.right, this.bottom)
                    }
                },
                toString: function() {
                    return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
                }
            }, Object.defineProperty(i.Rectangle.prototype, "halfWidth", {
                get: function() {
                    return Math.round(this.width / 2)
                }
            }), Object.defineProperty(i.Rectangle.prototype, "halfHeight", {
                get: function() {
                    return Math.round(this.height / 2)
                }
            }), Object.defineProperty(i.Rectangle.prototype, "bottom", {
                get: function() {
                    return this.y + this.height
                },
                set: function(t) {
                    t <= this.y ? this.height = 0 : this.height = t - this.y
                }
            }), Object.defineProperty(i.Rectangle.prototype, "bottomLeft", {
                get: function() {
                    return new i.Point(this.x, this.bottom)
                },
                set: function(t) {
                    this.x = t.x, this.bottom = t.y
                }
            }), Object.defineProperty(i.Rectangle.prototype, "bottomRight", {
                get: function() {
                    return new i.Point(this.right, this.bottom)
                },
                set: function(t) {
                    this.right = t.x, this.bottom = t.y
                }
            }), Object.defineProperty(i.Rectangle.prototype, "left", {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
                }
            }), Object.defineProperty(i.Rectangle.prototype, "right", {
                get: function() {
                    return this.x + this.width
                },
                set: function(t) {
                    t <= this.x ? this.width = 0 : this.width = t - this.x
                }
            }), Object.defineProperty(i.Rectangle.prototype, "volume", {
                get: function() {
                    return this.width * this.height
                }
            }), Object.defineProperty(i.Rectangle.prototype, "perimeter", {
                get: function() {
                    return 2 * this.width + 2 * this.height
                }
            }), Object.defineProperty(i.Rectangle.prototype, "centerX", {
                get: function() {
                    return this.x + this.halfWidth
                },
                set: function(t) {
                    this.x = t - this.halfWidth
                }
            }), Object.defineProperty(i.Rectangle.prototype, "centerY", {
                get: function() {
                    return this.y + this.halfHeight
                },
                set: function(t) {
                    this.y = t - this.halfHeight
                }
            }), Object.defineProperty(i.Rectangle.prototype, "randomX", {
                get: function() {
                    return this.x + Math.random() * this.width
                }
            }), Object.defineProperty(i.Rectangle.prototype, "randomY", {
                get: function() {
                    return this.y + Math.random() * this.height
                }
            }), Object.defineProperty(i.Rectangle.prototype, "top", {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
                }
            }), Object.defineProperty(i.Rectangle.prototype, "topLeft", {
                get: function() {
                    return new i.Point(this.x, this.y)
                },
                set: function(t) {
                    this.x = t.x, this.y = t.y
                }
            }), Object.defineProperty(i.Rectangle.prototype, "topRight", {
                get: function() {
                    return new i.Point(this.x + this.width, this.y)
                },
                set: function(t) {
                    this.right = t.x, this.y = t.y
                }
            }), Object.defineProperty(i.Rectangle.prototype, "empty", {
                get: function() {
                    return !this.width || !this.height
                },
                set: function(t) {
                    !0 === t && this.setTo(0, 0, 0, 0)
                }
            }), i.Rectangle.prototype.constructor = i.Rectangle, i.Rectangle.inflate = function(t, e, i) {
                return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
            }, i.Rectangle.inflatePoint = function(t, e) {
                return i.Rectangle.inflate(t, e.x, e.y)
            }, i.Rectangle.size = function(t, e) {
                return void 0 === e || null === e ? e = new i.Point(t.width, t.height) : e.setTo(t.width, t.height), e
            }, i.Rectangle.clone = function(t, e) {
                return void 0 === e || null === e ? e = new i.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
            }, i.Rectangle.contains = function(t, e, i) {
                return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
            }, i.Rectangle.containsRaw = function(t, e, i, n, s, r) {
                return s >= t && s < t + i && r >= e && r < e + n
            }, i.Rectangle.containsPoint = function(t, e) {
                return i.Rectangle.contains(t, e.x, e.y)
            }, i.Rectangle.containsRect = function(t, e) {
                return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
            }, i.Rectangle.equals = function(t, e) {
                return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
            }, i.Rectangle.sameDimensions = function(t, e) {
                return t.width === e.width && t.height === e.height
            }, i.Rectangle.intersection = function(t, e, n) {
                return void 0 === n && (n = new i.Rectangle), i.Rectangle.intersects(t, e) && (n.x = Math.max(t.x, e.x), n.y = Math.max(t.y, e.y), n.width = Math.min(t.right, e.right) - n.x, n.height = Math.min(t.bottom, e.bottom) - n.y), n
            }, i.Rectangle.intersects = function(t, e) {
                return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
            }, i.Rectangle.intersectsRaw = function(t, e, i, n, s, r) {
                return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || n > t.bottom + r || s < t.top - r)
            }, i.Rectangle.union = function(t, e, n) {
                return void 0 === n && (n = new i.Rectangle), n.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
            }, i.Rectangle.aabb = function(t, e) {
                void 0 === e && (e = new i.Rectangle);
                var n = Number.NEGATIVE_INFINITY,
                    s = Number.POSITIVE_INFINITY,
                    r = Number.NEGATIVE_INFINITY,
                    o = Number.POSITIVE_INFINITY;
                return t.forEach(function(t) {
                    t.x > n && (n = t.x), t.x < s && (s = t.x), t.y > r && (r = t.y), t.y < o && (o = t.y)
                }), e.setTo(s, o, n - s, r - o), e
            }, PIXI.Rectangle = i.Rectangle, PIXI.EmptyRectangle = new i.Rectangle(0, 0, 0, 0), i.RoundedRectangle = function(t, e, n, s, r) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 20), this.x = t, this.y = e, this.width = n, this.height = s, this.radius = r || 20, this.type = i.ROUNDEDRECTANGLE
            }, i.RoundedRectangle.prototype = {
                clone: function() {
                    return new i.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
                },
                contains: function(t, e) {
                    if (this.width <= 0 || this.height <= 0) return !1;
                    var i = this.x;
                    if (t >= i && t <= i + this.width) {
                        var n = this.y;
                        if (e >= n && e <= n + this.height) return !0
                    }
                    return !1
                }
            }, i.RoundedRectangle.prototype.constructor = i.RoundedRectangle, PIXI.RoundedRectangle = i.RoundedRectangle, i.Camera = function(t, e, n, s, r, o) {
                this.game = t, this.world = t.world, this.id = 0, this.view = new i.Rectangle(n, s, r, o), this.bounds = new i.Rectangle(n, s, r, o), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                    x: !1,
                    y: !1
                }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new i.Point(1, 1), this.onShakeComplete = new i.Signal, this.onFlashComplete = new i.Signal, this.onFadeComplete = new i.Signal, this.fx = null, this._targetPosition = new i.Point, this._edge = 0, this._position = new i.Point, this._shake = {
                    intensity: 0,
                    duration: 0,
                    horizontal: !1,
                    vertical: !1,
                    shakeBounds: !0,
                    x: 0,
                    y: 0
                }, this._fxDuration = 0, this._fxType = 0
            }, i.Camera.FOLLOW_LOCKON = 0, i.Camera.FOLLOW_PLATFORMER = 1, i.Camera.FOLLOW_TOPDOWN = 2, i.Camera.FOLLOW_TOPDOWN_TIGHT = 3, i.Camera.SHAKE_BOTH = 4, i.Camera.SHAKE_HORIZONTAL = 5, i.Camera.SHAKE_VERTICAL = 6, i.Camera.ENABLE_FX = !0, i.Camera.prototype = {
                boot: function() {
                    this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, i.Graphics && i.Camera.ENABLE_FX && (this.fx = new i.Graphics(this.game), this.game.stage.addChild(this.fx))
                },
                preUpdate: function() {
                    this.totalInView = 0
                },
                follow: function(t, e, n, s) {
                    var r;
                    switch (void 0 === e && (e = i.Camera.FOLLOW_LOCKON), void 0 === n && (n = 1), void 0 === s && (s = 1), this.target = t, this.lerp.set(n, s), e) {
                        case i.Camera.FOLLOW_PLATFORMER:
                            var o = this.width / 8,
                                a = this.height / 3;
                            this.deadzone = new i.Rectangle((this.width - o) / 2, (this.height - a) / 2 - .25 * a, o, a);
                            break;
                        case i.Camera.FOLLOW_TOPDOWN:
                            r = Math.max(this.width, this.height) / 4, this.deadzone = new i.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                            break;
                        case i.Camera.FOLLOW_TOPDOWN_TIGHT:
                            r = Math.max(this.width, this.height) / 8, this.deadzone = new i.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                            break;
                        case i.Camera.FOLLOW_LOCKON:
                        default:
                            this.deadzone = null
                    }
                },
                unfollow: function() {
                    this.target = null
                },
                focusOn: function(t) {
                    this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
                },
                focusOnXY: function(t, e) {
                    this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
                },
                shake: function(t, e, n, s, r) {
                    return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === n && (n = !0), void 0 === s && (s = i.Camera.SHAKE_BOTH), void 0 === r && (r = !0), !(!n && this._shake.duration > 0) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = r, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = s === i.Camera.SHAKE_BOTH || s === i.Camera.SHAKE_HORIZONTAL, this._shake.vertical = s === i.Camera.SHAKE_BOTH || s === i.Camera.SHAKE_VERTICAL, !0)
                },
                flash: function(t, e, i) {
                    return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, !0)
                },
                fade: function(t, e, i) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0)
                },
                update: function() {
                    this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                },
                updateFX: function() {
                    0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
                },
                updateShake: function() {
                    this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
                },
                updateTarget: function() {
                    this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                },
                setBoundsToWorld: function() {
                    this.bounds && this.bounds.copyFrom(this.game.world.bounds)
                },
                checkBounds: function() {
                    this.atLimit.x = !1, this.atLimit.y = !1;
                    var t = this.view.x + this._shake.x,
                        e = this.view.right + this._shake.x,
                        i = this.view.y + this._shake.y,
                        n = this.view.bottom + this._shake.y;
                    t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), n >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
                },
                setPosition: function(t, e) {
                    this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
                },
                setSize: function(t, e) {
                    this.view.width = t, this.view.height = e
                },
                reset: function() {
                    this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX()
                },
                resetFX: function() {
                    this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0
                }
            }, i.Camera.prototype.constructor = i.Camera, Object.defineProperty(i.Camera.prototype, "x", {
                get: function() {
                    return this.view.x
                },
                set: function(t) {
                    this.view.x = t, this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(i.Camera.prototype, "y", {
                get: function() {
                    return this.view.y
                },
                set: function(t) {
                    this.view.y = t, this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(i.Camera.prototype, "position", {
                get: function() {
                    return this._position.set(this.view.x, this.view.y), this._position
                },
                set: function(t) {
                    void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
                }
            }), Object.defineProperty(i.Camera.prototype, "width", {
                get: function() {
                    return this.view.width
                },
                set: function(t) {
                    this.view.width = t
                }
            }), Object.defineProperty(i.Camera.prototype, "height", {
                get: function() {
                    return this.view.height
                },
                set: function(t) {
                    this.view.height = t
                }
            }), Object.defineProperty(i.Camera.prototype, "shakeIntensity", {
                get: function() {
                    return this._shake.intensity
                },
                set: function(t) {
                    this._shake.intensity = t
                }
            }), i.State = function() {
                this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
            }, i.State.prototype = {
                init: function() {},
                preload: function() {},
                loadUpdate: function() {},
                loadRender: function() {},
                create: function() {},
                update: function() {},
                preRender: function() {},
                render: function() {},
                resize: function() {},
                paused: function() {},
                resumed: function() {},
                pauseUpdate: function() {},
                shutdown: function() {}
            }, i.State.prototype.constructor = i.State, i.StateManager = function(t, e) {
                this.game = t, this.states = {}, this._pendingState = null, void 0 !== e && null !== e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new i.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
            }, i.StateManager.prototype = {
                boot: function() {
                    this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
                },
                add: function(t, e, n) {
                    var s;
                    return void 0 === n && (n = !1), e instanceof i.State ? s = e : "object" == typeof e ? (s = e).game = this.game : "function" == typeof e && (s = new e(this.game)), this.states[t] = s, n && (this.game.isBooted ? this.start(t) : this._pendingState = t), s
                },
                remove: function(t) {
                    this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
                },
                start: function(t, e, i) {
                    void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
                },
                restart: function(t, e) {
                    void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
                },
                dummy: function() {},
                preUpdate: function() {
                    if (this._pendingState && this.game.isBooted) {
                        var t = this.current;
                        if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                        this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                    }
                },
                clearCurrentState: function() {
                    this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
                },
                checkState: function(t) {
                    return !!this.states[t] && !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render)
                },
                link: function(t) {
                    this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, this.states[t].state = this, this.states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t
                },
                unlink: function(t) {
                    this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].sound = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null)
                },
                setCurrentState: function(t) {
                    this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
                },
                getCurrentState: function() {
                    return this.states[this.current]
                },
                loadComplete: function() {
                    !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
                },
                pause: function() {
                    this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
                },
                resume: function() {
                    this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
                },
                update: function() {
                    this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                },
                pauseUpdate: function() {
                    this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                },
                preRender: function(t) {
                    this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
                },
                resize: function(t, e) {
                    this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
                },
                render: function() {
                    this._created ? this.onRenderCallback && (this.game.renderType === i.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
                },
                destroy: function() {
                    this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
                }
            }, i.StateManager.prototype.constructor = i.StateManager, Object.defineProperty(i.StateManager.prototype, "created", {
                get: function() {
                    return this._created
                }
            }), i.Signal = function() {}, i.Signal.prototype = {
                _bindings: null,
                _prevParams: null,
                memorize: !1,
                _shouldPropagate: !0,
                active: !0,
                _boundDispatch: !1,
                validateListener: function(t, e) {
                    if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
                },
                _registerListener: function(t, e, n, s, r) {
                    var o, a = this._indexOfListener(t, n);
                    if (-1 !== a) {
                        if ((o = this._bindings[a]).isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                    } else o = new i.SignalBinding(this, t, e, n, s, r), this._addBinding(o);
                    return this.memorize && this._prevParams && o.execute(this._prevParams), o
                },
                _addBinding: function(t) {
                    this._bindings || (this._bindings = []);
                    var e = this._bindings.length;
                    do {
                        e--
                    } while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                    this._bindings.splice(e + 1, 0, t)
                },
                _indexOfListener: function(t, e) {
                    if (!this._bindings) return -1;
                    void 0 === e && (e = null);
                    for (var i, n = this._bindings.length; n--;)
                        if ((i = this._bindings[n])._listener === t && i.context === e) return n;
                    return -1
                },
                has: function(t, e) {
                    return -1 !== this._indexOfListener(t, e)
                },
                add: function(t, e, i) {
                    this.validateListener(t, "add");
                    var n = [];
                    if (arguments.length > 3)
                        for (var s = 3; s < arguments.length; s++) n.push(arguments[s]);
                    return this._registerListener(t, !1, e, i, n)
                },
                addOnce: function(t, e, i) {
                    this.validateListener(t, "addOnce");
                    var n = [];
                    if (arguments.length > 3)
                        for (var s = 3; s < arguments.length; s++) n.push(arguments[s]);
                    return this._registerListener(t, !0, e, i, n)
                },
                remove: function(t, e) {
                    this.validateListener(t, "remove");
                    var i = this._indexOfListener(t, e);
                    return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
                },
                removeAll: function(t) {
                    if (void 0 === t && (t = null), this._bindings) {
                        for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                        t || (this._bindings.length = 0)
                    }
                },
                getNumListeners: function() {
                    return this._bindings ? this._bindings.length : 0
                },
                halt: function() {
                    this._shouldPropagate = !1
                },
                dispatch: function() {
                    if (this.active && this._bindings) {
                        var t, e = Array.prototype.slice.call(arguments),
                            i = this._bindings.length;
                        if (this.memorize && (this._prevParams = e), i) {
                            t = this._bindings.slice(), this._shouldPropagate = !0;
                            do {
                                i--
                            } while (t[i] && this._shouldPropagate && !1 !== t[i].execute(e))
                        }
                    }
                },
                forget: function() {
                    this._prevParams && (this._prevParams = null)
                },
                dispose: function() {
                    this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
                },
                toString: function() {
                    return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                }
            }, Object.defineProperty(i.Signal.prototype, "boundDispatch", {
                get: function() {
                    var t = this;
                    return this._boundDispatch || (this._boundDispatch = function() {
                        return t.dispatch.apply(t, arguments)
                    })
                }
            }), i.Signal.prototype.constructor = i.Signal, i.SignalBinding = function(t, e, i, n, s, r) {
                this._listener = e, i && (this._isOnce = !0), null != n && (this.context = n), this._signal = t, s && (this._priority = s), r && r.length && (this._args = r)
            }, i.SignalBinding.prototype = {
                context: null,
                _isOnce: !1,
                _priority: 0,
                _args: null,
                callCount: 0,
                active: !0,
                params: null,
                execute: function(t) {
                    var e, i;
                    return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
                },
                detach: function() {
                    return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                },
                isBound: function() {
                    return !!this._signal && !!this._listener
                },
                isOnce: function() {
                    return this._isOnce
                },
                getListener: function() {
                    return this._listener
                },
                getSignal: function() {
                    return this._signal
                },
                _destroy: function() {
                    delete this._signal, delete this._listener, delete this.context
                },
                toString: function() {
                    return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                }
            }, i.SignalBinding.prototype.constructor = i.SignalBinding, i.Filter = function(t, e, n) {
                this.game = t, this.type = i.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new i.Point;
                var s = new Date;
                if (this.uniforms = {
                        resolution: {
                            type: "2f",
                            value: {
                                x: 256,
                                y: 256
                            }
                        },
                        time: {
                            type: "1f",
                            value: 0
                        },
                        mouse: {
                            type: "2f",
                            value: {
                                x: 0,
                                y: 0
                            }
                        },
                        date: {
                            type: "4fv",
                            value: [s.getFullYear(), s.getMonth(), s.getDate(), 60 * s.getHours() * 60 + 60 * s.getMinutes() + s.getSeconds()]
                        },
                        sampleRate: {
                            type: "1f",
                            value: 44100
                        },
                        iChannel0: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel1: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel2: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        },
                        iChannel3: {
                            type: "sampler2D",
                            value: null,
                            textureData: {
                                repeat: !0
                            }
                        }
                    }, e)
                    for (var r in e) this.uniforms[r] = e[r];
                this.fragmentSrc = n || ""
            }, i.Filter.prototype = {
                init: function() {},
                setResolution: function(t, e) {
                    this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
                },
                update: function(t) {
                    if (void 0 !== t) {
                        var e = t.x / this.game.width,
                            i = 1 - t.y / this.game.height;
                        e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                    }
                    this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                },
                addToWorld: function(t, e, i, n, s, r) {
                    void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 !== i && null !== i ? this.width = i : i = this.width, void 0 !== n && null !== n ? this.height = n : n = this.height;
                    var o = this.game.add.image(t, e, "__default");
                    return o.width = i, o.height = n, o.anchor.set(s, r), o.filters = [this], o
                },
                destroy: function() {
                    this.game = null
                }
            }, i.Filter.prototype.constructor = i.Filter, Object.defineProperty(i.Filter.prototype, "width", {
                get: function() {
                    return this.uniforms.resolution.value.x
                },
                set: function(t) {
                    this.uniforms.resolution.value.x = t
                }
            }), Object.defineProperty(i.Filter.prototype, "height", {
                get: function() {
                    return this.uniforms.resolution.value.y
                },
                set: function(t) {
                    this.uniforms.resolution.value.y = t
                }
            }), i.Plugin = function(t, e) {
                void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
            }, i.Plugin.prototype = {
                preUpdate: function() {},
                update: function() {},
                render: function() {},
                postRender: function() {},
                destroy: function() {
                    this.game = null, this.parent = null, this.active = !1, this.visible = !1
                }
            }, i.Plugin.prototype.constructor = i.Plugin, i.PluginManager = function(t) {
                this.game = t, this.plugins = [], this._len = 0, this._i = 0
            }, i.PluginManager.prototype = {
                add: function(t) {
                    var e = Array.prototype.slice.call(arguments, 1),
                        i = !1;
                    return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
                },
                remove: function(t, e) {
                    for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                        if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
                },
                removeAll: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                    this.plugins.length = 0, this._len = 0
                },
                preUpdate: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
                },
                update: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
                },
                postUpdate: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
                },
                render: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
                },
                postRender: function() {
                    for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
                },
                destroy: function() {
                    this.removeAll(), this.game = null
                }
            }, i.PluginManager.prototype.constructor = i.PluginManager, i.Stage = function(t) {
                this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                    color: 0,
                    rgba: "#000000"
                }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
            }, i.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Stage.prototype.constructor = i.Stage, i.Stage.prototype.parseConfig = function(t) {
                t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
            }, i.Stage.prototype.boot = function() {
                i.DOM.getOffset(this.game.canvas, this.offset), i.Canvas.setUserSelect(this.game.canvas, "none"), i.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
            }, i.Stage.prototype.preUpdate = function() {
                this.currentRenderOrderID = 0;
                for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate()
            }, i.Stage.prototype.update = function() {
                for (var t = this.children.length; t--;) this.children[t].update()
            }, i.Stage.prototype.postUpdate = function() {
                this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
                this.updateTransform()
            }, i.Stage.prototype.updateTransform = function() {
                this.worldAlpha = 1;
                for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
            }, i.Stage.prototype.checkVisibility = function() {
                void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
                var t = this;
                this._onChange = function(e) {
                    return t.visibilityChange(e)
                }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                    i.Stage.prototype.visibilityChange.call(t, {
                        type: "pause"
                    })
                }), CocoonJS.App.onActivated.addEventListener(function() {
                    i.Stage.prototype.visibilityChange.call(t, {
                        type: "resume"
                    })
                }))
            }, i.Stage.prototype.visibilityChange = function(t) {
                "pagehide" !== t.type && "blur" !== t.type && "pageshow" !== t.type && "focus" !== t.type ? this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t)) : "pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t)
            }, i.Stage.prototype.setBackgroundColor = function(t) {
                this.game.transparent || (i.Color.valueToColor(t, this._bgColor), i.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
            }, i.Stage.prototype.destroy = function() {
                this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null
            }, Object.defineProperty(i.Stage.prototype, "backgroundColor", {
                get: function() {
                    return this._bgColor.color
                },
                set: function(t) {
                    this.setBackgroundColor(t)
                }
            }), Object.defineProperty(i.Stage.prototype, "smoothed", {
                get: function() {
                    return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
                },
                set: function(t) {
                    PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
                }
            }), i.Group = function(t, e, n, s, r, o) {
                void 0 === s && (s = !1), void 0 === r && (r = !1), void 0 === o && (o = i.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = n || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), s ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = i.GROUP, this.physicsType = i.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = i.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new i.Signal, this.onChildInputUp = new i.Signal, this.onChildInputOver = new i.Signal, this.onChildInputOut = new i.Signal, this.enableBody = r, this.enableBodyDebug = !1, this.physicsBodyType = o, this.physicsSortDirection = null, this.onDestroy = new i.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new i.Point, this.hash = [], this._sortProperty = "z"
            }, i.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Group.prototype.constructor = i.Group, i.Group.RETURN_NONE = 0, i.Group.RETURN_TOTAL = 1, i.Group.RETURN_CHILD = 2, i.Group.RETURN_ALL = 3, i.Group.SORT_ASCENDING = -1, i.Group.SORT_DESCENDING = 1, i.Group.prototype.add = function(t, e, i) {
                return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
            }, i.Group.prototype.addAt = function(t, e, i) {
                this.add(t, i, e)
            }, i.Group.prototype.addToHash = function(t) {
                if (t.parent === this && -1 === this.hash.indexOf(t)) return this.hash.push(t), !0;
                return !1
            }, i.Group.prototype.removeFromHash = function(t) {
                if (t) {
                    var e = this.hash.indexOf(t);
                    if (-1 !== e) return this.hash.splice(e, 1), !0
                }
                return !1
            }, i.Group.prototype.addMultiple = function(t, e) {
                if (t instanceof i.Group) t.moveAll(this, e);
                else if (Array.isArray(t))
                    for (var n = 0; n < t.length; n++) this.add(t[n], e);
                return t
            }, i.Group.prototype.getAt = function(t) {
                return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
            }, i.Group.prototype.create = function(t, e, i, n, s, r) {
                void 0 === s && (s = !0);
                var o = new this.classType(this.game, t, e, i, n);
                return o.exists = s, o.visible = s, o.alive = s, this.add(o, !1, r)
            }, i.Group.prototype.createMultiple = function(t, e, i, n) {
                void 0 === i && (i = 0), void 0 === n && (n = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
                var s = this,
                    r = [];
                return e.forEach(function(e) {
                    i.forEach(function(i) {
                        for (var o = 0; o < t; o++) r.push(s.create(0, 0, e, i, n))
                    })
                }), r
            }, i.Group.prototype.updateZ = function() {
                for (var t = this.children.length; t--;) this.children[t].z = t
            }, i.Group.prototype.align = function(t, e, n, s, r, o) {
                if (void 0 === r && (r = i.TOP_LEFT), void 0 === o && (o = 0), 0 === this.children.length || o > this.children.length || -1 === t && -1 === e) return !1;
                for (var a = new i.Rectangle(0, 0, n, s), h = t * n, l = e * s, c = o; c < this.children.length; c++) {
                    var u = this.children[c];
                    if (u.alignIn)
                        if (u.alignIn(a, r), -1 === t) a.y += s, a.y === l && (a.x += n, a.y = 0);
                        else if (-1 === e) a.x += n, a.x === h && (a.x = 0, a.y += s);
                    else if (a.x += n, a.x === h && (a.x = 0, a.y += s, a.y === l)) return !0
                }
                return !0
            }, i.Group.prototype.resetCursor = function(t) {
                if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
            }, i.Group.prototype.next = function() {
                if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
            }, i.Group.prototype.previous = function() {
                if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
            }, i.Group.prototype.swap = function(t, e) {
                this.swapChildren(t, e), this.updateZ()
            }, i.Group.prototype.bringToTop = function(t) {
                return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
            }, i.Group.prototype.sendToBack = function(t) {
                return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
            }, i.Group.prototype.moveUp = function(t) {
                if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                    var e = this.getIndex(t),
                        i = this.getAt(e + 1);
                    i && this.swap(t, i)
                }
                return t
            }, i.Group.prototype.moveDown = function(t) {
                if (t.parent === this && this.getIndex(t) > 0) {
                    var e = this.getIndex(t),
                        i = this.getAt(e - 1);
                    i && this.swap(t, i)
                }
                return t
            }, i.Group.prototype.xy = function(t, e, i) {
                if (t < 0 || t > this.children.length) return -1;
                this.getChildAt(t).x = e, this.getChildAt(t).y = i
            }, i.Group.prototype.reverse = function() {
                this.children.reverse(), this.updateZ()
            }, i.Group.prototype.getIndex = function(t) {
                return this.children.indexOf(t)
            }, i.Group.prototype.getByName = function(t) {
                for (var e = 0; e < this.children.length; e++)
                    if (this.children[e].name === t) return this.children[e];
                return null
            }, i.Group.prototype.replace = function(t, e) {
                var n = this.getIndex(t);
                if (-1 !== n) return e.parent && (e.parent instanceof i.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, n), t
            }, i.Group.prototype.hasProperty = function(t, e) {
                var i = e.length;
                return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]))
            }, i.Group.prototype.setProperty = function(t, e, i, n, s) {
                if (void 0 === s && (s = !1), n = n || 0, !this.hasProperty(t, e) && (!s || n > 0)) return !1;
                var r = e.length;
                return 1 === r ? 0 === n ? t[e[0]] = i : 1 === n ? t[e[0]] += i : 2 === n ? t[e[0]] -= i : 3 === n ? t[e[0]] *= i : 4 === n && (t[e[0]] /= i) : 2 === r ? 0 === n ? t[e[0]][e[1]] = i : 1 === n ? t[e[0]][e[1]] += i : 2 === n ? t[e[0]][e[1]] -= i : 3 === n ? t[e[0]][e[1]] *= i : 4 === n && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === n ? t[e[0]][e[1]][e[2]] = i : 1 === n ? t[e[0]][e[1]][e[2]] += i : 2 === n ? t[e[0]][e[1]][e[2]] -= i : 3 === n ? t[e[0]][e[1]][e[2]] *= i : 4 === n && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === n ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === n ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === n ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === n ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === n && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
            }, i.Group.prototype.checkProperty = function(t, e, n, s) {
                return void 0 === s && (s = !1), !(!i.Utils.getProperty(t, e) && s) && i.Utils.getProperty(t, e) === n
            }, i.Group.prototype.set = function(t, e, i, n, s, r, o) {
                if (void 0 === o && (o = !1), e = e.split("."), void 0 === n && (n = !1), void 0 === s && (s = !1), (!1 === n || n && t.alive) && (!1 === s || s && t.visible)) return this.setProperty(t, e, i, r, o)
            }, i.Group.prototype.setAll = function(t, e, i, n, s, r) {
                void 0 === i && (i = !1), void 0 === n && (n = !1), void 0 === r && (r = !1), t = t.split("."), s = s || 0;
                for (var o = 0; o < this.children.length; o++)(!i || i && this.children[o].alive) && (!n || n && this.children[o].visible) && this.setProperty(this.children[o], t, e, s, r)
            }, i.Group.prototype.setAllChildren = function(t, e, n, s, r, o) {
                void 0 === n && (n = !1), void 0 === s && (s = !1), void 0 === o && (o = !1), r = r || 0;
                for (var a = 0; a < this.children.length; a++)(!n || n && this.children[a].alive) && (!s || s && this.children[a].visible) && (this.children[a] instanceof i.Group ? this.children[a].setAllChildren(t, e, n, s, r, o) : this.setProperty(this.children[a], t.split("."), e, r, o))
            }, i.Group.prototype.checkAll = function(t, e, i, n, s) {
                void 0 === i && (i = !1), void 0 === n && (n = !1), void 0 === s && (s = !1);
                for (var r = 0; r < this.children.length; r++)
                    if ((!i || i && this.children[r].alive) && (!n || n && this.children[r].visible) && !this.checkProperty(this.children[r], t, e, s)) return !1;
                return !0
            }, i.Group.prototype.addAll = function(t, e, i, n) {
                this.setAll(t, e, i, n, 1)
            }, i.Group.prototype.subAll = function(t, e, i, n) {
                this.setAll(t, e, i, n, 2)
            }, i.Group.prototype.multiplyAll = function(t, e, i, n) {
                this.setAll(t, e, i, n, 3)
            }, i.Group.prototype.divideAll = function(t, e, i, n) {
                this.setAll(t, e, i, n, 4)
            }, i.Group.prototype.callAllExists = function(t, e) {
                var i;
                if (arguments.length > 2) {
                    i = [];
                    for (var n = 2; n < arguments.length; n++) i.push(arguments[n])
                }
                for (n = 0; n < this.children.length; n++) this.children[n].exists === e && this.children[n][t] && this.children[n][t].apply(this.children[n], i)
            }, i.Group.prototype.callbackFromArray = function(t, e, i) {
                if (1 === i) {
                    if (t[e[0]]) return t[e[0]]
                } else if (2 === i) {
                    if (t[e[0]][e[1]]) return t[e[0]][e[1]]
                } else if (3 === i) {
                    if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
                } else if (4 === i) {
                    if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
                } else if (t[e]) return t[e];
                return !1
            }, i.Group.prototype.callAll = function(t, e) {
                if (void 0 !== t) {
                    var i, n = (t = t.split(".")).length;
                    if (void 0 === e || null === e || "" === e) e = null;
                    else if ("string" == typeof e) var s = (e = e.split(".")).length;
                    if (arguments.length > 2) {
                        i = [];
                        for (var r = 2; r < arguments.length; r++) i.push(arguments[r])
                    }
                    var o = null,
                        a = null;
                    for (r = 0; r < this.children.length; r++) o = this.callbackFromArray(this.children[r], t, n), e && o ? (a = this.callbackFromArray(this.children[r], e, s), o && o.apply(a, i)) : o && o.apply(this.children[r], i)
                }
            }, i.Group.prototype.preUpdate = function() {
                if (this.pendingDestroy) return this.destroy(), !1;
                if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                return !0
            }, i.Group.prototype.update = function() {
                for (var t = this.children.length; t--;) this.children[t].update()
            }, i.Group.prototype.postUpdate = function() {
                this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
                for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
            }, i.Group.prototype.filter = function(t, e) {
                for (var n = -1, s = this.children.length, r = []; ++n < s;) {
                    var o = this.children[n];
                    (!e || e && o.exists) && t(o, n, this.children) && r.push(o)
                }
                return new i.ArraySet(r)
            }, i.Group.prototype.forEach = function(t, e, i) {
                if (void 0 === i && (i = !1), arguments.length <= 3)
                    for (var n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && t.call(e, this.children[n]);
                else {
                    var s = [null];
                    for (n = 3; n < arguments.length; n++) s.push(arguments[n]);
                    for (n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && (s[0] = this.children[n], t.apply(e, s))
                }
            }, i.Group.prototype.forEachExists = function(t, e) {
                var n;
                if (arguments.length > 2) {
                    n = [null];
                    for (var s = 2; s < arguments.length; s++) n.push(arguments[s])
                }
                this.iterate("exists", !0, i.Group.RETURN_TOTAL, t, e, n)
            }, i.Group.prototype.forEachAlive = function(t, e) {
                var n;
                if (arguments.length > 2) {
                    n = [null];
                    for (var s = 2; s < arguments.length; s++) n.push(arguments[s])
                }
                this.iterate("alive", !0, i.Group.RETURN_TOTAL, t, e, n)
            }, i.Group.prototype.forEachDead = function(t, e) {
                var n;
                if (arguments.length > 2) {
                    n = [null];
                    for (var s = 2; s < arguments.length; s++) n.push(arguments[s])
                }
                this.iterate("alive", !1, i.Group.RETURN_TOTAL, t, e, n)
            }, i.Group.prototype.sort = function(t, e) {
                this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = i.Group.SORT_ASCENDING), this._sortProperty = t, e === i.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
            }, i.Group.prototype.customSort = function(t, e) {
                this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
            }, i.Group.prototype.ascendingSortHandler = function(t, e) {
                return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
            }, i.Group.prototype.descendingSortHandler = function(t, e) {
                return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
            }, i.Group.prototype.iterate = function(t, e, n, s, r, o) {
                if (0 === this.children.length) {
                    if (n === i.Group.RETURN_TOTAL) return 0;
                    if (n === i.Group.RETURN_ALL) return []
                }
                var a = 0;
                if (n === i.Group.RETURN_ALL) var h = [];
                for (var l = 0; l < this.children.length; l++)
                    if (this.children[l][t] === e) {
                        if (a++, s && (o ? (o[0] = this.children[l], s.apply(r, o)) : s.call(r, this.children[l])), n === i.Group.RETURN_CHILD) return this.children[l];
                        n === i.Group.RETURN_ALL && h.push(this.children[l])
                    }
                return n === i.Group.RETURN_TOTAL ? a : n === i.Group.RETURN_ALL ? h : null
            }, i.Group.prototype.getFirstExists = function(t, e, n, s, r, o) {
                void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
                var a = this.iterate("exists", t, i.Group.RETURN_CHILD);
                return null === a && e ? this.create(n, s, r, o) : this.resetChild(a, n, s, r, o)
            }, i.Group.prototype.getFirstAlive = function(t, e, n, s, r) {
                void 0 === t && (t = !1);
                var o = this.iterate("alive", !0, i.Group.RETURN_CHILD);
                return null === o && t ? this.create(e, n, s, r) : this.resetChild(o, e, n, s, r)
            }, i.Group.prototype.getFirstDead = function(t, e, n, s, r) {
                void 0 === t && (t = !1);
                var o = this.iterate("alive", !1, i.Group.RETURN_CHILD);
                return null === o && t ? this.create(e, n, s, r) : this.resetChild(o, e, n, s, r)
            }, i.Group.prototype.resetChild = function(t, e, i, n, s) {
                return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== n && t.loadTexture(n, s), t)
            }, i.Group.prototype.getTop = function() {
                if (this.children.length > 0) return this.children[this.children.length - 1]
            }, i.Group.prototype.getBottom = function() {
                if (this.children.length > 0) return this.children[0]
            }, i.Group.prototype.getClosestTo = function(t, e, n) {
                for (var s = Number.MAX_VALUE, r = 0, o = null, a = 0; a < this.children.length; a++) {
                    var h = this.children[a];
                    h.exists && (r = Math.abs(i.Point.distance(t, h))) < s && (!e || e.call(n, h, r)) && (s = r, o = h)
                }
                return o
            }, i.Group.prototype.getFurthestFrom = function(t, e, n) {
                for (var s = 0, r = 0, o = null, a = 0; a < this.children.length; a++) {
                    var h = this.children[a];
                    h.exists && (r = Math.abs(i.Point.distance(t, h))) > s && (!e || e.call(n, h, r)) && (s = r, o = h)
                }
                return o
            }, i.Group.prototype.countLiving = function() {
                return this.iterate("alive", !0, i.Group.RETURN_TOTAL)
            }, i.Group.prototype.countDead = function() {
                return this.iterate("alive", !1, i.Group.RETURN_TOTAL)
            }, i.Group.prototype.getRandom = function(t, e) {
                return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : i.ArrayUtils.getRandomItem(this.children, t, e)
            }, i.Group.prototype.getRandomExists = function(t, e) {
                var i = this.getAll("exists", !0, t, e);
                return this.game.rnd.pick(i)
            }, i.Group.prototype.getAll = function(t, e, i, n) {
                void 0 === i && (i = 0), void 0 === n && (n = this.children.length);
                for (var s = [], r = i; r < n; r++) {
                    var o = this.children[r];
                    t && o[t] === e && s.push(o)
                }
                return s
            }, i.Group.prototype.remove = function(t, e, i) {
                if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
                i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
                var n = this.removeChild(t);
                return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && n && n.destroy(!0), !0
            }, i.Group.prototype.moveAll = function(t, e) {
                if (void 0 === e && (e = !1), this.children.length > 0 && t instanceof i.Group) {
                    do {
                        t.add(this.children[0], e)
                    } while (this.children.length > 0);
                    this.hash = [], this.cursor = null
                }
                return t
            }, i.Group.prototype.removeAll = function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                    do {
                        !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                        var n = this.removeChild(this.children[0]);
                        this.removeFromHash(n), t && n && n.destroy(!0, i)
                    } while (this.children.length > 0);
                    this.hash = [], this.cursor = null
                }
            }, i.Group.prototype.removeBetween = function(t, e, i, n) {
                if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === n && (n = !1), 0 !== this.children.length) {
                    if (t > e || t < 0 || e > this.children.length) return !1;
                    for (var s = e; s >= t;) {
                        !n && this.children[s].events && this.children[s].events.onRemovedFromGroup$dispatch(this.children[s], this);
                        var r = this.removeChild(this.children[s]);
                        this.removeFromHash(r), i && r && r.destroy(!0), this.cursor === this.children[s] && (this.cursor = null), s--
                    }
                    this.updateZ()
                }
            }, i.Group.prototype.destroy = function(t, e) {
                null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
            }, Object.defineProperty(i.Group.prototype, "total", {
                get: function() {
                    return this.iterate("exists", !0, i.Group.RETURN_TOTAL)
                }
            }), Object.defineProperty(i.Group.prototype, "length", {
                get: function() {
                    return this.children.length
                }
            }), Object.defineProperty(i.Group.prototype, "angle", {
                get: function() {
                    return i.Math.radToDeg(this.rotation)
                },
                set: function(t) {
                    this.rotation = i.Math.degToRad(t)
                }
            }), Object.defineProperty(i.Group.prototype, "centerX", {
                get: function() {
                    return this.getBounds(this.parent).centerX
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i - e.halfWidth
                }
            }), Object.defineProperty(i.Group.prototype, "centerY", {
                get: function() {
                    return this.getBounds(this.parent).centerY
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i - e.halfHeight
                }
            }), Object.defineProperty(i.Group.prototype, "left", {
                get: function() {
                    return this.getBounds(this.parent).left
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i
                }
            }), Object.defineProperty(i.Group.prototype, "right", {
                get: function() {
                    return this.getBounds(this.parent).right
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.x - e.x;
                    this.x = t + i - e.width
                }
            }), Object.defineProperty(i.Group.prototype, "top", {
                get: function() {
                    return this.getBounds(this.parent).top
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i
                }
            }), Object.defineProperty(i.Group.prototype, "bottom", {
                get: function() {
                    return this.getBounds(this.parent).bottom
                },
                set: function(t) {
                    var e = this.getBounds(this.parent),
                        i = this.y - e.y;
                    this.y = t + i - e.height
                }
            }), i.World = function(t) {
                i.Group.call(this, t, null, "__world", !1), this.bounds = new i.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
            }, i.World.prototype = Object.create(i.Group.prototype), i.World.prototype.constructor = i.World, i.World.prototype.boot = function() {
                this.camera = new i.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
            }, i.World.prototype.stateChange = function() {
                this.x = 0, this.y = 0, this.camera.reset()
            }, i.World.prototype.setBounds = function(t, e, i, n) {
                this._definedSize = !0, this._width = i, this._height = n, this.bounds.setTo(t, e, i, n), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(n, this.game.height)), this.game.physics.setBoundsToWorld()
            }, i.World.prototype.resize = function(t, e) {
                this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
            }, i.World.prototype.shutdown = function() {
                this.destroy(!0, !0)
            }, i.World.prototype.wrap = function(t, e, i, n, s) {
                void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === n && (n = !0), void 0 === s && (s = !0), i ? (t.getBounds(), n && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), s && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (n && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : n && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), s && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : s && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
            }, Object.defineProperty(i.World.prototype, "width", {
                get: function() {
                    return this.bounds.width
                },
                set: function(t) {
                    t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
                }
            }), Object.defineProperty(i.World.prototype, "height", {
                get: function() {
                    return this.bounds.height
                },
                set: function(t) {
                    t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
                }
            }), Object.defineProperty(i.World.prototype, "centerX", {
                get: function() {
                    return this.bounds.halfWidth + this.bounds.x
                }
            }), Object.defineProperty(i.World.prototype, "centerY", {
                get: function() {
                    return this.bounds.halfHeight + this.bounds.y
                }
            }), Object.defineProperty(i.World.prototype, "randomX", {
                get: function() {
                    return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
                }
            }), Object.defineProperty(i.World.prototype, "randomY", {
                get: function() {
                    return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
                }
            }), i.Game = function(t, e, n, s, r, o, a, h) {
                return this.id = i.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = i.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = i.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new i.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                    enableDebug: !0
                }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== n && (this.renderType = n), void 0 !== s && (this.parent = s), void 0 !== o && (this.transparent = o), void 0 !== a && (this.antialias = a), this.rnd = new i.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new i.StateManager(this, r)), this.device.whenReady(this.boot, this), this
            }, i.Game.prototype = {
                parseConfig: function(t) {
                    this.config = t, void 0 === t.enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                    var e = [(Date.now() * Math.random()).toString()];
                    t.seed && (e = t.seed), this.rnd = new i.RandomDataGenerator(e);
                    var n = null;
                    t.state && (n = t.state), this.state = new i.StateManager(this, n)
                },
                boot: function() {
                    this.isBooted || (this.onPause = new i.Signal, this.onResume = new i.Signal, this.onBlur = new i.Signal, this.onFocus = new i.Signal, this.isBooted = !0, PIXI.game = this, this.math = i.Math, this.scale = new i.ScaleManager(this, this._width, this._height), this.stage = new i.Stage(this), this.setUpRenderer(), this.world = new i.World(this), this.add = new i.GameObjectFactory(this), this.make = new i.GameObjectCreator(this), this.cache = new i.Cache(this), this.load = new i.Loader(this), this.time = new i.Time(this), this.tweens = new i.TweenManager(this), this.input = new i.Input(this), this.sound = new i.SoundManager(this), this.physics = new i.Physics(this, this.physicsConfig), this.particles = new i.Particles(this), this.create = new i.Create(this), this.plugins = new i.PluginManager(this), this.net = new i.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new i.Utils.Debug(this), this.debug.boot()) : this.debug = {
                        preUpdate: function() {},
                        update: function() {},
                        reset: function() {}
                    }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new i.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new i.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start())
                },
                showDebugHeader: function() {
                    if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                        var t = i.VERSION,
                            e = "Canvas",
                            n = "HTML Audio",
                            s = 1;
                        if (this.renderType === i.WEBGL ? (e = "WebGL", s++) : this.renderType === i.HEADLESS && (e = "Headless"), this.device.webAudio && (n = "WebAudio", s++), this.device.chrome)
                            for (var r = ["%c %c %c Phaser v" + t + " | Pixi.js | " + e + " | " + n + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], o = 0; o < 3; o++) o < s ? r.push("color: #ff2424; background: #fff") : r.push("color: #959595; background: #fff");
                        else window.console
                    }
                },
                setUpRenderer: function() {
                    if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = i.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === i.HEADLESS || this.renderType === i.CANVAS || this.renderType === i.AUTO && !this.device.webGL) {
                        if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                        this.renderType = i.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                    } else this.renderType = i.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                    this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === i.CANVAS), this.renderType !== i.HEADLESS && (this.stage.smoothed = this.antialias, i.Canvas.addToDOM(this.canvas, this.parent, !1), i.Canvas.setTouchAction(this.canvas))
                },
                contextLost: function(t) {
                    t.preventDefault(), this.renderer.contextLost = !0
                },
                contextRestored: function() {
                    this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
                },
                update: function(t) {
                    if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                    if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                    else {
                        var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                        this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                        var i = 0;
                        for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                        i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e)
                    }
                },
                updateLogic: function(t) {
                    this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
                },
                updateRender: function(t) {
                    this.lockRender || (this.state.preRender(t), this.renderType !== i.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t))
                },
                enableStep: function() {
                    this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
                },
                disableStep: function() {
                    this.stepping = !1, this.pendingStep = !1
                },
                step: function() {
                    this.pendingStep = !1, this.stepCount++
                },
                destroy: function() {
                    this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), i.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, i.GAMES[this.id] = null
                },
                gamePaused: function(t) {
                    this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
                },
                gameResumed: function(t) {
                    this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
                },
                focusLoss: function(t) {
                    this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
                },
                focusGain: function(t) {
                    this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
                }
            }, i.Game.prototype.constructor = i.Game, Object.defineProperty(i.Game.prototype, "paused", {
                get: function() {
                    return this._paused
                },
                set: function(t) {
                    !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
                }
            }), i.Input = function(t) {
                this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = i.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new i.ArraySet, this._localPoint = new i.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
            }, i.Input.MOUSE_OVERRIDES_TOUCH = 0, i.Input.TOUCH_OVERRIDES_MOUSE = 1, i.Input.MOUSE_TOUCH_COMBINE = 2, i.Input.MAX_POINTERS = 10, i.Input.prototype = {
                boot: function() {
                    this.mousePointer = new i.Pointer(this.game, 0, i.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new i.Mouse(this.game), this.touch = new i.Touch(this.game), this.mspointer = new i.MSPointer(this.game), i.Keyboard && (this.keyboard = new i.Keyboard(this.game)), i.Gamepad && (this.gamepad = new i.Gamepad(this.game)), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.scale = new i.Point(1, 1), this.speed = new i.Point, this.position = new i.Point, this._oldPosition = new i.Point, this.circle = new i.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                    var t = this;
                    this._onClickTrampoline = function(e) {
                        t.onClickTrampoline(e)
                    }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
                },
                destroy: function() {
                    this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
                },
                setInteractiveCandidateHandler: function(t, e) {
                    this.customCandidateHandler = t, this.customCandidateHandlerContext = e
                },
                addMoveCallback: function(t, e) {
                    this.moveCallbacks.push({
                        callback: t,
                        context: e
                    })
                },
                deleteMoveCallback: function(t, e) {
                    for (var i = this.moveCallbacks.length; i--;)
                        if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
                },
                addPointer: function() {
                    if (this.pointers.length >= i.Input.MAX_POINTERS) return null;
                    var t = this.pointers.length + 1,
                        e = new i.Pointer(this.game, t, i.PointerMode.TOUCH);
                    return this.pointers.push(e), this["pointer" + t] = e, e
                },
                update: function() {
                    if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) this._pollCounter++;
                    else {
                        this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                        for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                        this._pollCounter = 0
                    }
                },
                reset: function(t) {
                    if (this.game.isBooted && !this.resetLocked) {
                        void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t), this.gamepad && this.gamepad.reset();
                        for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset();
                        "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.moveCallbacks = []), this._pollCounter = 0
                    }
                },
                resetSpeed: function(t, e) {
                    this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
                },
                startPointer: function(t) {
                    if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                    if (!this.pointer1.active) return this.pointer1.start(t);
                    if (!this.pointer2.active) return this.pointer2.start(t);
                    for (var e = 2; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (!i.active) return i.start(t)
                    }
                    return null
                },
                updatePointer: function(t) {
                    if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                    if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                    for (var e = 2; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.active && i.identifier === t.identifier) return i.move(t)
                    }
                    return null
                },
                stopPointer: function(t) {
                    if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                    if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                    for (var e = 2; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.active && i.identifier === t.identifier) return i.stop(t)
                    }
                    return null
                },
                countActivePointers: function(t) {
                    void 0 === t && (t = this.pointers.length);
                    for (var e = t, i = 0; i < this.pointers.length && e > 0; i++) {
                        this.pointers[i].active && e--
                    }
                    return t - e
                },
                getPointer: function(t) {
                    void 0 === t && (t = !1);
                    for (var e = 0; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.active === t) return i
                    }
                    return null
                },
                getPointerFromIdentifier: function(t) {
                    for (var e = 0; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.identifier === t) return i
                    }
                    return null
                },
                getPointerFromId: function(t) {
                    for (var e = 0; e < this.pointers.length; e++) {
                        var i = this.pointers[e];
                        if (i.pointerId === t) return i
                    }
                    return null
                },
                getLocalPosition: function(t, e, n) {
                    void 0 === n && (n = new i.Point);
                    var s = t.worldTransform,
                        r = 1 / (s.a * s.d + s.c * -s.b);
                    return n.setTo(s.d * r * e.x + -s.c * r * e.y + (s.ty * s.c - s.tx * s.d) * r, s.a * r * e.y + -s.b * r * e.x + (-s.ty * s.a + s.tx * s.b) * r)
                },
                hitTest: function(t, e, n) {
                    if (!t.worldVisible) return !1;
                    if (this.getLocalPosition(t, e, this._localPoint), n.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                    if (t instanceof i.TileSprite) {
                        var s = t.width,
                            r = t.height,
                            o = -s * t.anchor.x;
                        if (this._localPoint.x >= o && this._localPoint.x < o + s) {
                            var a = -r * t.anchor.y;
                            if (this._localPoint.y >= a && this._localPoint.y < a + r) return !0
                        }
                    } else if (t instanceof PIXI.Sprite) {
                        s = t.texture.frame.width, r = t.texture.frame.height, o = -s * t.anchor.x;
                        if (this._localPoint.x >= o && this._localPoint.x < o + s) {
                            a = -r * t.anchor.y;
                            if (this._localPoint.y >= a && this._localPoint.y < a + r) return !0
                        }
                    } else if (t instanceof i.Graphics)
                        for (var h = 0; h < t.graphicsData.length; h++) {
                            var l = t.graphicsData[h];
                            if (l.fill && (l.shape && l.shape.contains(this._localPoint.x, this._localPoint.y))) return !0
                        }
                    for (h = 0; h < t.children.length; h++)
                        if (this.hitTest(t.children[h], e, n)) return !0;
                    return !1
                },
                onClickTrampoline: function() {
                    this.activePointer.processClickTrampolines()
                }
            }, i.Input.prototype.constructor = i.Input, Object.defineProperty(i.Input.prototype, "x", {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = Math.floor(t)
                }
            }), Object.defineProperty(i.Input.prototype, "y", {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = Math.floor(t)
                }
            }), Object.defineProperty(i.Input.prototype, "pollLocked", {
                get: function() {
                    return this.pollRate > 0 && this._pollCounter < this.pollRate
                }
            }), Object.defineProperty(i.Input.prototype, "totalInactivePointers", {
                get: function() {
                    return this.pointers.length - this.countActivePointers()
                }
            }), Object.defineProperty(i.Input.prototype, "totalActivePointers", {
                get: function() {
                    return this.countActivePointers()
                }
            }), Object.defineProperty(i.Input.prototype, "worldX", {
                get: function() {
                    return this.game.camera.view.x + this.x
                }
            }), Object.defineProperty(i.Input.prototype, "worldY", {
                get: function() {
                    return this.game.camera.view.y + this.y
                }
            }), i.Mouse = function(t) {
                this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new i.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
            }, i.Mouse.NO_BUTTON = -1, i.Mouse.LEFT_BUTTON = 0, i.Mouse.MIDDLE_BUTTON = 1, i.Mouse.RIGHT_BUTTON = 2, i.Mouse.BACK_BUTTON = 3, i.Mouse.FORWARD_BUTTON = 4, i.Mouse.WHEEL_UP = 1, i.Mouse.WHEEL_DOWN = -1, i.Mouse.prototype = {
                start: function() {
                    if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                        var t = this;
                        this._onMouseDown = function(e) {
                            return t.onMouseDown(e)
                        }, this._onMouseMove = function(e) {
                            return t.onMouseMove(e)
                        }, this._onMouseUp = function(e) {
                            return t.onMouseUp(e)
                        }, this._onMouseUpGlobal = function(e) {
                            return t.onMouseUpGlobal(e)
                        }, this._onMouseOutGlobal = function(e) {
                            return t.onMouseOutGlobal(e)
                        }, this._onMouseOut = function(e) {
                            return t.onMouseOut(e)
                        }, this._onMouseOver = function(e) {
                            return t.onMouseOver(e)
                        }, this._onMouseWheel = function(e) {
                            return t.onMouseWheel(e)
                        };
                        var e = this.game.canvas;
                        e.addEventListener("mousedown", this._onMouseDown, !0), e.addEventListener("mousemove", this._onMouseMove, !0), e.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), e.addEventListener("mouseover", this._onMouseOver, !0), e.addEventListener("mouseout", this._onMouseOut, !0));
                        var i = this.game.device.wheelEvent;
                        i && (e.addEventListener(i, this._onMouseWheel, !0), "mousewheel" === i ? this._wheelEvent = new s(-.025, 1) : "DOMMouseScroll" === i && (this._wheelEvent = new s(1, 1)))
                    }
                },
                onMouseDown: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
                },
                onMouseMove: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
                },
                onMouseUp: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
                },
                onMouseUpGlobal: function(t) {
                    this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
                },
                onMouseOutGlobal: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t))
                },
                onMouseOut: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t))
                },
                onMouseOver: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
                },
                onMouseWheel: function(t) {
                    this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = i.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
                },
                requestPointerLock: function() {
                    if (this.game.device.pointerLock) {
                        var t = this.game.canvas;
                        t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                        var e = this;
                        this._pointerLockChange = function(t) {
                            return e.pointerLockChange(t)
                        }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    }
                },
                pointerLockChange: function(t) {
                    var e = this.game.canvas;
                    document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
                },
                releasePointerLock: function() {
                    document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                },
                stop: function() {
                    var t = this.game.canvas;
                    t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
                    var e = this.game.device.wheelEvent;
                    e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                }
            }, i.Mouse.prototype.constructor = i.Mouse, s.prototype = {}, s.prototype.constructor = s, s.prototype.bindEvent = function(t) {
                if (!s._stubsGenerated && t) {
                    var e = function(t) {
                        return function() {
                            var e = this.originalEvent[t];
                            return "function" != typeof e ? e : e.bind(this.originalEvent)
                        }
                    };
                    for (var i in t) i in s.prototype || Object.defineProperty(s.prototype, i, {
                        get: e(i)
                    });
                    s._stubsGenerated = !0
                }
                return this.originalEvent = t, this
            }, Object.defineProperties(s.prototype, {
                type: {
                    value: "wheel"
                },
                deltaMode: {
                    get: function() {
                        return this._deltaMode
                    }
                },
                deltaY: {
                    get: function() {
                        return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                    }
                },
                deltaX: {
                    get: function() {
                        return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                    }
                },
                deltaZ: {
                    value: 0
                }
            }), i.MSPointer = function(t) {
                this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
            }, i.MSPointer.prototype = {
                start: function() {
                    if (null === this._onMSPointerDown) {
                        var t = this;
                        if (this.game.device.mspointer) {
                            this._onMSPointerDown = function(e) {
                                return t.onPointerDown(e)
                            }, this._onMSPointerMove = function(e) {
                                return t.onPointerMove(e)
                            }, this._onMSPointerUp = function(e) {
                                return t.onPointerUp(e)
                            }, this._onMSPointerUpGlobal = function(e) {
                                return t.onPointerUpGlobal(e)
                            }, this._onMSPointerOut = function(e) {
                                return t.onPointerOut(e)
                            }, this._onMSPointerOver = function(e) {
                                return t.onPointerOver(e)
                            };
                            var e = this.game.canvas;
                            e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0))
                        }
                    }
                },
                onPointerDown: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
                },
                onPointerMove: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
                },
                onPointerUp: function(t) {
                    this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
                },
                onPointerUpGlobal: function(t) {
                    if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && e.withinGame && this.onPointerUp(t)
                    } else this.onPointerUp(t)
                },
                onPointerOut: function(t) {
                    if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                    else {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && (e.withinGame = !1)
                    }
                    this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
                },
                onPointerOver: function(t) {
                    if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                    else {
                        var e = this.input.getPointerFromIdentifier(t.identifier);
                        e && (e.withinGame = !0)
                    }
                    this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
                },
                stop: function() {
                    var t = this.game.canvas;
                    t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0)
                }
            }, i.MSPointer.prototype.constructor = i.MSPointer, i.DeviceButton = function(t, e) {
                this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new i.Signal, this.onUp = new i.Signal, this.onFloat = new i.Signal
            }, i.DeviceButton.prototype = {
                start: function(t, e) {
                    this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
                },
                stop: function(t, e) {
                    this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
                },
                padFloat: function(t) {
                    this.value = t, this.onFloat.dispatch(this, t)
                },
                justPressed: function(t) {
                    return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
                },
                justReleased: function(t) {
                    return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
                },
                reset: function() {
                    this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
                },
                destroy: function() {
                    this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
                }
            }, i.DeviceButton.prototype.constructor = i.DeviceButton, Object.defineProperty(i.DeviceButton.prototype, "duration", {
                get: function() {
                    return this.isUp ? -1 : this.game.time.time - this.timeDown
                }
            }), i.Pointer = function(t, e, n) {
                this.game = t, this.id = e, this.type = i.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = n || i.PointerMode.CURSOR | i.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new i.DeviceButton(this, i.Pointer.LEFT_BUTTON), this.middleButton = new i.DeviceButton(this, i.Pointer.MIDDLE_BUTTON), this.rightButton = new i.DeviceButton(this, i.Pointer.RIGHT_BUTTON), this.backButton = new i.DeviceButton(this, i.Pointer.BACK_BUTTON), this.forwardButton = new i.DeviceButton(this, i.Pointer.FORWARD_BUTTON), this.eraserButton = new i.DeviceButton(this, i.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new i.Point, this.positionDown = new i.Point, this.positionUp = new i.Point, this.circle = new i.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
            }, i.Pointer.NO_BUTTON = 0, i.Pointer.LEFT_BUTTON = 1, i.Pointer.RIGHT_BUTTON = 2, i.Pointer.MIDDLE_BUTTON = 4, i.Pointer.BACK_BUTTON = 8, i.Pointer.FORWARD_BUTTON = 16, i.Pointer.ERASER_BUTTON = 32, i.Pointer.prototype = {
                resetButtons: function() {
                    this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
                },
                processButtonsDown: function(t, e) {
                    i.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), i.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), i.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), i.Pointer.BACK_BUTTON & t && this.backButton.start(e), i.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), i.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e)
                },
                processButtonsUp: function(t, e) {
                    t === i.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === i.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === i.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === i.Mouse.BACK_BUTTON && this.backButton.stop(e), t === i.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e)
                },
                updateButtons: function(t) {
                    this.button = t.button;
                    var e = "down" === t.type.toLowerCase().substr(-4);
                    void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
                },
                start: function(t) {
                    var e = this.game.input;
                    return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
                },
                update: function() {
                    var t = this.game.input;
                    this.active && (this.dirty && (t.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                        x: this.position.x,
                        y: this.position.y
                    }), this._history.length > t.recordLimit && this._history.shift()))
                },
                move: function(t, e) {
                    var n = this.game.input;
                    if (!n.pollLocked) {
                        if (void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && n.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * n.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * n.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (n.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || n.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || n.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === n.totalActivePointers) && (n.activePointer = this, n.x = this.x, n.y = this.y, n.position.setTo(n.x, n.y), n.circle.x = n.x, n.circle.y = n.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                        for (var s = n.moveCallbacks.length; s--;) n.moveCallbacks[s].callback.call(n.moveCallbacks[s].context, this, this.x, this.y, e);
                        return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : n.interactiveItems.total > 0 && this.processInteractiveObjects(e), this
                    }
                },
                processInteractiveObjects: function(t) {
                    var e = 0,
                        i = -1,
                        n = null,
                        s = this.game.input.interactiveItems.first;
                    for (this.interactiveCandidates = []; s;) s.checked = !1, s.validForInput(i, e, !1) && (s.checked = !0, (t && s.checkPointerDown(this, !0) || !t && s.checkPointerOver(this, !0)) && (e = s.sprite.renderOrderID, i = s.priorityID, n = s, this.interactiveCandidates.push(s))), s = this.game.input.interactiveItems.next;
                    for (s = this.game.input.interactiveItems.first; s;) !s.checked && s.validForInput(i, e, !0) && (t && s.checkPointerDown(this, !1) || !t && s.checkPointerOver(this, !1)) && (e = s.sprite.renderOrderID, i = s.priorityID, n = s, this.interactiveCandidates.push(s)), s = this.game.input.interactiveItems.next;
                    return this.game.input.customCandidateHandler && (n = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, n)), this.swapTarget(n, !1), null !== this.targetObject
                },
                swapTarget: function(t, e) {
                    void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
                },
                leave: function(t) {
                    this.withinGame = !1, this.move(t, !1)
                },
                stop: function(t) {
                    var e = this.game.input;
                    if (!this._stateReset || !this.withinGame) return this.timeUp = this.game.time.time, (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this;
                    t.preventDefault()
                },
                justPressed: function(t) {
                    return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
                },
                justReleased: function(t) {
                    return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
                },
                addClickTrampoline: function(t, e, i, n) {
                    if (this.isDown) {
                        for (var s = this._clickTrampolines = this._clickTrampolines || [], r = 0; r < s.length; r++)
                            if (s[r].name === t) {
                                s.splice(r, 1);
                                break
                            }
                        s.push({
                            name: t,
                            targetObject: this.targetObject,
                            callback: e,
                            callbackContext: i,
                            callbackArgs: n
                        })
                    }
                },
                processClickTrampolines: function() {
                    var t = this._clickTrampolines;
                    if (t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = t[e];
                            i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                        }
                        this._clickTrampolines = null, this._trampolineTargetObject = null
                    }
                },
                reset: function() {
                    !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
                },
                resetMovement: function() {
                    this.movementX = 0, this.movementY = 0
                }
            }, i.Pointer.prototype.constructor = i.Pointer, Object.defineProperty(i.Pointer.prototype, "duration", {
                get: function() {
                    return this.isUp ? -1 : this.game.time.time - this.timeDown
                }
            }), Object.defineProperty(i.Pointer.prototype, "worldX", {
                get: function() {
                    return this.game.world.camera.x + this.x
                }
            }), Object.defineProperty(i.Pointer.prototype, "worldY", {
                get: function() {
                    return this.game.world.camera.y + this.y
                }
            }), i.PointerMode = {
                CURSOR: 1,
                CONTACT: 2
            }, i.Touch = function(t) {
                this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
            }, i.Touch.prototype = {
                start: function() {
                    if (null === this._onTouchStart) {
                        var t = this;
                        this.game.device.touch && (this._onTouchStart = function(e) {
                            return t.onTouchStart(e)
                        }, this._onTouchMove = function(e) {
                            return t.onTouchMove(e)
                        }, this._onTouchEnd = function(e) {
                            return t.onTouchEnd(e)
                        }, this._onTouchEnter = function(e) {
                            return t.onTouchEnter(e)
                        }, this._onTouchLeave = function(e) {
                            return t.onTouchLeave(e)
                        }, this._onTouchCancel = function(e) {
                            return t.onTouchCancel(e)
                        }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                    }
                },
                consumeDocumentTouches: function() {
                    this._documentTouchMove = function(t) {
                        t.preventDefault()
                    }, document.addEventListener("touchmove", this._documentTouchMove, !1)
                },
                addTouchLockCallback: function(t, e, i) {
                    void 0 === i && (i = !1), this.touchLockCallbacks.push({
                        callback: t,
                        context: e,
                        onEnd: i
                    })
                },
                removeTouchLockCallback: function(t, e) {
                    for (var i = this.touchLockCallbacks.length; i--;)
                        if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                    return !1
                },
                onTouchStart: function(t) {
                    for (var e = this.touchLockCallbacks.length; e--;) {
                        var i = this.touchLockCallbacks[e];
                        !i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                    }
                    if (this.event = t, this.game.input.enabled && this.enabled) {
                        this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                    }
                },
                onTouchCancel: function(t) {
                    if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                        this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                    }
                },
                onTouchEnter: function(t) {
                    this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
                },
                onTouchLeave: function(t) {
                    this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
                },
                onTouchMove: function(t) {
                    this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
                },
                onTouchEnd: function(t) {
                    for (var e = this.touchLockCallbacks.length; e--;) {
                        var i = this.touchLockCallbacks[e];
                        i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                    }
                    this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                    for (e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                },
                stop: function() {
                    this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
                }
            }, i.Touch.prototype.constructor = i.Touch, i.InputHandler = function(t) {
                this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new i.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new i.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new i.Point, this.snapPoint = new i.Point, this._dragPoint = new i.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new i.Point, this._pointerData = [], this._pointerData.push({
                    id: 0,
                    x: 0,
                    y: 0,
                    camX: 0,
                    camY: 0,
                    isDown: !1,
                    isUp: !1,
                    isOver: !1,
                    isOut: !1,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: !1
                })
            }, i.InputHandler.prototype = {
                start: function(t, e) {
                    if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                        this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                        for (var n = 0; n < 10; n++) this._pointerData[n] = {
                            id: n,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        };
                        this.snapOffset = new i.Point, this.enabled = !0, this._wasEnabled = !0
                    }
                    return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
                },
                addedToGroup: function() {
                    this._dragPhase || this._wasEnabled && !this.enabled && this.start()
                },
                removedFromGroup: function() {
                    this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
                },
                reset: function() {
                    this.enabled = !1;
                    for (var t = 0; t < 10; t++) this._pointerData[t] = {
                        id: t,
                        x: 0,
                        y: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    }
                },
                stop: function() {
                    !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
                },
                destroy: function() {
                    this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
                },
                validForInput: function(t, e, i) {
                    return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
                },
                isPixelPerfect: function() {
                    return this.pixelPerfectClick || this.pixelPerfectOver
                },
                pointerX: function(t) {
                    return t = t || 0, this._pointerData[t].x
                },
                pointerY: function(t) {
                    return t = t || 0, this._pointerData[t].y
                },
                pointerDown: function(t) {
                    return t = t || 0, this._pointerData[t].isDown
                },
                pointerUp: function(t) {
                    return t = t || 0, this._pointerData[t].isUp
                },
                pointerTimeDown: function(t) {
                    return t = t || 0, this._pointerData[t].timeDown
                },
                pointerTimeUp: function(t) {
                    return t = t || 0, this._pointerData[t].timeUp
                },
                pointerOver: function(t) {
                    if (!this.enabled) return !1;
                    if (void 0 === t) {
                        for (var e = 0; e < 10; e++)
                            if (this._pointerData[e].isOver) return !0;
                        return !1
                    }
                    return this._pointerData[t].isOver
                },
                pointerOut: function(t) {
                    if (!this.enabled) return !1;
                    if (void 0 !== t) return this._pointerData[t].isOut;
                    for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOut) return !0
                },
                pointerTimeOver: function(t) {
                    return t = t || 0, this._pointerData[t].timeOver
                },
                pointerTimeOut: function(t) {
                    return t = t || 0, this._pointerData[t].timeOut
                },
                pointerDragged: function(t) {
                    return t = t || 0, this._pointerData[t].isDragged
                },
                checkPointerDown: function(t, e) {
                    return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                },
                checkPointerOver: function(t, e) {
                    return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                },
                checkPixel: function(t, e, i) {
                    if (this.sprite.texture.baseTexture.source) {
                        if (null === t && null === e) {
                            this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                            t = this._tempPoint.x, e = this._tempPoint.y
                        }
                        if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                        if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                    }
                    return !1
                },
                update: function(t) {
                    if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = i.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
                },
                _pointerOverHandler: function(t, e) {
                    if (null !== this.sprite) {
                        var n = this._pointerData[t.id];
                        if (!1 === n.isOver || t.dirty) {
                            var s = !1 === n.isOver;
                            n.isOver = !0, n.isOut = !1, n.timeOver = this.game.time.time, n.x = t.x - this.sprite.x, n.y = t.y - this.sprite.y, this.useHandCursor && !1 === n.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                        }
                    }
                },
                _pointerOutHandler: function(t, e) {
                    if (null !== this.sprite) {
                        var n = this._pointerData[t.id];
                        n.isOver = !1, n.isOut = !0, n.timeOut = this.game.time.time, this.useHandCursor && !1 === n.isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                    }
                },
                _touchedHandler: function(t) {
                    if (null !== this.sprite) {
                        var e = this._pointerData[t.id];
                        if (!e.isDown && e.isOver) {
                            if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                            if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                            this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                        }
                    }
                },
                dragTimeElapsed: function(t) {
                    this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
                },
                _releasedHandler: function(t) {
                    if (null !== this.sprite) {
                        var e = this._pointerData[t.id];
                        if (e.isDown && t.isUp) {
                            e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                            var n = this.checkPointerOver(t);
                            this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, n), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, n), n && (n = this.checkPointerOver(t))), e.isOver = n, !n && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                        }
                    }
                },
                updateDrag: function(t, e) {
                    if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                    var i = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                        n = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y;
                    if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = i), this.allowVerticalDrag && (this.sprite.cameraOffset.y = n), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                    else {
                        var s = this.game.camera.x - this._pointerData[t.id].camX,
                            r = this.game.camera.y - this._pointerData[t.id].camY;
                        this.allowHorizontalDrag && (this.sprite.x = i + s), this.allowVerticalDrag && (this.sprite.y = n + r), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
                    }
                    return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, i, n, this.snapPoint, e), !0
                },
                justOver: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
                },
                justOut: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
                },
                justPressed: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
                },
                justReleased: function(t, e) {
                    return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
                },
                overDuration: function(t) {
                    return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
                },
                downDuration: function(t) {
                    return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
                },
                enableDrag: function(t, e, n, s, r, o) {
                    void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === n && (n = !1), void 0 === s && (s = 255), void 0 === r && (r = null), void 0 === o && (o = null), this._dragPoint = new i.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new i.Point, this.dragFromCenter = t, this.pixelPerfectClick = n, this.pixelPerfectAlpha = s, r && (this.boundsRect = r), o && (this.boundsSprite = o)
                },
                disableDrag: function() {
                    if (this._pointerData)
                        for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                    this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
                },
                startDrag: function(t) {
                    var e = this.sprite.x,
                        i = this.sprite.y;
                    if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                        if (this.dragFromCenter) {
                            var n = this.sprite.getBounds();
                            this.sprite.cameraOffset.x = this.globalToLocalX(t.x) + (this.sprite.cameraOffset.x - n.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(t.y) + (this.sprite.cameraOffset.y - n.centerY)
                        }
                        this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                    } else {
                        if (this.dragFromCenter) {
                            n = this.sprite.getBounds();
                            this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - n.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - n.centerY)
                        }
                        this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y))
                    }
                    this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1
                },
                globalToLocalX: function(t) {
                    return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
                },
                globalToLocalY: function(t) {
                    return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
                },
                stopDrag: function(t) {
                    this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
                },
                setDragLock: function(t, e) {
                    void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
                },
                enableSnap: function(t, e, i, n, s, r) {
                    void 0 === i && (i = !0), void 0 === n && (n = !1), void 0 === s && (s = 0), void 0 === r && (r = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = s, this.snapOffsetY = r, this.snapOnDrag = i, this.snapOnRelease = n
                },
                disableSnap: function() {
                    this.snapOnDrag = !1, this.snapOnRelease = !1
                },
                checkBoundsRect: function() {
                    this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
                },
                checkBoundsSprite: function() {
                    this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
                }
            }, i.InputHandler.prototype.constructor = i.InputHandler, i.Gamepad = function(t) {
                this.game = t, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new i.SinglePad(t, this), new i.SinglePad(t, this), new i.SinglePad(t, this), new i.SinglePad(t, this)]
            }, i.Gamepad.prototype = {
                addCallbacks: function(t, e) {
                    void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                },
                start: function() {
                    if (!this._active) {
                        this._active = !0;
                        var t = this;
                        this._onGamepadConnected = function(e) {
                            return t.onGamepadConnected(e)
                        }, this._onGamepadDisconnected = function(e) {
                            return t.onGamepadDisconnected(e)
                        }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                    }
                },
                onGamepadConnected: function(t) {
                    var e = t.gamepad;
                    this._rawPads.push(e), this._gamepads[e.index].connect(e)
                },
                onGamepadDisconnected: function(t) {
                    var e = t.gamepad;
                    for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                    this._gamepads[e.index].disconnect()
                },
                update: function() {
                    this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
                },
                _pollGamepads: function() {
                    if (this._active) {
                        if (navigator.getGamepads) var t = navigator.getGamepads();
                        else if (navigator.webkitGetGamepads) t = navigator.webkitGetGamepads();
                        else if (navigator.webkitGamepads) t = navigator.webkitGamepads();
                        if (t) {
                            this._rawPads = [];
                            for (var e = !1, i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                            for (var n = 0; n < this._gamepads.length; n++) this._gamepads[n]._rawPad = this._rawPads[n];
                            if (e) {
                                for (var s, r = {
                                        rawIndices: {},
                                        padIndices: {}
                                    }, o = 0; o < this._gamepads.length; o++)
                                    if ((s = this._gamepads[o]).connected)
                                        for (var a = 0; a < this._rawPads.length; a++) this._rawPads[a].index === s.index && (r.rawIndices[s.index] = !0, r.padIndices[o] = !0);
                                for (var h = 0; h < this._gamepads.length; h++)
                                    if (s = this._gamepads[h], !r.padIndices[h]) {
                                        this._rawPads.length < 1 && s.disconnect();
                                        for (var l = 0; l < this._rawPads.length && !r.padIndices[h]; l++) {
                                            var c = this._rawPads[l];
                                            if (c) {
                                                if (r.rawIndices[c.index]) {
                                                    s.disconnect();
                                                    continue
                                                }
                                                s.connect(c), r.rawIndices[c.index] = !0, r.padIndices[h] = !0
                                            } else s.disconnect()
                                        }
                                    }
                            }
                        }
                    }
                },
                setDeadZones: function(t) {
                    for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
                },
                stop: function() {
                    this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
                },
                reset: function() {
                    this.update();
                    for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
                },
                justPressed: function(t, e) {
                    for (var i = 0; i < this._gamepads.length; i++)
                        if (!0 === this._gamepads[i].justPressed(t, e)) return !0;
                    return !1
                },
                justReleased: function(t, e) {
                    for (var i = 0; i < this._gamepads.length; i++)
                        if (!0 === this._gamepads[i].justReleased(t, e)) return !0;
                    return !1
                },
                isDown: function(t) {
                    for (var e = 0; e < this._gamepads.length; e++)
                        if (!0 === this._gamepads[e].isDown(t)) return !0;
                    return !1
                },
                destroy: function() {
                    this.stop();
                    for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy()
                }
            }, i.Gamepad.prototype.constructor = i.Gamepad, Object.defineProperty(i.Gamepad.prototype, "active", {
                get: function() {
                    return this._active
                }
            }), Object.defineProperty(i.Gamepad.prototype, "supported", {
                get: function() {
                    return this._gamepadSupportAvailable
                }
            }), Object.defineProperty(i.Gamepad.prototype, "padsConnected", {
                get: function() {
                    return this._rawPads.length
                }
            }), Object.defineProperty(i.Gamepad.prototype, "pad1", {
                get: function() {
                    return this._gamepads[0]
                }
            }), Object.defineProperty(i.Gamepad.prototype, "pad2", {
                get: function() {
                    return this._gamepads[1]
                }
            }), Object.defineProperty(i.Gamepad.prototype, "pad3", {
                get: function() {
                    return this._gamepads[2]
                }
            }), Object.defineProperty(i.Gamepad.prototype, "pad4", {
                get: function() {
                    return this._gamepads[3]
                }
            }), i.Gamepad.BUTTON_0 = 0, i.Gamepad.BUTTON_1 = 1, i.Gamepad.BUTTON_2 = 2, i.Gamepad.BUTTON_3 = 3, i.Gamepad.BUTTON_4 = 4, i.Gamepad.BUTTON_5 = 5, i.Gamepad.BUTTON_6 = 6, i.Gamepad.BUTTON_7 = 7, i.Gamepad.BUTTON_8 = 8, i.Gamepad.BUTTON_9 = 9, i.Gamepad.BUTTON_10 = 10, i.Gamepad.BUTTON_11 = 11, i.Gamepad.BUTTON_12 = 12, i.Gamepad.BUTTON_13 = 13, i.Gamepad.BUTTON_14 = 14, i.Gamepad.BUTTON_15 = 15, i.Gamepad.AXIS_0 = 0, i.Gamepad.AXIS_1 = 1, i.Gamepad.AXIS_2 = 2, i.Gamepad.AXIS_3 = 3, i.Gamepad.AXIS_4 = 4, i.Gamepad.AXIS_5 = 5, i.Gamepad.AXIS_6 = 6, i.Gamepad.AXIS_7 = 7, i.Gamepad.AXIS_8 = 8, i.Gamepad.AXIS_9 = 9, i.Gamepad.XBOX360_A = 0, i.Gamepad.XBOX360_B = 1, i.Gamepad.XBOX360_X = 2, i.Gamepad.XBOX360_Y = 3, i.Gamepad.XBOX360_LEFT_BUMPER = 4, i.Gamepad.XBOX360_RIGHT_BUMPER = 5, i.Gamepad.XBOX360_LEFT_TRIGGER = 6, i.Gamepad.XBOX360_RIGHT_TRIGGER = 7, i.Gamepad.XBOX360_BACK = 8, i.Gamepad.XBOX360_START = 9, i.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, i.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, i.Gamepad.XBOX360_DPAD_LEFT = 14, i.Gamepad.XBOX360_DPAD_RIGHT = 15, i.Gamepad.XBOX360_DPAD_UP = 12, i.Gamepad.XBOX360_DPAD_DOWN = 13, i.Gamepad.XBOX360_STICK_LEFT_X = 0, i.Gamepad.XBOX360_STICK_LEFT_Y = 1, i.Gamepad.XBOX360_STICK_RIGHT_X = 2, i.Gamepad.XBOX360_STICK_RIGHT_Y = 3, i.Gamepad.PS3XC_X = 0, i.Gamepad.PS3XC_CIRCLE = 1, i.Gamepad.PS3XC_SQUARE = 2, i.Gamepad.PS3XC_TRIANGLE = 3, i.Gamepad.PS3XC_L1 = 4, i.Gamepad.PS3XC_R1 = 5, i.Gamepad.PS3XC_L2 = 6, i.Gamepad.PS3XC_R2 = 7, i.Gamepad.PS3XC_SELECT = 8, i.Gamepad.PS3XC_START = 9, i.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, i.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, i.Gamepad.PS3XC_DPAD_UP = 12, i.Gamepad.PS3XC_DPAD_DOWN = 13, i.Gamepad.PS3XC_DPAD_LEFT = 14, i.Gamepad.PS3XC_DPAD_RIGHT = 15, i.Gamepad.PS3XC_STICK_LEFT_X = 0, i.Gamepad.PS3XC_STICK_LEFT_Y = 1, i.Gamepad.PS3XC_STICK_RIGHT_X = 2, i.Gamepad.PS3XC_STICK_RIGHT_Y = 3, i.SinglePad = function(t, e) {
                this.game = t, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
            }, i.SinglePad.prototype = {
                addCallbacks: function(t, e) {
                    void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                },
                getButton: function(t) {
                    return this._buttons[t] ? this._buttons[t] : null
                },
                pollStatus: function() {
                    if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                        for (var t = 0; t < this._buttonsLen; t++) {
                            var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                            e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                        }
                        for (var i = 0; i < this._axesLen; i++) {
                            var n = this._rawPad.axes[i];
                            n > 0 && n > this.deadZone || n < 0 && n < -this.deadZone ? this.processAxisChange(i, n) : this.processAxisChange(i, 0)
                        }
                        this._prevTimestamp = this._rawPad.timestamp
                    }
                },
                connect: function(t) {
                    var e = !this.connected;
                    this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = [], this._axesLen = t.axes.length;
                    for (var n = 0; n < this._axesLen; n++) this._axes[n] = t.axes[n];
                    for (var s in t.buttons) s = parseInt(s, 10), this._buttons[s] = new i.DeviceButton(this, s);
                    e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
                },
                disconnect: function() {
                    var t = this.connected,
                        e = this.index;
                    this.connected = !1, this.index = null, this._rawPad = void 0;
                    for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
                },
                destroy: function() {
                    this._rawPad = void 0;
                    for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                    this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
                },
                processAxisChange: function(t, e) {
                    this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
                },
                processButtonDown: function(t, e) {
                    this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
                },
                processButtonUp: function(t, e) {
                    this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e)
                },
                processButtonFloat: function(t, e) {
                    this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e)
                },
                axis: function(t) {
                    return !!this._axes[t] && this._axes[t]
                },
                isDown: function(t) {
                    return !!this._buttons[t] && this._buttons[t].isDown
                },
                isUp: function(t) {
                    return !!this._buttons[t] && this._buttons[t].isUp
                },
                justReleased: function(t, e) {
                    if (this._buttons[t]) return this._buttons[t].justReleased(e)
                },
                justPressed: function(t, e) {
                    if (this._buttons[t]) return this._buttons[t].justPressed(e)
                },
                buttonValue: function(t) {
                    return this._buttons[t] ? this._buttons[t].value : null
                },
                reset: function() {
                    for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
                }
            }, i.SinglePad.prototype.constructor = i.SinglePad, i.Key = function(t, e) {
                this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new i.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new i.Signal, this._justDown = !1, this._justUp = !1
            }, i.Key.prototype = {
                update: function() {
                    this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
                },
                processKeyDown: function(t) {
                    this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
                },
                processKeyUp: function(t) {
                    this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this)))
                },
                reset: function(t) {
                    void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
                },
                downDuration: function(t) {
                    return void 0 === t && (t = 50), this.isDown && this.duration < t
                },
                upDuration: function(t) {
                    return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
                }
            }, Object.defineProperty(i.Key.prototype, "justDown", {
                get: function() {
                    var t = this._justDown;
                    return this._justDown = !1, t
                }
            }), Object.defineProperty(i.Key.prototype, "justUp", {
                get: function() {
                    var t = this._justUp;
                    return this._justUp = !1, t
                }
            }), Object.defineProperty(i.Key.prototype, "enabled", {
                get: function() {
                    return this._enabled
                },
                set: function(t) {
                    (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
                }
            }), i.Key.prototype.constructor = i.Key, i.Keyboard = function(t) {
                this.game = t, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
            }, i.Keyboard.prototype = {
                addCallbacks: function(t, e, i, n) {
                    this.callbackContext = t, void 0 !== e && null !== e && (this.onDownCallback = e), void 0 !== i && null !== i && (this.onUpCallback = i), void 0 !== n && null !== n && (this.onPressCallback = n)
                },
                addKey: function(t) {
                    return this._keys[t] || (this._keys[t] = new i.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
                },
                addKeys: function(t) {
                    var e = {};
                    for (var i in t) e[i] = this.addKey(t[i]);
                    return e
                },
                removeKey: function(t) {
                    this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
                },
                createCursorKeys: function() {
                    return this.addKeys({
                        up: i.KeyCode.UP,
                        down: i.KeyCode.DOWN,
                        left: i.KeyCode.LEFT,
                        right: i.KeyCode.RIGHT
                    })
                },
                start: function() {
                    if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                        var t = this;
                        this._onKeyDown = function(e) {
                            return t.processKeyDown(e)
                        }, this._onKeyUp = function(e) {
                            return t.processKeyUp(e)
                        }, this._onKeyPress = function(e) {
                            return t.processKeyPress(e)
                        }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                    }
                },
                stop: function() {
                    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null
                },
                destroy: function() {
                    this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
                },
                addKeyCapture: function(t) {
                    if ("object" == typeof t)
                        for (var e in t) this._capture[t[e]] = !0;
                    else this._capture[t] = !0
                },
                removeKeyCapture: function(t) {
                    delete this._capture[t]
                },
                clearCaptures: function() {
                    this._capture = {}
                },
                update: function() {
                    for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
                },
                processKeyDown: function(t) {
                    if (this.event = t, this.game.input.enabled && this.enabled) {
                        var e = t.keyCode;
                        this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                    }
                },
                processKeyPress: function(t) {
                    this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
                },
                processKeyUp: function(t) {
                    if (this.event = t, this.game.input.enabled && this.enabled) {
                        var e = t.keyCode;
                        this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                    }
                },
                reset: function(t) {
                    void 0 === t && (t = !0), this.event = null;
                    for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
                },
                downDuration: function(t, e) {
                    return this._keys[t] ? this._keys[t].downDuration(e) : null
                },
                upDuration: function(t, e) {
                    return this._keys[t] ? this._keys[t].upDuration(e) : null
                },
                isDown: function(t) {
                    return this._keys[t] ? this._keys[t].isDown : null
                }
            }, Object.defineProperty(i.Keyboard.prototype, "lastChar", {
                get: function() {
                    return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode)
                }
            }), Object.defineProperty(i.Keyboard.prototype, "lastKey", {
                get: function() {
                    return this._keys[this._k]
                }
            }), i.Keyboard.prototype.constructor = i.Keyboard, i.KeyCode = {
                A: "A".charCodeAt(0),
                B: "B".charCodeAt(0),
                C: "C".charCodeAt(0),
                D: "D".charCodeAt(0),
                E: "E".charCodeAt(0),
                F: "F".charCodeAt(0),
                G: "G".charCodeAt(0),
                H: "H".charCodeAt(0),
                I: "I".charCodeAt(0),
                J: "J".charCodeAt(0),
                K: "K".charCodeAt(0),
                L: "L".charCodeAt(0),
                M: "M".charCodeAt(0),
                N: "N".charCodeAt(0),
                O: "O".charCodeAt(0),
                P: "P".charCodeAt(0),
                Q: "Q".charCodeAt(0),
                R: "R".charCodeAt(0),
                S: "S".charCodeAt(0),
                T: "T".charCodeAt(0),
                U: "U".charCodeAt(0),
                V: "V".charCodeAt(0),
                W: "W".charCodeAt(0),
                X: "X".charCodeAt(0),
                Y: "Y".charCodeAt(0),
                Z: "Z".charCodeAt(0),
                ZERO: "0".charCodeAt(0),
                ONE: "1".charCodeAt(0),
                TWO: "2".charCodeAt(0),
                THREE: "3".charCodeAt(0),
                FOUR: "4".charCodeAt(0),
                FIVE: "5".charCodeAt(0),
                SIX: "6".charCodeAt(0),
                SEVEN: "7".charCodeAt(0),
                EIGHT: "8".charCodeAt(0),
                NINE: "9".charCodeAt(0),
                NUMPAD_0: 96,
                NUMPAD_1: 97,
                NUMPAD_2: 98,
                NUMPAD_3: 99,
                NUMPAD_4: 100,
                NUMPAD_5: 101,
                NUMPAD_6: 102,
                NUMPAD_7: 103,
                NUMPAD_8: 104,
                NUMPAD_9: 105,
                NUMPAD_MULTIPLY: 106,
                NUMPAD_ADD: 107,
                NUMPAD_ENTER: 108,
                NUMPAD_SUBTRACT: 109,
                NUMPAD_DECIMAL: 110,
                NUMPAD_DIVIDE: 111,
                F1: 112,
                F2: 113,
                F3: 114,
                F4: 115,
                F5: 116,
                F6: 117,
                F7: 118,
                F8: 119,
                F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
                F13: 124,
                F14: 125,
                F15: 126,
                COLON: 186,
                EQUALS: 187,
                COMMA: 188,
                UNDERSCORE: 189,
                PERIOD: 190,
                QUESTION_MARK: 191,
                TILDE: 192,
                OPEN_BRACKET: 219,
                BACKWARD_SLASH: 220,
                CLOSED_BRACKET: 221,
                QUOTES: 222,
                BACKSPACE: 8,
                TAB: 9,
                CLEAR: 12,
                ENTER: 13,
                SHIFT: 16,
                CONTROL: 17,
                ALT: 18,
                CAPS_LOCK: 20,
                ESC: 27,
                SPACEBAR: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                PLUS: 43,
                MINUS: 44,
                INSERT: 45,
                DELETE: 46,
                HELP: 47,
                NUM_LOCK: 144
            }, i.KeyCode) i.KeyCode.hasOwnProperty(r) && !r.match(/[a-z]/) && (i.Keyboard[r] = i.KeyCode[r]);
        for (var o in i.Component = function() {}, i.Component.Angle = function() {}, i.Component.Angle.prototype = {
                angle: {
                    get: function() {
                        return i.Math.wrapAngle(i.Math.radToDeg(this.rotation))
                    },
                    set: function(t) {
                        this.rotation = i.Math.degToRad(i.Math.wrapAngle(t))
                    }
                }
            }, i.Component.Animation = function() {}, i.Component.Animation.prototype = {
                play: function(t, e, i, n) {
                    if (this.animations) return this.animations.play(t, e, i, n)
                }
            }, i.Component.AutoCull = function() {}, i.Component.AutoCull.prototype = {
                autoCull: !1,
                inCamera: {
                    get: function() {
                        return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                    }
                }
            }, i.Component.Bounds = function() {}, i.Component.Bounds.prototype = {
                offsetX: {
                    get: function() {
                        return this.anchor.x * this.width
                    }
                },
                offsetY: {
                    get: function() {
                        return this.anchor.y * this.height
                    }
                },
                centerX: {
                    get: function() {
                        return this.x - this.offsetX + .5 * this.width
                    },
                    set: function(t) {
                        this.x = t + this.offsetX - .5 * this.width
                    }
                },
                centerY: {
                    get: function() {
                        return this.y - this.offsetY + .5 * this.height
                    },
                    set: function(t) {
                        this.y = t + this.offsetY - .5 * this.height
                    }
                },
                left: {
                    get: function() {
                        return this.x - this.offsetX
                    },
                    set: function(t) {
                        this.x = t + this.offsetX
                    }
                },
                right: {
                    get: function() {
                        return this.x + this.width - this.offsetX
                    },
                    set: function(t) {
                        this.x = t - this.width + this.offsetX
                    }
                },
                top: {
                    get: function() {
                        return this.y - this.offsetY
                    },
                    set: function(t) {
                        this.y = t + this.offsetY
                    }
                },
                bottom: {
                    get: function() {
                        return this.y + this.height - this.offsetY
                    },
                    set: function(t) {
                        this.y = t - this.height + this.offsetY
                    }
                },
                alignIn: function(t, e, n, s) {
                    switch (void 0 === n && (n = 0), void 0 === s && (s = 0), e) {
                        default:
                            case i.TOP_LEFT:
                            this.left = t.left - n,
                        this.top = t.top - s;
                        break;
                        case i.TOP_CENTER:
                                this.centerX = t.centerX + n,
                            this.top = t.top - s;
                            break;
                        case i.TOP_RIGHT:
                                this.right = t.right + n,
                            this.top = t.top - s;
                            break;
                        case i.LEFT_CENTER:
                                this.left = t.left - n,
                            this.centerY = t.centerY + s;
                            break;
                        case i.CENTER:
                                this.centerX = t.centerX + n,
                            this.centerY = t.centerY + s;
                            break;
                        case i.RIGHT_CENTER:
                                this.right = t.right + n,
                            this.centerY = t.centerY + s;
                            break;
                        case i.BOTTOM_LEFT:
                                this.left = t.left - n,
                            this.bottom = t.bottom + s;
                            break;
                        case i.BOTTOM_CENTER:
                                this.centerX = t.centerX + n,
                            this.bottom = t.bottom + s;
                            break;
                        case i.BOTTOM_RIGHT:
                                this.right = t.right + n,
                            this.bottom = t.bottom + s
                    }
                    return this
                },
                alignTo: function(t, e, n, s) {
                    switch (void 0 === n && (n = 0), void 0 === s && (s = 0), e) {
                        default:
                            case i.TOP_LEFT:
                            this.left = t.left - n,
                        this.bottom = t.top - s;
                        break;
                        case i.TOP_CENTER:
                                this.centerX = t.centerX + n,
                            this.bottom = t.top - s;
                            break;
                        case i.TOP_RIGHT:
                                this.right = t.right + n,
                            this.bottom = t.top - s;
                            break;
                        case i.LEFT_TOP:
                                this.right = t.left - n,
                            this.top = t.top - s;
                            break;
                        case i.LEFT_CENTER:
                                this.right = t.left - n,
                            this.centerY = t.centerY + s;
                            break;
                        case i.LEFT_BOTTOM:
                                this.right = t.left - n,
                            this.bottom = t.bottom + s;
                            break;
                        case i.RIGHT_TOP:
                                this.left = t.right + n,
                            this.top = t.top - s;
                            break;
                        case i.RIGHT_CENTER:
                                this.left = t.right + n,
                            this.centerY = t.centerY + s;
                            break;
                        case i.RIGHT_BOTTOM:
                                this.left = t.right + n,
                            this.bottom = t.bottom + s;
                            break;
                        case i.BOTTOM_LEFT:
                                this.left = t.left - n,
                            this.top = t.bottom + s;
                            break;
                        case i.BOTTOM_CENTER:
                                this.centerX = t.centerX + n,
                            this.top = t.bottom + s;
                            break;
                        case i.BOTTOM_RIGHT:
                                this.right = t.right + n,
                            this.top = t.bottom + s
                    }
                    return this
                }
            }, i.Group.prototype.alignIn = i.Component.Bounds.prototype.alignIn, i.Group.prototype.alignTo = i.Component.Bounds.prototype.alignTo, i.Component.BringToTop = function() {}, i.Component.BringToTop.prototype.bringToTop = function() {
                return this.parent && this.parent.bringToTop(this), this
            }, i.Component.BringToTop.prototype.sendToBack = function() {
                return this.parent && this.parent.sendToBack(this), this
            }, i.Component.BringToTop.prototype.moveUp = function() {
                return this.parent && this.parent.moveUp(this), this
            }, i.Component.BringToTop.prototype.moveDown = function() {
                return this.parent && this.parent.moveDown(this), this
            }, i.Component.Core = function() {}, i.Component.Core.install = function(t) {
                i.Utils.mixinPrototype(this, i.Component.Core.prototype), this.components = {};
                for (var e = 0; e < t.length; e++) {
                    var n = t[e],
                        s = !1;
                    "Destroy" === n && (s = !0), i.Utils.mixinPrototype(this, i.Component[n].prototype, s), this.components[n] = !0
                }
            }, i.Component.Core.init = function(t, e, n, s, r) {
                this.game = t, this.key = s, this.data = {}, this.position.set(e, n), this.world = new i.Point(e, n), this.previousPosition = new i.Point(e, n), this.events = new i.Events(this), this._bounds = new i.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new i.AnimationManager(this)), this.components.LoadTexture && null !== s && this.loadTexture(s, r), this.components.FixedToCamera && (this.cameraOffset = new i.Point(e, n))
            }, i.Component.Core.preUpdate = function() {
                if (!this.pendingDestroy) {
                    if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                    this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
                    for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                    return !0
                }
                this.destroy()
            }, i.Component.Core.prototype = {
                game: null,
                name: "",
                data: {},
                components: {},
                z: 0,
                events: void 0,
                animations: void 0,
                key: "",
                world: null,
                debug: !1,
                previousPosition: null,
                previousRotation: 0,
                renderOrderID: 0,
                fresh: !0,
                pendingDestroy: !1,
                _bounds: null,
                _exists: !0,
                exists: {
                    get: function() {
                        return this._exists
                    },
                    set: function(t) {
                        t ? (this._exists = !0, this.body && this.body.type === i.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === i.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                    }
                },
                update: function() {},
                postUpdate: function() {
                    this.customRender && this.key.render(), this.components.PhysicsBody && i.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && i.Component.FixedToCamera.postUpdate.call(this);
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                }
            }, i.Component.Crop = function() {}, i.Component.Crop.prototype = {
                cropRect: null,
                _crop: null,
                crop: function(t, e) {
                    void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new i.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
                },
                updateCrop: function() {
                    if (this.cropRect) {
                        var t = this.texture.crop.x,
                            e = this.texture.crop.y,
                            n = this.texture.crop.width,
                            s = this.texture.crop.height;
                        this._crop = i.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                        var r = Math.max(this._frame.x, this._crop.x),
                            o = Math.max(this._frame.y, this._crop.y),
                            a = Math.min(this._frame.right, this._crop.right) - r,
                            h = Math.min(this._frame.bottom, this._crop.bottom) - o;
                        this.texture.crop.x = r, this.texture.crop.y = o, this.texture.crop.width = a, this.texture.crop.height = h, this.texture.frame.width = Math.min(a, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === r && e === o && n === a && s === h || (this.texture.requiresReTint = !0)
                    }
                }
            }, i.Component.Delta = function() {}, i.Component.Delta.prototype = {
                deltaX: {
                    get: function() {
                        return this.world.x - this.previousPosition.x
                    }
                },
                deltaY: {
                    get: function() {
                        return this.world.y - this.previousPosition.y
                    }
                },
                deltaZ: {
                    get: function() {
                        return this.rotation - this.previousRotation
                    }
                }
            }, i.Component.Destroy = function() {}, i.Component.Destroy.prototype = {
                destroyPhase: !1,
                destroy: function(t, e) {
                    if (null !== this.game && !this.destroyPhase) {
                        void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof i.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                        var n = this.children.length;
                        if (t)
                            for (; n--;) this.children[n].destroy(t);
                        else
                            for (; n--;) this.removeChild(this.children[n]);
                        this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), i.Video && this.key instanceof i.Video && this.key.onChangeSource.remove(this.resizeFrame, this), i.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                    }
                }
            }, i.Events = function(t) {
                this.parent = t
            }, i.Events.prototype = {
                destroy: function() {
                    this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
                },
                onAddedToGroup: null,
                onRemovedFromGroup: null,
                onRemovedFromWorld: null,
                onDestroy: null,
                onKilled: null,
                onRevived: null,
                onOutOfBounds: null,
                onEnterBounds: null,
                onInputOver: null,
                onInputOut: null,
                onInputDown: null,
                onInputUp: null,
                onDragStart: null,
                onDragUpdate: null,
                onDragStop: null,
                onAnimationStart: null,
                onAnimationComplete: null,
                onAnimationLoop: null
            }, i.Events.prototype.constructor = i.Events, i.Events.prototype) i.Events.prototype.hasOwnProperty(o) && 0 === o.indexOf("on") && null === i.Events.prototype[o] && function(t, e) {
            "use strict";
            Object.defineProperty(i.Events.prototype, t, {
                get: function() {
                    return this[e] || (this[e] = new i.Signal)
                }
            }), i.Events.prototype[t + "$dispatch"] = function() {
                return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
            }
        }(o, "_" + o);
        i.Component.FixedToCamera = function() {}, i.Component.FixedToCamera.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
        }, i.Component.FixedToCamera.prototype = {
            _fixedToCamera: !1,
            fixedToCamera: {
                get: function() {
                    return this._fixedToCamera
                },
                set: function(t) {
                    t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                }
            },
            cameraOffset: new i.Point
        }, i.Component.Health = function() {}, i.Component.Health.prototype = {
            health: 1,
            maxHealth: 100,
            damage: function(t) {
                return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
            },
            setHealth: function(t) {
                return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
            },
            heal: function(t) {
                return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
            }
        }, i.Component.InCamera = function() {}, i.Component.InCamera.prototype = {
            inCamera: {
                get: function() {
                    return this.game.world.camera.view.intersects(this._bounds)
                }
            }
        }, i.Component.InputEnabled = function() {}, i.Component.InputEnabled.prototype = {
            input: null,
            inputEnabled: {
                get: function() {
                    return this.input && this.input.enabled
                },
                set: function(t) {
                    t ? null === this.input ? (this.input = new i.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                }
            }
        }, i.Component.InWorld = function() {}, i.Component.InWorld.preUpdate = function() {
            if (this.autoCull || this.checkWorldBounds) {
                if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
            }
            return !0
        }, i.Component.InWorld.prototype = {
            checkWorldBounds: !1,
            outOfBoundsKill: !1,
            outOfCameraBoundsKill: !1,
            _outOfBoundsFired: !1,
            inWorld: {
                get: function() {
                    return this.game.world.bounds.intersects(this.getBounds())
                }
            }
        }, i.Component.LifeSpan = function() {}, i.Component.LifeSpan.preUpdate = function() {
            return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1)
        }, i.Component.LifeSpan.prototype = {
            alive: !0,
            lifespan: 0,
            revive: function(t) {
                return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
            },
            kill: function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
            }
        }, i.Component.LoadTexture = function() {}, i.Component.LoadTexture.prototype = {
            customRender: !1,
            _frame: null,
            loadTexture: function(t, e, n) {
                t === i.PENDING_ATLAS ? (t = e, e = 0) : e = e || 0, (n || void 0 === n) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                var s = this.game.cache,
                    r = !0,
                    o = !this.texture.baseTexture.scaleMode;
                if (i.RenderTexture && t instanceof i.RenderTexture) this.key = t.key, this.setTexture(t);
                else if (i.BitmapData && t instanceof i.BitmapData) this.customRender = !0, this.setTexture(t.texture), r = s.hasFrameData(t.key, i.Cache.BITMAPDATA) ? !this.animations.loadFrameData(s.getFrameData(t.key, i.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                else if (i.Video && t instanceof i.Video) {
                    this.customRender = !0;
                    var a = t.texture.valid;
                    this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = a
                } else if (i.Tilemap && t instanceof i.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                else if (t instanceof PIXI.Texture) this.setTexture(t);
                else {
                    var h = s.getImage(t, !0);
                    this.key = h.key, this.setTexture(new PIXI.Texture(h.base)), this.texture.baseTexture.skipRender = "__default" === t, r = !this.animations.loadFrameData(h.frameData, e)
                }
                r && (this._frame = i.Rectangle.clone(this.texture.frame)), o || (this.texture.baseTexture.scaleMode = 1)
            },
            setFrame: function(t) {
                this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                    x: t.spriteSourceSizeX,
                    y: t.spriteSourceSizeY,
                    width: t.sourceSizeW,
                    height: t.sourceSizeH
                }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
            },
            resizeFrame: function(t, e, i) {
                this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
            },
            resetFrame: function() {
                this._frame && this.setFrame(this._frame)
            },
            frame: {
                get: function() {
                    return this.animations.frame
                },
                set: function(t) {
                    this.animations.frame = t
                }
            },
            frameName: {
                get: function() {
                    return this.animations.frameName
                },
                set: function(t) {
                    this.animations.frameName = t
                }
            }
        }, i.Component.Overlap = function() {}, i.Component.Overlap.prototype = {
            overlap: function(t) {
                return i.Rectangle.intersects(this.getBounds(), t.getBounds())
            }
        }, i.Component.PhysicsBody = function() {}, i.Component.PhysicsBody.preUpdate = function() {
            return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
        }, i.Component.PhysicsBody.postUpdate = function() {
            this.exists && this.body && this.body.postUpdate()
        }, i.Component.PhysicsBody.prototype = {
            body: null,
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                }
            }
        }, i.Component.Reset = function() {}, i.Component.Reset.prototype.reset = function(t, e, i) {
            return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
        }, i.Component.ScaleMinMax = function() {}, i.Component.ScaleMinMax.prototype = {
            transformCallback: null,
            transformCallbackContext: this,
            scaleMin: null,
            scaleMax: null,
            checkTransform: function(t) {
                this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
            },
            setScaleMinMax: function(t, e, n, s) {
                void 0 === e ? e = n = s = t : void 0 === n && (n = s = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new i.Point(t, e), null === n ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(n, s) : this.scaleMax = new i.Point(n, s), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
            }
        }, i.Component.Smoothed = function() {}, i.Component.Smoothed.prototype = {
            smoothed: {
                get: function() {
                    return !this.texture.baseTexture.scaleMode
                },
                set: function(t) {
                    t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                }
            }
        }, i.GameObjectFactory = function(t) {
            this.game = t, this.world = this.game.world
        }, i.GameObjectFactory.prototype = {
            existing: function(t) {
                return this.world.add(t)
            },
            weapon: function(t, e, n, s) {
                var r = this.game.plugins.add(i.Weapon);
                return r.createBullets(t, e, n, s), r
            },
            image: function(t, e, n, s, r) {
                return void 0 === r && (r = this.world), r.add(new i.Image(this.game, t, e, n, s))
            },
            sprite: function(t, e, i, n, s) {
                return void 0 === s && (s = this.world), s.create(t, e, i, n)
            },
            creature: function(t, e, n, s, r) {
                void 0 === r && (r = this.world);
                var o = new i.Creature(this.game, t, e, n, s);
                return r.add(o), o
            },
            tween: function(t) {
                return this.game.tweens.create(t)
            },
            group: function(t, e, n, s, r) {
                return new i.Group(this.game, t, e, n, s, r)
            },
            physicsGroup: function(t, e, n, s) {
                return new i.Group(this.game, e, n, s, !0, t)
            },
            spriteBatch: function(t, e, n) {
                return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === n && (n = !1), new i.SpriteBatch(this.game, t, e, n)
            },
            audio: function(t, e, i, n) {
                return this.game.sound.add(t, e, i, n)
            },
            sound: function(t, e, i, n) {
                return this.game.sound.add(t, e, i, n)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            tileSprite: function(t, e, n, s, r, o, a) {
                return void 0 === a && (a = this.world), a.add(new i.TileSprite(this.game, t, e, n, s, r, o))
            },
            rope: function(t, e, n, s, r, o) {
                return void 0 === o && (o = this.world), o.add(new i.Rope(this.game, t, e, n, s, r))
            },
            text: function(t, e, n, s, r) {
                return void 0 === r && (r = this.world), r.add(new i.Text(this.game, t, e, n, s))
            },
            button: function(t, e, n, s, r, o, a, h, l, c) {
                return void 0 === c && (c = this.world), c.add(new i.Button(this.game, t, e, n, s, r, o, a, h, l))
            },
            graphics: function(t, e, n) {
                return void 0 === n && (n = this.world), n.add(new i.Graphics(this.game, t, e))
            },
            emitter: function(t, e, n) {
                return this.game.particles.add(new i.Particles.Arcade.Emitter(this.game, t, e, n))
            },
            retroFont: function(t, e, n, s, r, o, a, h, l) {
                return new i.RetroFont(this.game, t, e, n, s, r, o, a, h, l)
            },
            bitmapText: function(t, e, n, s, r, o) {
                return void 0 === o && (o = this.world), o.add(new i.BitmapText(this.game, t, e, n, s, r))
            },
            tilemap: function(t, e, n, s, r) {
                return new i.Tilemap(this.game, t, e, n, s, r)
            },
            renderTexture: function(t, e, n, s) {
                void 0 !== n && "" !== n || (n = this.game.rnd.uuid()), void 0 === s && (s = !1);
                var r = new i.RenderTexture(this.game, t, e, n);
                return s && this.game.cache.addRenderTexture(n, r), r
            },
            video: function(t, e) {
                return new i.Video(this.game, t, e)
            },
            bitmapData: function(t, e, n, s) {
                void 0 === s && (s = !1), void 0 !== n && "" !== n || (n = this.game.rnd.uuid());
                var r = new i.BitmapData(this.game, n, t, e);
                return s && this.game.cache.addBitmapData(n, r), r
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1);
                return (t = new i.Filter[t](this.game)).init.apply(t, e), t
            },
            plugin: function(t) {
                return this.game.plugins.add(t)
            }
        }, i.GameObjectFactory.prototype.constructor = i.GameObjectFactory, i.GameObjectCreator = function(t) {
            this.game = t, this.world = this.game.world
        }, i.GameObjectCreator.prototype = {
            image: function(t, e, n, s) {
                return new i.Image(this.game, t, e, n, s)
            },
            sprite: function(t, e, n, s) {
                return new i.Sprite(this.game, t, e, n, s)
            },
            tween: function(t) {
                return new i.Tween(t, this.game, this.game.tweens)
            },
            group: function(t, e, n, s, r) {
                return new i.Group(this.game, t, e, n, s, r)
            },
            spriteBatch: function(t, e, n) {
                return void 0 === e && (e = "group"), void 0 === n && (n = !1), new i.SpriteBatch(this.game, t, e, n)
            },
            audio: function(t, e, i, n) {
                return this.game.sound.add(t, e, i, n)
            },
            audioSprite: function(t) {
                return this.game.sound.addSprite(t)
            },
            sound: function(t, e, i, n) {
                return this.game.sound.add(t, e, i, n)
            },
            tileSprite: function(t, e, n, s, r, o) {
                return new i.TileSprite(this.game, t, e, n, s, r, o)
            },
            rope: function(t, e, n, s, r) {
                return new i.Rope(this.game, t, e, n, s, r)
            },
            text: function(t, e, n, s) {
                return new i.Text(this.game, t, e, n, s)
            },
            button: function(t, e, n, s, r, o, a, h, l) {
                return new i.Button(this.game, t, e, n, s, r, o, a, h, l)
            },
            graphics: function(t, e) {
                return new i.Graphics(this.game, t, e)
            },
            emitter: function(t, e, n) {
                return new i.Particles.Arcade.Emitter(this.game, t, e, n)
            },
            retroFont: function(t, e, n, s, r, o, a, h, l) {
                return new i.RetroFont(this.game, t, e, n, s, r, o, a, h, l)
            },
            bitmapText: function(t, e, n, s, r, o) {
                return new i.BitmapText(this.game, t, e, n, s, r, o)
            },
            tilemap: function(t, e, n, s, r) {
                return new i.Tilemap(this.game, t, e, n, s, r)
            },
            renderTexture: function(t, e, n, s) {
                void 0 !== n && "" !== n || (n = this.game.rnd.uuid()), void 0 === s && (s = !1);
                var r = new i.RenderTexture(this.game, t, e, n);
                return s && this.game.cache.addRenderTexture(n, r), r
            },
            bitmapData: function(t, e, n, s) {
                void 0 === s && (s = !1), void 0 !== n && "" !== n || (n = this.game.rnd.uuid());
                var r = new i.BitmapData(this.game, n, t, e);
                return s && this.game.cache.addBitmapData(n, r), r
            },
            filter: function(t) {
                var e = Array.prototype.slice.call(arguments, 1);
                return (t = new i.Filter[t](this.game)).init.apply(t, e), t
            }
        }, i.GameObjectCreator.prototype.constructor = i.GameObjectCreator, i.Sprite = function(t, e, n, s, r) {
            e = e || 0, n = n || 0, s = s || null, r = r || null, this.type = i.SPRITE, this.physicsType = i.SPRITE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, n, s, r)
        }, i.Sprite.prototype = Object.create(PIXI.Sprite.prototype), i.Sprite.prototype.constructor = i.Sprite, i.Component.Core.install.call(i.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Sprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Sprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Sprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Sprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Sprite.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Image = function(t, e, n, s, r) {
            e = e || 0, n = n || 0, s = s || null, r = r || null, this.type = i.IMAGE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, n, s, r)
        }, i.Image.prototype = Object.create(PIXI.Sprite.prototype), i.Image.prototype.constructor = i.Image, i.Component.Core.install.call(i.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), i.Image.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Image.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Image.prototype.preUpdate = function() {
            return !!this.preUpdateInWorld() && this.preUpdateCore()
        }, i.Button = function(t, e, n, s, r, o, a, h, l, c) {
            e = e || 0, n = n || 0, s = s || null, r = r || null, o = o || this, i.Image.call(this, t, e, n, s, h), this.type = i.BUTTON, this.physicsType = i.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new i.Signal, this.onInputOut = new i.Signal, this.onInputDown = new i.Signal, this.onInputUp = new i.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = i.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(a, h, l, c), null !== r && this.onInputUp.add(r, o), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
        }, i.Button.prototype = Object.create(i.Image.prototype), i.Button.prototype.constructor = i.Button;
        i.Button.prototype.clearFrames = function() {
            this.setFrames(null, null, null, null)
        }, i.Button.prototype.removedFromWorld = function() {
            this.inputEnabled = !1
        }, i.Button.prototype.setStateFrame = function(t, e, i) {
            var n = "_on" + t + "Frame";
            null !== e ? (this[n] = e, i && this.changeStateFrame(t)) : this[n] = null
        }, i.Button.prototype.changeStateFrame = function(t) {
            if (this.freezeFrames) return !1;
            var e = this["_on" + t + "Frame"];
            return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0)
        }, i.Button.prototype.setFrames = function(t, e, i, n) {
            this.setStateFrame("Over", t, this.input.pointerOver()), this.setStateFrame("Out", e, !this.input.pointerOver()), this.setStateFrame("Down", i, this.input.pointerDown()), this.setStateFrame("Up", n, this.input.pointerUp())
        }, i.Button.prototype.setStateSound = function(t, e, n) {
            var s = "on" + t + "Sound",
                r = "on" + t + "SoundMarker";
            e instanceof i.Sound || e instanceof i.AudioSprite ? (this[s] = e, this[r] = "string" == typeof n ? n : "") : (this[s] = null, this[r] = "")
        }, i.Button.prototype.playStateSound = function(t) {
            var e = this["on" + t + "Sound"];
            if (e) {
                var i = this["on" + t + "SoundMarker"];
                return e.play(i), !0
            }
            return !1
        }, i.Button.prototype.setSounds = function(t, e, i, n, s, r, o, a) {
            this.setStateSound("Over", t, e), this.setStateSound("Out", s, r), this.setStateSound("Down", i, n), this.setStateSound("Up", o, a)
        }, i.Button.prototype.setOverSound = function(t, e) {
            this.setStateSound("Over", t, e)
        }, i.Button.prototype.setOutSound = function(t, e) {
            this.setStateSound("Out", t, e)
        }, i.Button.prototype.setDownSound = function(t, e) {
            this.setStateSound("Down", t, e)
        }, i.Button.prototype.setUpSound = function(t, e) {
            this.setStateSound("Up", t, e)
        }, i.Button.prototype.onInputOverHandler = function(t, e) {
            e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame("Over"), this.onOverMouseOnly && !e.isMouse || (this.playStateSound("Over"), this.onInputOver && this.onInputOver.dispatch(this, e)))
        }, i.Button.prototype.onInputOutHandler = function(t, e) {
            this.changeStateFrame("Out"), this.playStateSound("Out"), this.onInputOut && this.onInputOut.dispatch(this, e)
        }, i.Button.prototype.onInputDownHandler = function(t, e) {
            this.changeStateFrame("Down"), this.playStateSound("Down"), this.onInputDown && this.onInputDown.dispatch(this, e)
        }, i.Button.prototype.onInputUpHandler = function(t, e, i) {
            (this.playStateSound("Up"), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames) || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame("Out") : this.changeStateFrame("Up") || (i ? this.changeStateFrame("Over") : this.changeStateFrame("Out")))
        }, i.SpriteBatch = function(t, e, n, s) {
            void 0 !== e && null !== e || (e = t.world), PIXI.SpriteBatch.call(this), i.Group.call(this, t, e, n, s), this.type = i.SPRITEBATCH
        }, i.SpriteBatch.prototype = i.Utils.extend(!0, i.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, i.Group.prototype), i.SpriteBatch.prototype.constructor = i.SpriteBatch, i.BitmapData = function(t, e, n, s, r) {
            void 0 !== n && 0 !== n || (n = 256), void 0 !== s && 0 !== s || (s = 256), void 0 === r && (r = !1), this.game = t, this.key = e, this.width = n, this.height = s, this.canvas = i.Canvas.create(this, n, s, null, r), this.context = this.canvas.getContext("2d", {
                alpha: !0
            }), this.ctx = this.context, this.smoothProperty = t.renderType === i.CANVAS ? t.renderer.renderSession.smoothProperty : i.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, n, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new i.FrameData, this.textureFrame = this.frameData.addFrame(new i.Frame(0, 0, 0, n, s, "bitmapData")), this.texture.frame = this.textureFrame, this.type = i.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new i.Point, this._size = new i.Point, this._scale = new i.Point, this._rotate = 0, this._alpha = {
                prev: 1,
                current: 1
            }, this._anchor = new i.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new i.Circle, this._swapCanvas = void 0
        }, i.BitmapData.prototype = {
            move: function(t, e, i) {
                return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
            },
            moveH: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas.getContext("2d"),
                    n = this.height,
                    s = this.canvas;
                if (i.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    var r = this.width - t;
                    e && i.drawImage(s, 0, 0, t, n, r, 0, t, n), i.drawImage(s, t, 0, r, n, 0, 0, r, n)
                } else {
                    r = this.width - t;
                    e && i.drawImage(s, r, 0, t, n, 0, 0, t, n), i.drawImage(s, 0, 0, r, n, t, 0, r, n)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            moveV: function(t, e) {
                void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                var i = this._swapCanvas.getContext("2d"),
                    n = this.width,
                    s = this.canvas;
                if (i.clearRect(0, 0, this.width, this.height), t < 0) {
                    t = Math.abs(t);
                    var r = this.height - t;
                    e && i.drawImage(s, 0, 0, n, t, 0, r, n, t), i.drawImage(s, 0, t, n, r, 0, 0, n, r)
                } else {
                    r = this.height - t;
                    e && i.drawImage(s, 0, r, n, t, 0, 0, n, t), i.drawImage(s, 0, 0, n, r, 0, t, n, r)
                }
                return this.clear(), this.copy(this._swapCanvas)
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            load: function(t) {
                if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
            },
            clear: function(t, e, i, n) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = this.height), this.context.clearRect(t, e, i, n), this.dirty = !0, this
            },
            fill: function(t, e, i, n) {
                return void 0 === n && (n = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + n + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
            },
            generateTexture: function(t) {
                var e = new Image;
                e.src = this.canvas.toDataURL("image/png");
                var i = this.game.cache.addImage(t, "", e);
                return new PIXI.Texture(i.base)
            },
            resize: function(t, e) {
                return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
            },
            update: function(t, e, i, n) {
                return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === n && (n = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, n), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
            },
            processPixelRGB: function(t, e, n, s, r, o) {
                void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = this.width), void 0 === o && (o = this.height);
                for (var a = n + r, h = s + o, l = i.Color.createColor(), c = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    }, u = !1, d = s; d < h; d++)
                    for (var p = n; p < a; p++) i.Color.unpackPixel(this.getPixel32(p, d), l), !1 !== (c = t.call(e, l, p, d)) && null !== c && void 0 !== c && (this.setPixel32(p, d, c.r, c.g, c.b, c.a, !1), u = !0);
                return u && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            processPixel: function(t, e, i, n, s, r) {
                void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.width), void 0 === r && (r = this.height);
                for (var o = i + s, a = n + r, h = 0, l = 0, c = !1, u = n; u < a; u++)
                    for (var d = i; d < o; d++) h = this.getPixel32(d, u), (l = t.call(e, h, d, u)) !== h && (this.pixels[u * this.width + d] = l, c = !0);
                return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
            },
            replaceRGB: function(t, e, n, s, r, o, a, h, l) {
                var c = 0,
                    u = 0,
                    d = this.width,
                    p = this.height,
                    f = i.Color.packPixel(t, e, n, s);
                void 0 !== l && l instanceof i.Rectangle && (c = l.x, u = l.y, d = l.width, p = l.height);
                for (var g = 0; g < p; g++)
                    for (var m = 0; m < d; m++) this.getPixel32(c + m, u + g) === f && this.setPixel32(c + m, u + g, r, o, a, h, !1);
                return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
            },
            setHSL: function(t, e, n, s) {
                var r = t || 0 === t,
                    o = e || 0 === e,
                    a = n || 0 === n;
                if (r || o || a) {
                    void 0 === s && (s = new i.Rectangle(0, 0, this.width, this.height));
                    for (var h = i.Color.createColor(), l = s.y; l < s.bottom; l++)
                        for (var c = s.x; c < s.right; c++) i.Color.unpackPixel(this.getPixel32(c, l), h, !0), r && (h.h = t), o && (h.s = e), a && (h.l = n), i.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(c, l, h.r, h.g, h.b, h.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            shiftHSL: function(t, e, n, s) {
                if (void 0 !== t && null !== t || (t = !1), void 0 !== e && null !== e || (e = !1), void 0 !== n && null !== n || (n = !1), t || e || n) {
                    void 0 === s && (s = new i.Rectangle(0, 0, this.width, this.height));
                    for (var r = i.Color.createColor(), o = s.y; o < s.bottom; o++)
                        for (var a = s.x; a < s.right; a++) i.Color.unpackPixel(this.getPixel32(a, o), r, !0), t && (r.h = this.game.math.wrap(r.h + t, 0, 1)), e && (r.s = this.game.math.clamp(r.s + e, 0, 1)), n && (r.l = this.game.math.clamp(r.l + n, 0, 1)), i.Color.HSLtoRGB(r.h, r.s, r.l, r), this.setPixel32(a, o, r.r, r.g, r.b, r.a, !1);
                    return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                }
            },
            setPixel32: function(t, e, n, s, r, o, a) {
                return void 0 === a && (a = !0), t >= 0 && t <= this.width && e >= 0 && e <= this.height && (i.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = o << 24 | r << 16 | s << 8 | n : this.pixels[e * this.width + t] = n << 24 | s << 16 | r << 8 | o, a && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
            },
            setPixel: function(t, e, i, n, s, r) {
                return this.setPixel32(t, e, i, n, s, 255, r)
            },
            getPixel: function(t, e, n) {
                n || (n = i.Color.createColor());
                var s = ~~(t + e * this.width);
                return s *= 4, n.r = this.data[s], n.g = this.data[++s], n.b = this.data[++s], n.a = this.data[++s], n
            },
            getPixel32: function(t, e) {
                if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t]
            },
            getPixelRGB: function(t, e, n, s, r) {
                return i.Color.unpackPixel(this.getPixel32(t, e), n, s, r)
            },
            getPixels: function(t) {
                return this.context.getImageData(t.x, t.y, t.width, t.height)
            },
            getFirstPixel: function(t) {
                void 0 === t && (t = 0);
                var e = i.Color.createColor(),
                    n = 0,
                    s = 0,
                    r = 1,
                    o = !1;
                1 === t ? (r = -1, s = this.height) : 3 === t && (r = -1, n = this.width);
                do {
                    i.Color.unpackPixel(this.getPixel32(n, s), e), 0 === t || 1 === t ? ++n === this.width && (n = 0, ((s += r) >= this.height || s <= 0) && (o = !0)) : 2 !== t && 3 !== t || ++s === this.height && (s = 0, ((n += r) >= this.width || n <= 0) && (o = !0))
                } while (0 === e.a && !o);
                return e.x = n, e.y = s, e
            },
            getBounds: function(t) {
                return void 0 === t && (t = new i.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t)
            },
            addToWorld: function(t, e, i, n, s, r) {
                s = s || 1, r = r || 1;
                var o = this.game.add.image(t, e, this);
                return o.anchor.set(i, n), o.scale.set(s, r), o
            },
            copy: function(t, e, n, s, r, o, a, h, l, c, u, d, p, f, g, m, y) {
                if (void 0 !== t && null !== t || (t = this), (t instanceof i.RenderTexture || t instanceof PIXI.RenderTexture) && (t = t.getCanvas()), this._image = t, t instanceof i.Sprite || t instanceof i.Image || t instanceof i.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, void 0 !== o && null !== o || (o = t.x), void 0 !== a && null !== a || (a = t.y), t.texture.trim && (o += t.texture.trim.x - t.anchor.x * t.texture.trim.width, a += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                else {
                    if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof i.BitmapData) this._image = t.canvas;
                    else if ("string" == typeof t) {
                        if (null === (t = this.game.cache.getImage(t))) return;
                        this._image = t
                    }
                    this._size.set(this._image.width, this._image.height)
                }
                if (void 0 !== e && null !== e || (e = 0), void 0 !== n && null !== n || (n = 0), s && (this._size.x = s), r && (this._size.y = r), void 0 !== o && null !== o || (o = e), void 0 !== a && null !== a || (a = n), void 0 !== h && null !== h || (h = this._size.x), void 0 !== l && null !== l || (l = this._size.y), "number" == typeof c && (this._rotate = c), "number" == typeof u && (this._anchor.x = u), "number" == typeof d && (this._anchor.y = d), "number" == typeof p && (this._scale.x = p), "number" == typeof f && (this._scale.y = f), "number" == typeof g && (this._alpha.current = g), void 0 === m && (m = null), void 0 === y && (y = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                    var v = this.context;
                    return this._alpha.prev = v.globalAlpha, v.save(), v.globalAlpha = this._alpha.current, m && (this.op = m), y && (o |= 0, a |= 0), v.translate(o, a), v.scale(this._scale.x, this._scale.y), v.rotate(this._rotate), v.drawImage(this._image, this._pos.x + e, this._pos.y + n, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l), v.restore(), v.globalAlpha = this._alpha.prev, this.dirty = !0, this
                }
            },
            copyTransform: function(t, e, n) {
                if (void 0 === e && (e = null), void 0 === n && (n = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this;
                var s = t.worldTransform;
                if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === s.a || 0 === s.d || 0 === this._size.x || 0 === this._size.y) return this;
                t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                var r = s.tx,
                    o = s.ty;
                t.texture.trim && (r += t.texture.trim.x - t.anchor.x * t.texture.trim.width, o += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), n && (r |= 0, o |= 0);
                var a = this.context;
                return this._alpha.prev = a.globalAlpha, a.save(), a.globalAlpha = this._alpha.current, e && (this.op = e), a[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, a.setTransform(s.a, s.b, s.c, s.d, r, o), a.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), a.restore(), a.globalAlpha = this._alpha.prev, this.dirty = !0, this
            },
            copyRect: function(t, e, i, n, s, r, o) {
                return this.copy(t, e.x, e.y, e.width, e.height, i, n, e.width, e.height, 0, 0, 0, 1, 1, s, r, o)
            },
            draw: function(t, e, i, n, s, r, o) {
                return this.copy(t, null, null, null, null, e, i, n, s, null, null, null, null, null, null, r, o)
            },
            drawGroup: function(t, e, i) {
                return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this
            },
            drawGroupProxy: function(t, e, n) {
                if (t.hasOwnProperty("texture") && this.copyTransform(t, e, n), t.type === i.GROUP && t.exists) this.drawGroup(t, e, n);
                else if (t.hasOwnProperty("children") && t.children.length > 0)
                    for (var s = 0; s < t.children.length; s++) t.children[s].exists && this.copyTransform(t.children[s], e, n)
            },
            drawFull: function(t, e, n) {
                if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this;
                if (t.type !== i.GROUP && t.type !== i.EMITTER && t.type !== i.BITMAPTEXT)
                    if (t.type === i.GRAPHICS) {
                        var s = t.getBounds();
                        this.ctx.save(), this.ctx.translate(s.x, s.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()
                    } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, n);
                if (t.children)
                    for (var r = 0; r < t.children.length; r++) this.drawFull(t.children[r], e, n);
                return this
            },
            shadow: function(t, e, i, n) {
                var s = this.context;
                return void 0 === t || null === t ? s.shadowColor = "rgba(0,0,0,0)" : (s.shadowColor = t, s.shadowBlur = e || 5, s.shadowOffsetX = i || 10, s.shadowOffsetY = n || 10), this
            },
            alphaMask: function(t, e, i, n) {
                return void 0 === n || null === n ? this.draw(e).blendSourceAtop() : this.draw(e, n.x, n.y, n.width, n.height).blendSourceAtop(), void 0 === i || null === i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this
            },
            extract: function(t, e, i, n, s, r, o, a, h) {
                return void 0 === s && (s = 255), void 0 === r && (r = !1), void 0 === o && (o = e), void 0 === a && (a = i), void 0 === h && (h = n), r && t.resize(this.width, this.height), this.processPixelRGB(function(r, l, c) {
                    return r.r === e && r.g === i && r.b === n && t.setPixel32(l, c, o, a, h, s, !1), !1
                }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
            },
            rect: function(t, e, i, n, s) {
                return void 0 !== s && (this.context.fillStyle = s), this.context.fillRect(t, e, i, n), this
            },
            text: function(t, e, i, n, s, r) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = "14px Courier"), void 0 === s && (s = "rgb(255,255,255)"), void 0 === r && (r = !0);
                var o = this.context,
                    a = o.font;
                return o.font = n, r && (o.fillStyle = "rgb(0,0,0)", o.fillText(t, e + 1, i + 1)), o.fillStyle = s, o.fillText(t, e, i), o.font = a, this
            },
            circle: function(t, e, i, n) {
                var s = this.context;
                return void 0 !== n && (s.fillStyle = n), s.beginPath(), s.arc(t, e, i, 0, 2 * Math.PI, !1), s.closePath(), s.fill(), this
            },
            line: function(t, e, i, n, s, r) {
                void 0 === s && (s = "#fff"), void 0 === r && (r = 1);
                var o = this.context;
                return o.beginPath(), o.moveTo(t, e), o.lineTo(i, n), o.lineWidth = r, o.strokeStyle = s, o.stroke(), o.closePath(), this
            },
            textureLine: function(t, e, n) {
                if (void 0 === n && (n = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) {
                    var s = t.length;
                    "no-repeat" === n && s > e.width && (s = e.width);
                    var r = this.context;
                    return r.fillStyle = r.createPattern(e, n), this._circle = new i.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), r.save(), r.translate(this._pos.x, this._pos.y), r.rotate(t.angle), r.fillRect(0, 0, s, e.height), r.restore(), this.dirty = !0, this
                }
            },
            render: function() {
                return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
            },
            destroy: function() {
                this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this)
            },
            blendReset: function() {
                return this.op = "source-over", this
            },
            blendSourceOver: function() {
                return this.op = "source-over", this
            },
            blendSourceIn: function() {
                return this.op = "source-in", this
            },
            blendSourceOut: function() {
                return this.op = "source-out", this
            },
            blendSourceAtop: function() {
                return this.op = "source-atop", this
            },
            blendDestinationOver: function() {
                return this.op = "destination-over", this
            },
            blendDestinationIn: function() {
                return this.op = "destination-in", this
            },
            blendDestinationOut: function() {
                return this.op = "destination-out", this
            },
            blendDestinationAtop: function() {
                return this.op = "destination-atop", this
            },
            blendXor: function() {
                return this.op = "xor", this
            },
            blendAdd: function() {
                return this.op = "lighter", this
            },
            blendMultiply: function() {
                return this.op = "multiply", this
            },
            blendScreen: function() {
                return this.op = "screen", this
            },
            blendOverlay: function() {
                return this.op = "overlay", this
            },
            blendDarken: function() {
                return this.op = "darken", this
            },
            blendLighten: function() {
                return this.op = "lighten", this
            },
            blendColorDodge: function() {
                return this.op = "color-dodge", this
            },
            blendColorBurn: function() {
                return this.op = "color-burn", this
            },
            blendHardLight: function() {
                return this.op = "hard-light", this
            },
            blendSoftLight: function() {
                return this.op = "soft-light", this
            },
            blendDifference: function() {
                return this.op = "difference", this
            },
            blendExclusion: function() {
                return this.op = "exclusion", this
            },
            blendHue: function() {
                return this.op = "hue", this
            },
            blendSaturation: function() {
                return this.op = "saturation", this
            },
            blendColor: function() {
                return this.op = "color", this
            },
            blendLuminosity: function() {
                return this.op = "luminosity", this
            }
        }, Object.defineProperty(i.BitmapData.prototype, "smoothed", {
            get: function() {
                i.Canvas.getSmoothingEnabled(this.context)
            },
            set: function(t) {
                i.Canvas.setSmoothingEnabled(this.context, t)
            }
        }), Object.defineProperty(i.BitmapData.prototype, "op", {
            get: function() {
                return this.context.globalCompositeOperation
            },
            set: function(t) {
                this.context.globalCompositeOperation = t
            }
        }), i.BitmapData.getTransform = function(t, e, i, n, s, r) {
            return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof n && (n = 1), "number" != typeof s && (s = 0), "number" != typeof r && (r = 0), {
                sx: i,
                sy: n,
                scaleX: i,
                scaleY: n,
                skewX: s,
                skewY: r,
                translateX: t,
                translateY: e,
                tx: t,
                ty: e
            }
        }, i.BitmapData.prototype.constructor = i.BitmapData, PIXI.Graphics = function() {
            PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1
        }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(t, e, i) {
            return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
        }, PIXI.Graphics.prototype.moveTo = function(t, e) {
            return this.drawShape(new PIXI.Polygon([t, e])), this
        }, PIXI.Graphics.prototype.lineTo = function(t, e) {
            return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.quadraticCurveTo = function(t, e, i, n) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            var s, r, o = this.currentPath.shape.points;
            0 === o.length && this.moveTo(0, 0);
            for (var a = o[o.length - 2], h = o[o.length - 1], l = 0, c = 1; c <= 20; ++c) s = a + (t - a) * (l = c / 20), r = h + (e - h) * l, o.push(s + (t + (i - t) * l - s) * l, r + (e + (n - e) * l - r) * l);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.bezierCurveTo = function(t, e, i, n, s, r) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
            for (var o, a, h, l, c, u = this.currentPath.shape.points, d = u[u.length - 2], p = u[u.length - 1], f = 0, g = 1; g <= 20; ++g) h = (a = (o = 1 - (f = g / 20)) * o) * o, c = (l = f * f) * f, u.push(h * d + 3 * a * f * t + 3 * o * l * i + c * s, h * p + 3 * a * f * e + 3 * o * l * n + c * r);
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arcTo = function(t, e, i, n, s) {
            this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
            var r = this.currentPath.shape.points,
                o = r[r.length - 2],
                a = r[r.length - 1] - e,
                h = o - t,
                l = n - e,
                c = i - t,
                u = Math.abs(a * c - h * l);
            if (u < 1e-8 || 0 === s) r[r.length - 2] === t && r[r.length - 1] === e || r.push(t, e);
            else {
                var d = a * a + h * h,
                    p = l * l + c * c,
                    f = a * l + h * c,
                    g = s * Math.sqrt(d) / u,
                    m = s * Math.sqrt(p) / u,
                    y = g * f / d,
                    v = m * f / p,
                    b = g * c + m * h,
                    x = g * l + m * a,
                    w = h * (m + y),
                    _ = a * (m + y),
                    P = c * (g + v),
                    T = l * (g + v),
                    S = Math.atan2(_ - x, w - b),
                    C = Math.atan2(T - x, P - b);
                this.arc(b + t, x + e, s, S, C, h * l > c * a)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.arc = function(t, e, i, n, s, r, o) {
            if (n === s) return this;
            void 0 === r && (r = !1), void 0 === o && (o = 40), !r && s <= n ? s += 2 * Math.PI : r && n <= s && (n += 2 * Math.PI);
            var a = r ? -1 * (n - s) : s - n,
                h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * o;
            if (0 === a) return this;
            var l = t + Math.cos(n) * i,
                c = e + Math.sin(n) * i;
            r && this.filling ? this.moveTo(t, e) : this.moveTo(l, c);
            for (var u = this.currentPath.shape.points, d = a / (2 * h), p = 2 * d, f = Math.cos(d), g = Math.sin(d), m = h - 1, y = m % 1 / m, v = 0; v <= m; v++) {
                var b = d + n + p * (v + y * v),
                    x = Math.cos(b),
                    w = -Math.sin(b);
                u.push((f * x + g * w) * i + t, (f * -w + g * x) * i + e)
            }
            return this.dirty = !0, this._boundsDirty = !0, this
        }, PIXI.Graphics.prototype.beginFill = function(t, e) {
            return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
        }, PIXI.Graphics.prototype.endFill = function() {
            return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
        }, PIXI.Graphics.prototype.drawRect = function(t, e, i, n) {
            return this.drawShape(new PIXI.Rectangle(t, e, i, n)), this
        }, PIXI.Graphics.prototype.drawRoundedRect = function(t, e, i, n, s) {
            return this.drawShape(new PIXI.RoundedRectangle(t, e, i, n, s)), this
        }, PIXI.Graphics.prototype.drawCircle = function(t, e, i) {
            return this.drawShape(new PIXI.Circle(t, e, i)), this
        }, PIXI.Graphics.prototype.drawEllipse = function(t, e, i, n) {
            return this.drawShape(new PIXI.Ellipse(t, e, i, n)), this
        }, PIXI.Graphics.prototype.drawPolygon = function(t) {
            (t instanceof i.Polygon || t instanceof PIXI.Polygon) && (t = t.points);
            var e = t;
            if (!Array.isArray(e)) {
                e = new Array(arguments.length);
                for (var n = 0; n < e.length; ++n) e[n] = arguments[n]
            }
            return this.drawShape(new i.Polygon(e)), this
        }, PIXI.Graphics.prototype.clear = function() {
            return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
        }, PIXI.Graphics.prototype.generateTexture = function(t, e, i) {
            void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
            var n = this.getBounds();
            n.width += i, n.height += i;
            var s = new PIXI.CanvasBuffer(n.width * t, n.height * t),
                r = PIXI.Texture.fromCanvas(s.canvas, e);
            return r.baseTexture.resolution = t, s.context.scale(t, t), s.context.translate(-n.x, -n.y), PIXI.CanvasGraphics.renderGraphics(this, s.context), r
        }, PIXI.Graphics.prototype._renderWebGL = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                    t.spriteBatch.currentBlendMode = this.blendMode;
                    var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                    t.spriteBatch.gl.blendFunc(e[0], e[1])
                }
                if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                    t.spriteBatch.start();
                    for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                    t.spriteBatch.stop()
                }
                this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
            }
        }, PIXI.Graphics.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                var e = t.context,
                    i = this.worldTransform;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                var n = t.resolution,
                    s = i.tx * t.resolution + t.shakeX,
                    r = i.ty * t.resolution + t.shakeY;
                e.setTransform(i.a * n, i.b * n, i.c * n, i.d * n, s, r), PIXI.CanvasGraphics.renderGraphics(this, e);
                for (var o = 0; o < this.children.length; o++) this.children[o]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, PIXI.Graphics.prototype.getBounds = function(t) {
            if (!this._currentBounds) {
                if (!this.renderable) return PIXI.EmptyRectangle;
                this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                var e = this._localBounds,
                    i = e.x,
                    n = e.width + e.x,
                    s = e.y,
                    r = e.height + e.y,
                    o = t || this.worldTransform,
                    a = o.a,
                    h = o.b,
                    l = o.c,
                    c = o.d,
                    u = o.tx,
                    d = o.ty,
                    p = a * n + l * r + u,
                    f = c * r + h * n + d,
                    g = a * i + l * r + u,
                    m = c * r + h * i + d,
                    y = a * i + l * s + u,
                    v = c * s + h * i + d,
                    b = a * n + l * s + u,
                    x = c * s + h * n + d,
                    w = p,
                    _ = f,
                    P = p,
                    T = f;
                P = b < (P = y < (P = g < P ? g : P) ? y : P) ? b : P, T = x < (T = v < (T = m < T ? m : T) ? v : T) ? x : T, w = b > (w = y > (w = g > w ? g : w) ? y : w) ? b : w, _ = x > (_ = v > (_ = m > _ ? m : _) ? v : _) ? x : _, this._bounds.x = P, this._bounds.width = w - P, this._bounds.y = T, this._bounds.height = _ - T, this._currentBounds = this._bounds
            }
            return this._currentBounds
        }, PIXI.Graphics.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = PIXI.identityMatrix;
            for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            return i
        }, PIXI.Graphics.prototype.containsPoint = function(t) {
            this.worldTransform.applyInverse(t, tempPoint);
            for (var e = this.graphicsData, i = 0; i < e.length; i++) {
                var n = e[i];
                if (n.fill && (n.shape && n.shape.contains(tempPoint.x, tempPoint.y))) return !0
            }
            return !1
        }, PIXI.Graphics.prototype.updateLocalBounds = function() {
            var t = 1 / 0,
                e = -1 / 0,
                n = 1 / 0,
                s = -1 / 0;
            if (this.graphicsData.length)
                for (var r, o, a, h, l, c, u = 0; u < this.graphicsData.length; u++) {
                    var d = this.graphicsData[u],
                        p = d.type,
                        f = d.lineWidth;
                    if (r = d.shape, p === PIXI.Graphics.RECT || p === PIXI.Graphics.RREC) a = r.x - f / 2, h = r.y - f / 2, l = r.width + f, c = r.height + f, t = a < t ? a : t, e = a + l > e ? a + l : e, n = h < n ? h : n, s = h + c > s ? h + c : s;
                    else if (p === PIXI.Graphics.CIRC) a = r.x, h = r.y, l = r.radius + f / 2, c = r.radius + f / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, n = h - c < n ? h - c : n, s = h + c > s ? h + c : s;
                    else if (p === PIXI.Graphics.ELIP) a = r.x, h = r.y, l = r.width + f / 2, c = r.height + f / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, n = h - c < n ? h - c : n, s = h + c > s ? h + c : s;
                    else {
                        o = r.points;
                        for (var g = 0; g < o.length; g++) o[g] instanceof i.Point ? (a = o[g].x, h = o[g].y) : (a = o[g], h = o[g + 1], g < o.length - 1 && g++), t = a - f < t ? a - f : t, e = a + f > e ? a + f : e, n = h - f < n ? h - f : n, s = h + f > s ? h + f : s
                    }
                } else t = 0, e = 0, n = 0, s = 0;
            var m = this.boundsPadding;
            this._localBounds.x = t - m, this._localBounds.width = e - t + 2 * m, this._localBounds.y = n - m, this._localBounds.height = s - n + 2 * m
        }, PIXI.Graphics.prototype._generateCachedSprite = function() {
            var t = this.getLocalBounds();
            if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
            else {
                var e = new PIXI.CanvasBuffer(t.width, t.height),
                    i = PIXI.Texture.fromCanvas(e.canvas);
                this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
            }
            this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
        }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
            var t = this._cachedSprite,
                e = t.texture,
                i = t.buffer.canvas;
            e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
        }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
            this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
        }, PIXI.Graphics.prototype.drawShape = function(t) {
            this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof i.Polygon && (t = t.clone()).flatten();
            var e = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
            return this.graphicsData.push(e), e.type === PIXI.Graphics.POLY && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e
        }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
            get: function() {
                return this._cacheAsBitmap
            },
            set: function(t) {
                this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
            }
        }), PIXI.GraphicsData = function(t, e, i, n, s, r, o) {
            this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = n, this.fillAlpha = s, this._fillTint = n, this.fill = r, this.shape = o, this.type = o.type
        }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() {
            return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
        }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(t, e, i) {
            i = i || 2;
            var n, s, r, o, a, h, l, c = e && e.length,
                u = c ? e[0] * i : t.length,
                d = PIXI.EarCut.linkedList(t, 0, u, i, !0),
                p = [];
            if (!d) return p;
            if (c && (d = PIXI.EarCut.eliminateHoles(t, e, d, i)), t.length > 80 * i) {
                n = r = t[0], s = o = t[1];
                for (var f = i; f < u; f += i) a = t[f], h = t[f + 1], a < n && (n = a), h < s && (s = h), a > r && (r = a), h > o && (o = h);
                l = Math.max(r - n, o - s)
            }
            return PIXI.EarCut.earcutLinked(d, p, i, n, s, l), p
        }, PIXI.EarCut.linkedList = function(t, e, i, n, s) {
            var r, o, a, h = 0;
            for (r = e, o = i - n; r < i; r += n) h += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r;
            if (s === h > 0)
                for (r = e; r < i; r += n) a = PIXI.EarCut.insertNode(r, t[r], t[r + 1], a);
            else
                for (r = i - n; r >= e; r -= n) a = PIXI.EarCut.insertNode(r, t[r], t[r + 1], a);
            return a
        }, PIXI.EarCut.filterPoints = function(t, e) {
            if (!t) return t;
            e || (e = t);
            var i, n = t;
            do {
                if (i = !1, n.steiner || !PIXI.EarCut.equals(n, n.next) && 0 !== PIXI.EarCut.area(n.prev, n, n.next)) n = n.next;
                else {
                    if (PIXI.EarCut.removeNode(n), (n = e = n.prev) === n.next) return null;
                    i = !0
                }
            } while (i || n !== e);
            return e
        }, PIXI.EarCut.earcutLinked = function(t, e, i, n, s, r, o) {
            if (t) {
                !o && r && PIXI.EarCut.indexCurve(t, n, s, r);
                for (var a, h, l = t; t.prev !== t.next;)
                    if (a = t.prev, h = t.next, r ? PIXI.EarCut.isEarHashed(t, n, s, r) : PIXI.EarCut.isEar(t)) e.push(a.i / i), e.push(t.i / i), e.push(h.i / i), PIXI.EarCut.removeNode(t), t = h.next, l = h.next;
                    else if ((t = h) === l) {
                    o ? 1 === o ? (t = PIXI.EarCut.cureLocalIntersections(t, e, i), PIXI.EarCut.earcutLinked(t, e, i, n, s, r, 2)) : 2 === o && PIXI.EarCut.splitEarcut(t, e, i, n, s, r) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(t), e, i, n, s, r, 1);
                    break
                }
            }
        }, PIXI.EarCut.isEar = function(t) {
            var e = t.prev,
                i = t,
                n = t.next;
            if (PIXI.EarCut.area(e, i, n) >= 0) return !1;
            for (var s = t.next.next; s !== t.prev;) {
                if (PIXI.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && PIXI.EarCut.area(s.prev, s, s.next) >= 0) return !1;
                s = s.next
            }
            return !0
        }, PIXI.EarCut.isEarHashed = function(t, e, i, n) {
            var s = t.prev,
                r = t,
                o = t.next;
            if (PIXI.EarCut.area(s, r, o) >= 0) return !1;
            for (var a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x, h = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y, l = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x, c = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y, u = PIXI.EarCut.zOrder(a, h, e, i, n), d = PIXI.EarCut.zOrder(l, c, e, i, n), p = t.nextZ; p && p.z <= d;) {
                if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0) return !1;
                p = p.nextZ
            }
            for (p = t.prevZ; p && p.z >= u;) {
                if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0) return !1;
                p = p.prevZ
            }
            return !0
        }, PIXI.EarCut.cureLocalIntersections = function(t, e, i) {
            var n = t;
            do {
                var s = n.prev,
                    r = n.next.next;
                PIXI.EarCut.intersects(s, n, n.next, r) && PIXI.EarCut.locallyInside(s, r) && PIXI.EarCut.locallyInside(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), PIXI.EarCut.removeNode(n), PIXI.EarCut.removeNode(n.next), n = t = r), n = n.next
            } while (n !== t);
            return n
        }, PIXI.EarCut.splitEarcut = function(t, e, i, n, s, r) {
            var o = t;
            do {
                for (var a = o.next.next; a !== o.prev;) {
                    if (o.i !== a.i && PIXI.EarCut.isValidDiagonal(o, a)) {
                        var h = PIXI.EarCut.splitPolygon(o, a);
                        return o = PIXI.EarCut.filterPoints(o, o.next), h = PIXI.EarCut.filterPoints(h, h.next), PIXI.EarCut.earcutLinked(o, e, i, n, s, r), void PIXI.EarCut.earcutLinked(h, e, i, n, s, r)
                    }
                    a = a.next
                }
                o = o.next
            } while (o !== t)
        }, PIXI.EarCut.eliminateHoles = function(t, e, i, n) {
            var s, r, o, a, h, l = [];
            for (s = 0, r = e.length; s < r; s++) o = e[s] * n, a = s < r - 1 ? e[s + 1] * n : t.length, (h = PIXI.EarCut.linkedList(t, o, a, n, !1)) === h.next && (h.steiner = !0), l.push(PIXI.EarCut.getLeftmost(h));
            for (l.sort(compareX), s = 0; s < l.length; s++) PIXI.EarCut.eliminateHole(l[s], i), i = PIXI.EarCut.filterPoints(i, i.next);
            return i
        }, PIXI.EarCut.compareX = function(t, e) {
            return t.x - e.x
        }, PIXI.EarCut.eliminateHole = function(t, e) {
            if (e = PIXI.EarCut.findHoleBridge(t, e)) {
                var i = PIXI.EarCut.splitPolygon(e, t);
                PIXI.EarCut.filterPoints(i, i.next)
            }
        }, PIXI.EarCut.findHoleBridge = function(t, e) {
            var i, n = e,
                s = t.x,
                r = t.y,
                o = -1 / 0;
            do {
                if (r <= n.y && r >= n.next.y) {
                    var a = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    a <= s && a > o && (o = a, i = n.x < n.next.x ? n : n.next)
                }
                n = n.next
            } while (n !== e);
            if (!i) return null;
            if (t.x === i.x) return i.prev;
            var h, l = i,
                c = 1 / 0;
            for (n = i.next; n !== l;) s >= n.x && n.x >= i.x && PIXI.EarCut.pointInTriangle(r < i.y ? s : o, r, i.x, i.y, r < i.y ? o : s, r, n.x, n.y) && ((h = Math.abs(r - n.y) / (s - n.x)) < c || h === c && n.x > i.x) && PIXI.EarCut.locallyInside(n, t) && (i = n, c = h), n = n.next;
            return i
        }, PIXI.EarCut.indexCurve = function(t, e, i, n) {
            var s = t;
            do {
                null === s.z && (s.z = PIXI.EarCut.zOrder(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next
            } while (s !== t);
            s.prevZ.nextZ = null, s.prevZ = null, PIXI.EarCut.sortLinked(s)
        }, PIXI.EarCut.sortLinked = function(t) {
            var e, i, n, s, r, o, a, h, l = 1;
            do {
                for (i = t, t = null, r = null, o = 0; i;) {
                    for (o++, n = i, a = 0, e = 0; e < l && (a++, n = n.nextZ); e++);
                    for (h = l; a > 0 || h > 0 && n;) 0 === a ? (s = n, n = n.nextZ, h--) : 0 !== h && n ? i.z <= n.z ? (s = i, i = i.nextZ, a--) : (s = n, n = n.nextZ, h--) : (s = i, i = i.nextZ, a--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s;
                    i = n
                }
                r.nextZ = null, l *= 2
            } while (o > 1);
            return t
        }, PIXI.EarCut.zOrder = function(t, e, i, n, s) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / s) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) / s) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }, PIXI.EarCut.getLeftmost = function(t) {
            var e = t,
                i = t;
            do {
                e.x < i.x && (i = e), e = e.next
            } while (e !== t);
            return i
        }, PIXI.EarCut.pointInTriangle = function(t, e, i, n, s, r, o, a) {
            return (s - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (n - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (s - o) * (n - a) >= 0
        }, PIXI.EarCut.isValidDiagonal = function(t, e) {
            return PIXI.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !PIXI.EarCut.intersectsPolygon(t, e) && PIXI.EarCut.locallyInside(t, e) && PIXI.EarCut.locallyInside(e, t) && PIXI.EarCut.middleInside(t, e)
        }, PIXI.EarCut.area = function(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }, PIXI.EarCut.equals = function(t, e) {
            return t.x === e.x && t.y === e.y
        }, PIXI.EarCut.intersects = function(t, e, i, n) {
            return PIXI.EarCut.area(t, e, i) > 0 != PIXI.EarCut.area(t, e, n) > 0 && PIXI.EarCut.area(i, n, t) > 0 != PIXI.EarCut.area(i, n, e) > 0
        }, PIXI.EarCut.intersectsPolygon = function(t, e) {
            var i = t;
            do {
                if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && PIXI.EarCut.intersects(i, i.next, t, e)) return !0;
                i = i.next
            } while (i !== t);
            return !1
        }, PIXI.EarCut.locallyInside = function(t, e) {
            return PIXI.EarCut.area(t.prev, t, t.next) < 0 ? PIXI.EarCut.area(t, e, t.next) >= 0 && PIXI.EarCut.area(t, t.prev, e) >= 0 : PIXI.EarCut.area(t, e, t.prev) < 0 || PIXI.EarCut.area(t, t.next, e) < 0
        }, PIXI.EarCut.middleInside = function(t, e) {
            var i = t,
                n = !1,
                s = (t.x + e.x) / 2,
                r = (t.y + e.y) / 2;
            do {
                i.y > r != i.next.y > r && s < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
            } while (i !== t);
            return n
        }, PIXI.EarCut.splitPolygon = function(t, e) {
            var i = new PIXI.EarCut.Node(t.i, t.x, t.y),
                n = new PIXI.EarCut.Node(e.i, e.x, e.y),
                s = t.next,
                r = e.prev;
            return t.next = e, e.prev = t, i.next = s, s.prev = i, n.next = i, i.prev = n, r.next = n, n.prev = r, n
        }, PIXI.EarCut.insertNode = function(t, e, i, n) {
            var s = new PIXI.EarCut.Node(t, e, i);
            return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s
        }, PIXI.EarCut.removeNode = function(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }, PIXI.EarCut.Node = function(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, e) {
            var i, n = e.gl,
                s = e.projection,
                r = e.offset,
                o = e.shaderManager.primitiveShader;
            t.dirty && PIXI.WebGLGraphics.updateGraphics(t, n);
            for (var a = t._webGL[n.id], h = 0; h < a.data.length; h++) 1 === a.data[h].mode ? (i = a.data[h], e.stencilManager.pushStencil(t, i, e), n.drawElements(n.TRIANGLE_FAN, 4, n.UNSIGNED_SHORT, 2 * (i.indices.length - 4)), e.stencilManager.popStencil(t, i, e)) : (i = a.data[h], e.shaderManager.setShader(o), o = e.shaderManager.primitiveShader, n.uniformMatrix3fv(o.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(o.flipY, 1), n.uniform2f(o.projectionVector, s.x, -s.y), n.uniform2f(o.offsetVector, -r.x, -r.y), n.uniform3fv(o.tintColor, PIXI.hex2rgb(t.tint)), n.uniform1f(o.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, i.buffer), n.vertexAttribPointer(o.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(o.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, i.indexBuffer), n.drawElements(n.TRIANGLE_STRIP, i.indices.length, n.UNSIGNED_SHORT, 0))
        }, PIXI.WebGLGraphics.updateGraphics = function(t, e) {
            var i, n, s = t._webGL[e.id];
            if (s || (s = t._webGL[e.id] = {
                    lastIndex: 0,
                    data: [],
                    gl: e
                }), t.dirty = !1, t.clearDirty) {
                for (t.clearDirty = !1, i = 0; i < s.data.length; i++) {
                    var r = s.data[i];
                    r.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(r)
                }
                s.data = [], s.lastIndex = 0
            }
            for (i = s.lastIndex; i < t.graphicsData.length; i++) {
                var o = t.graphicsData[i];
                if (o.type === PIXI.Graphics.POLY) {
                    if (o.points = o.shape.points.slice(), o.shape.closed && (o.points[0] === o.points[o.points.length - 2] && o.points[1] === o.points[o.points.length - 1] || o.points.push(o.points[0], o.points[1])), o.fill)
                        if (o.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
                            if (o.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) n = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildPoly(o, n) || (n = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(o, n));
                            else n = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(o, n);
                    o.lineWidth > 0 && (n = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildLine(o, n))
                } else n = PIXI.WebGLGraphics.switchMode(s, 0), o.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(o, n) : o.type === PIXI.Graphics.CIRC || o.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(o, n) : o.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(o, n);
                s.lastIndex++
            }
            for (i = 0; i < s.data.length; i++)(n = s.data[i]).dirty && n.upload()
        }, PIXI.WebGLGraphics.switchMode = function(t, e) {
            var i;
            return t.data.length && (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)), i.dirty = !0, i
        }, PIXI.WebGLGraphics.buildRectangle = function(t, e) {
            var i = t.shape,
                n = i.x,
                s = i.y,
                r = i.width,
                o = i.height;
            if (t.fill) {
                var a = PIXI.hex2rgb(t.fillColor),
                    h = t.fillAlpha,
                    l = a[0] * h,
                    c = a[1] * h,
                    u = a[2] * h,
                    d = e.points,
                    p = e.indices,
                    f = d.length / 6;
                d.push(n, s), d.push(l, c, u, h), d.push(n + r, s), d.push(l, c, u, h), d.push(n, s + o), d.push(l, c, u, h), d.push(n + r, s + o), d.push(l, c, u, h), p.push(f, f, f + 1, f + 2, f + 3, f + 3)
            }
            if (t.lineWidth) {
                var g = t.points;
                t.points = [n, s, n + r, s, n + r, s + o, n, s + o, n, s], PIXI.WebGLGraphics.buildLine(t, e), t.points = g
            }
        }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) {
            var i = t.shape,
                n = i.x,
                s = i.y,
                r = i.width,
                o = i.height,
                a = i.radius,
                h = [];
            if (h.push(n, s + a), h = (h = (h = (h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n, s + o - a, n, s + o, n + a, s + o))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + r - a, s + o, n + r, s + o, n + r, s + o - a))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + r, s + a, n + r, s, n + r - a, s))).concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + a, s, n, s, n, s + a)), t.fill) {
                var l = PIXI.hex2rgb(t.fillColor),
                    c = t.fillAlpha,
                    u = l[0] * c,
                    d = l[1] * c,
                    p = l[2] * c,
                    f = e.points,
                    g = e.indices,
                    m = f.length / 6,
                    y = PIXI.EarCut.Triangulate(h, null, 2),
                    v = 0;
                for (v = 0; v < y.length; v += 3) g.push(y[v] + m), g.push(y[v] + m), g.push(y[v + 1] + m), g.push(y[v + 2] + m), g.push(y[v + 2] + m);
                for (v = 0; v < h.length; v++) f.push(h[v], h[++v], u, d, p, c)
            }
            if (t.lineWidth) {
                var b = t.points;
                t.points = h, PIXI.WebGLGraphics.buildLine(t, e), t.points = b
            }
        }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, n, s, r) {
            var o, a, h, l, c, u, d = [];

            function p(t, e, i) {
                return t + (e - t) * i
            }
            for (var f = 0, g = 0; g <= 20; g++) o = p(t, i, f = g / 20), a = p(e, n, f), h = p(i, s, f), l = p(n, r, f), c = p(o, h, f), u = p(a, l, f), d.push(c, u);
            return d
        }, PIXI.WebGLGraphics.buildCircle = function(t, e) {
            var i, n, s = t.shape,
                r = s.x,
                o = s.y;
            t.type === PIXI.Graphics.CIRC ? (i = s.radius, n = s.radius) : (i = s.width, n = s.height);
            var a = 2 * Math.PI / 40,
                h = 0;
            if (t.fill) {
                var l = PIXI.hex2rgb(t.fillColor),
                    c = t.fillAlpha,
                    u = l[0] * c,
                    d = l[1] * c,
                    p = l[2] * c,
                    f = e.points,
                    g = e.indices,
                    m = f.length / 6;
                for (g.push(m), h = 0; h < 41; h++) f.push(r, o, u, d, p, c), f.push(r + Math.sin(a * h) * i, o + Math.cos(a * h) * n, u, d, p, c), g.push(m++, m++);
                g.push(m - 1)
            }
            if (t.lineWidth) {
                var y = t.points;
                for (t.points = [], h = 0; h < 41; h++) t.points.push(r + Math.sin(a * h) * i, o + Math.cos(a * h) * n);
                PIXI.WebGLGraphics.buildLine(t, e), t.points = y
            }
        }, PIXI.WebGLGraphics.buildLine = function(t, e) {
            var i = 0,
                n = t.points;
            if (0 !== n.length) {
                if (t.lineWidth % 2)
                    for (i = 0; i < n.length; i++) n[i] += .5;
                var s = new PIXI.Point(n[0], n[1]),
                    r = new PIXI.Point(n[n.length - 2], n[n.length - 1]);
                if (s.x === r.x && s.y === r.y) {
                    (n = n.slice()).pop(), n.pop();
                    var o = (r = new PIXI.Point(n[n.length - 2], n[n.length - 1])).x + .5 * (s.x - r.x),
                        a = r.y + .5 * (s.y - r.y);
                    n.unshift(o, a), n.push(o, a)
                }
                var h, l, c, u, d, p, f, g, m, y, v, b, x, w, _, P, T, S, C, A, E, M, I = e.points,
                    O = e.indices,
                    k = n.length / 2,
                    R = n.length,
                    L = I.length / 6,
                    B = t.lineWidth / 2,
                    F = PIXI.hex2rgb(t.lineColor),
                    D = t.lineAlpha,
                    U = F[0] * D,
                    G = F[1] * D,
                    N = F[2] * D;
                for (c = n[0], u = n[1], d = n[2], m = -(u - (p = n[3])), y = c - d, m /= M = Math.sqrt(m * m + y * y), y /= M, m *= B, y *= B, I.push(c - m, u - y, U, G, N, D), I.push(c + m, u + y, U, G, N, D), i = 1; i < k - 1; i++) c = n[2 * (i - 1)], u = n[2 * (i - 1) + 1], d = n[2 * i], p = n[2 * i + 1], f = n[2 * (i + 1)], g = n[2 * (i + 1) + 1], m = -(u - p), y = c - d, m /= M = Math.sqrt(m * m + y * y), y /= M, m *= B, y *= B, v = -(p - g), b = d - f, v /= M = Math.sqrt(v * v + b * b), b /= M, T = (-m + c) * (-y + p) - (-m + d) * (-y + u), A = (-(v *= B) + f) * (-(b *= B) + p) - (-v + d) * (-b + g), E = (_ = -y + u - (-y + p)) * (C = -v + d - (-v + f)) - (S = -b + g - (-b + p)) * (P = -m + d - (-m + c)), Math.abs(E) < .1 ? (E += 10.1, I.push(d - m, p - y, U, G, N, D), I.push(d + m, p + y, U, G, N, D)) : ((h = (P * A - C * T) / E) - d) * (h - d) + ((l = (S * T - _ * A) / E) - p) + (l - p) > 19600 ? (x = m - v, w = y - b, x /= M = Math.sqrt(x * x + w * w), w /= M, x *= B, w *= B, I.push(d - x, p - w), I.push(U, G, N, D), I.push(d + x, p + w), I.push(U, G, N, D), I.push(d - x, p - w), I.push(U, G, N, D), R++) : (I.push(h, l), I.push(U, G, N, D), I.push(d - (h - d), p - (l - p)), I.push(U, G, N, D));
                for (c = n[2 * (k - 2)], u = n[2 * (k - 2) + 1], d = n[2 * (k - 1)], m = -(u - (p = n[2 * (k - 1) + 1])), y = c - d, m /= M = Math.sqrt(m * m + y * y), y /= M, m *= B, y *= B, I.push(d - m, p - y), I.push(U, G, N, D), I.push(d + m, p + y), I.push(U, G, N, D), O.push(L), i = 0; i < R; i++) O.push(L++);
                O.push(L - 1)
            }
        }, PIXI.WebGLGraphics.buildComplexPoly = function(t, e) {
            var i = t.points.slice();
            if (!(i.length < 6)) {
                var n = e.indices;
                e.points = i, e.alpha = t.fillAlpha, e.color = PIXI.hex2rgb(t.fillColor);
                for (var s, r, o = 1 / 0, a = -1 / 0, h = 1 / 0, l = -1 / 0, c = 0; c < i.length; c += 2) s = i[c], r = i[c + 1], o = s < o ? s : o, a = s > a ? s : a, h = r < h ? r : h, l = r > l ? r : l;
                i.push(o, h, a, h, a, l, o, l);
                var u = i.length / 2;
                for (c = 0; c < u; c++) n.push(c)
            }
        }, PIXI.WebGLGraphics.buildPoly = function(t, e) {
            var i = t.points;
            if (!(i.length < 6)) {
                var n = e.points,
                    s = e.indices,
                    r = i.length / 2,
                    o = PIXI.hex2rgb(t.fillColor),
                    a = t.fillAlpha,
                    h = o[0] * a,
                    l = o[1] * a,
                    c = o[2] * a,
                    u = PIXI.EarCut.Triangulate(i, null, 2);
                if (!u) return !1;
                var d = n.length / 6,
                    p = 0;
                for (p = 0; p < u.length; p += 3) s.push(u[p] + d), s.push(u[p] + d), s.push(u[p + 1] + d), s.push(u[p + 2] + d), s.push(u[p + 2] + d);
                for (p = 0; p < r; p++) n.push(i[2 * p], i[2 * p + 1], h, l, c, a);
                return !0
            }
        }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
            this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
        }, PIXI.WebGLGraphicsData.prototype.reset = function() {
            this.points = [], this.indices = []
        }, PIXI.WebGLGraphicsData.prototype.upload = function() {
            var t = this.gl;
            this.glPoints = new PIXI.Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
        }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, e) {
            var i = t.worldAlpha;
            t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
            for (var n = 0; n < t.graphicsData.length; n++) {
                var s = t.graphicsData[n],
                    r = s.shape,
                    o = s._fillTint,
                    a = s._lineTint;
                if (e.lineWidth = s.lineWidth, s.type === PIXI.Graphics.POLY) {
                    e.beginPath();
                    var h = r.points;
                    e.moveTo(h[0], h[1]);
                    for (var l = 1; l < h.length / 2; l++) e.lineTo(h[2 * l], h[2 * l + 1]);
                    r.closed && e.lineTo(h[0], h[1]), h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                } else if (s.type === PIXI.Graphics.RECT)(s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fillRect(r.x, r.y, r.width, r.height)), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.strokeRect(r.x, r.y, r.width, r.height));
                else if (s.type === PIXI.Graphics.CIRC) e.beginPath(), e.arc(r.x, r.y, r.radius, 0, 2 * Math.PI), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke());
                else if (s.type === PIXI.Graphics.ELIP) {
                    var c = 2 * r.width,
                        u = 2 * r.height,
                        d = r.x - c / 2,
                        p = r.y - u / 2;
                    e.beginPath();
                    var f = c / 2 * .5522848,
                        g = u / 2 * .5522848,
                        m = d + c,
                        y = p + u,
                        v = d + c / 2,
                        b = p + u / 2;
                    e.moveTo(d, b), e.bezierCurveTo(d, b - g, v - f, p, v, p), e.bezierCurveTo(v + f, p, m, b - g, m, b), e.bezierCurveTo(m, b + g, v + f, y, v, y), e.bezierCurveTo(v - f, y, d, b + g, d, b), e.closePath(), s.fill && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                } else if (s.type === PIXI.Graphics.RREC) {
                    var x = r.x,
                        w = r.y,
                        _ = r.width,
                        P = r.height,
                        T = r.radius,
                        S = Math.min(_, P) / 2 | 0;
                    T = T > S ? S : T, e.beginPath(), e.moveTo(x, w + T), e.lineTo(x, w + P - T), e.quadraticCurveTo(x, w + P, x + T, w + P), e.lineTo(x + _ - T, w + P), e.quadraticCurveTo(x + _, w + P, x + _, w + P - T), e.lineTo(x + _, w + T), e.quadraticCurveTo(x + _, w, x + _ - T, w), e.lineTo(x + T, w), e.quadraticCurveTo(x, w, x, w + T), e.closePath(), (s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o).toString(16)).substr(-6), e.fill()), s.lineWidth && (e.globalAlpha = s.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke())
                }
            }
        }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
            var i = t.graphicsData.length;
            if (0 !== i) {
                e.beginPath();
                for (var n = 0; n < i; n++) {
                    var s = t.graphicsData[n],
                        r = s.shape;
                    if (s.type === PIXI.Graphics.POLY) {
                        var o = r.points;
                        e.moveTo(o[0], o[1]);
                        for (var a = 1; a < o.length / 2; a++) e.lineTo(o[2 * a], o[2 * a + 1]);
                        o[0] === o[o.length - 2] && o[1] === o[o.length - 1] && e.closePath()
                    } else if (s.type === PIXI.Graphics.RECT) e.rect(r.x, r.y, r.width, r.height), e.closePath();
                    else if (s.type === PIXI.Graphics.CIRC) e.arc(r.x, r.y, r.radius, 0, 2 * Math.PI), e.closePath();
                    else if (s.type === PIXI.Graphics.ELIP) {
                        var h = 2 * r.width,
                            l = 2 * r.height,
                            c = r.x - h / 2,
                            u = r.y - l / 2,
                            d = h / 2 * .5522848,
                            p = l / 2 * .5522848,
                            f = c + h,
                            g = u + l,
                            m = c + h / 2,
                            y = u + l / 2;
                        e.moveTo(c, y), e.bezierCurveTo(c, y - p, m - d, u, m, u), e.bezierCurveTo(m + d, u, f, y - p, f, y), e.bezierCurveTo(f, y + p, m + d, g, m, g), e.bezierCurveTo(m - d, g, c, y + p, c, y), e.closePath()
                    } else if (s.type === PIXI.Graphics.RREC) {
                        var v = r.x,
                            b = r.y,
                            x = r.width,
                            w = r.height,
                            _ = r.radius,
                            P = Math.min(x, w) / 2 | 0;
                        _ = _ > P ? P : _, e.moveTo(v, b + _), e.lineTo(v, b + w - _), e.quadraticCurveTo(v, b + w, v + _, b + w), e.lineTo(v + x - _, b + w), e.quadraticCurveTo(v + x, b + w, v + x, b + w - _), e.lineTo(v + x, b + _), e.quadraticCurveTo(v + x, b, v + x - _, b), e.lineTo(v + _, b), e.quadraticCurveTo(v, b, v, b + _), e.closePath()
                    }
                }
            }
        }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
            if (16777215 !== t.tint)
                for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, n = (255 & t.tint) / 255, s = 0; s < t.graphicsData.length; s++) {
                    var r = t.graphicsData[s],
                        o = 0 | r.fillColor,
                        a = 0 | r.lineColor;
                    r._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * n * 255, r._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * n * 255
                }
        }, i.Graphics = function(t, e, n) {
            void 0 === e && (e = 0), void 0 === n && (n = 0), this.type = i.GRAPHICS, this.physicsType = i.SPRITE, this.anchor = new i.Point, PIXI.Graphics.call(this), i.Component.Core.init.call(this, t, e, n, "", null)
        }, i.Graphics.prototype = Object.create(PIXI.Graphics.prototype), i.Graphics.prototype.constructor = i.Graphics, i.Component.Core.install.call(i.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.Graphics.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Graphics.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Graphics.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Graphics.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Graphics.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Graphics.prototype.postUpdate = function() {
            i.Component.PhysicsBody.postUpdate.call(this), i.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
            for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
        }, i.Graphics.prototype.destroy = function(t) {
            this.clear(), i.Component.Destroy.prototype.destroy.call(this, t)
        }, i.Graphics.prototype.drawTriangle = function(t, e) {
            void 0 === e && (e = !1);
            var n = new i.Polygon(t);
            if (e) {
                var s = new i.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                    r = new i.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                    o = new i.Point(t[1].x - t[2].x, t[1].y - t[2].y).cross(r);
                s.dot(o) > 0 && this.drawPolygon(n)
            } else this.drawPolygon(n)
        }, i.Graphics.prototype.drawTriangles = function(t, e, n) {
            void 0 === n && (n = !1);
            var s, r = new i.Point,
                o = new i.Point,
                a = new i.Point,
                h = [];
            if (e)
                if (t[0] instanceof i.Point)
                    for (s = 0; s < e.length / 3; s++) h.push(t[e[3 * s]]), h.push(t[e[3 * s + 1]]), h.push(t[e[3 * s + 2]]), 3 === h.length && (this.drawTriangle(h, n), h = []);
                else
                    for (s = 0; s < e.length; s++) r.x = t[2 * e[s]], r.y = t[2 * e[s] + 1], h.push(r.copyTo({})), 3 === h.length && (this.drawTriangle(h, n), h = []);
            else if (t[0] instanceof i.Point)
                for (s = 0; s < t.length / 3; s++) this.drawTriangle([t[3 * s], t[3 * s + 1], t[3 * s + 2]], n);
            else
                for (s = 0; s < t.length / 6; s++) r.x = t[6 * s + 0], r.y = t[6 * s + 1], o.x = t[6 * s + 2], o.y = t[6 * s + 3], a.x = t[6 * s + 4], a.y = t[6 * s + 5], this.drawTriangle([r, o, a], n)
        }, i.RenderTexture = function(t, e, n, s, r, o) {
            void 0 === s && (s = ""), void 0 === r && (r = i.scaleModes.DEFAULT), void 0 === o && (o = 1), this.game = t, this.key = s, this.type = i.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, e, n, this.game.renderer, r, o), this.render = i.RenderTexture.prototype.render
        }, i.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), i.RenderTexture.prototype.constructor = i.RenderTexture, i.RenderTexture.prototype.renderXY = function(t, e, i, n) {
            t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, n) : this.renderCanvas(t, this._tempMatrix, n)
        }, i.RenderTexture.prototype.renderRawXY = function(t, e, i, n) {
            this._tempMatrix.identity().translate(e, i), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, n) : this.renderCanvas(t, this._tempMatrix, n)
        }, i.RenderTexture.prototype.render = function(t, e, i) {
            void 0 === e || null === e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, i) : this.renderCanvas(t, this._tempMatrix, i)
        }, i.Text = function(t, e, n, s, r) {
            e = e || 0, n = n || 0, s = void 0 === s || null === s ? "" : s.toString(), r = i.Utils.extend({}, r), this.type = i.TEXT, this.physicsType = i.SPRITE, this.padding = new i.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = t.renderer.resolution, this._text = s, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, i.Sprite.call(this, t, e, n, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(r), "" !== s && this.updateText()
        }, i.Text.prototype = Object.create(i.Sprite.prototype), i.Text.prototype.constructor = i.Text, i.Text.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Text.prototype.update = function() {}, i.Text.prototype.destroy = function(t) {
            this.texture.destroy(!0), i.Component.Destroy.prototype.destroy.call(this, t)
        }, i.Text.prototype.setShadow = function(t, e, i, n, s, r) {
            return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === n && (n = 0), void 0 === s && (s = !0), void 0 === r && (r = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = n, this.style.shadowStroke = s, this.style.shadowFill = r, this.dirty = !0, this
        }, i.Text.prototype.setStyle = function(t, e) {
            void 0 === e && (e = !1), (t = t || {}).font = t.font || "bold 20pt Arial", t.backgroundColor = t.backgroundColor || null, t.fill = t.fill || "black", t.align = t.align || "left", t.boundsAlignH = t.boundsAlignH || "left", t.boundsAlignV = t.boundsAlignV || "top", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.maxLines = t.maxLines || 0, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, t.tabs = t.tabs || 0;
            var i = this.fontToComponents(t.font);
            return t.fontStyle && (i.fontStyle = t.fontStyle), t.fontVariant && (i.fontVariant = t.fontVariant), t.fontWeight && (i.fontWeight = t.fontWeight), t.fontSize && ("number" == typeof t.fontSize && (t.fontSize = t.fontSize + "px"), i.fontSize = t.fontSize), this._fontComponents = i, t.font = this.componentsToFont(this._fontComponents), this.style = t, this.dirty = !0, e && this.updateText(), this
        }, i.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var t = this.text;
            this.style.wordWrap && (t = this.runWordWrap(this.text));
            var e = t.split(/(?:\r\n|\r|\n)/),
                i = this.style.tabs,
                n = [],
                s = 0,
                r = this.determineFontProperties(this.style.font),
                o = e.length;
            this.style.maxLines > 0 && this.style.maxLines < e.length && (o = this.style.maxLines), this._charCount = 0;
            for (var a = 0; a < o; a++) {
                if (0 === i) {
                    var h = this.style.strokeThickness + this.padding.x;
                    this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? h += this.measureLine(e[a]) : h += this.context.measureText(e[a]).width, this.style.wordWrap && (h -= this.context.measureText(" ").width)
                } else {
                    var l = e[a].split(/(?:\t)/);
                    h = this.padding.x + this.style.strokeThickness;
                    if (Array.isArray(i))
                        for (var c = 0, u = 0; u < l.length; u++) {
                            var d = 0;
                            d = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(l[u]) : Math.ceil(this.context.measureText(l[u]).width), u > 0 && (c += i[u - 1]), h = c + d
                        } else
                            for (u = 0; u < l.length; u++) {
                                this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? h += this.measureLine(l[u]) : h += Math.ceil(this.context.measureText(l[u]).width), h += this.game.math.snapToCeil(h, i) - h
                            }
                }
                n[a] = Math.ceil(h), s = Math.max(s, n[a])
            }
            this.canvas.width = s * this._res;
            var p, f, g = r.fontSize + this.style.strokeThickness + this.padding.y,
                m = g * o,
                y = this._lineSpacing;
            for (y < 0 && Math.abs(y) > g && (y = -g), 0 !== y && (m += y > 0 ? y * e.length : y * (e.length - 1)), this.canvas.height = m * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round", this._charCount = 0, a = 0; a < o; a++) p = this.style.strokeThickness / 2, f = this.style.strokeThickness / 2 + a * g + r.ascent, a > 0 && (f += y * a), "right" === this.style.align ? p += s - n[a] : "center" === this.style.align && (p += (s - n[a]) / 2), this.autoRound && (p = Math.round(p), f = Math.round(f)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[a], p, f) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], p, f) : this.renderTabLine(e[a], p, f, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], p, f) : this.renderTabLine(e[a], p, f, !0)));
            this.updateTexture(), this.dirty = !1
        }, i.Text.prototype.renderTabLine = function(t, e, i, n) {
            var s = t.split(/(?:\t)/),
                r = this.style.tabs,
                o = 0;
            if (Array.isArray(r))
                for (var a = 0, h = 0; h < s.length; h++) h > 0 && (a += r[h - 1]), o = e + a, n ? this.context.fillText(s[h], o, i) : this.context.strokeText(s[h], o, i);
            else
                for (h = 0; h < s.length; h++) {
                    var l = Math.ceil(this.context.measureText(s[h]).width);
                    o = this.game.math.snapToCeil(e, r), n ? this.context.fillText(s[h], o, i) : this.context.strokeText(s[h], o, i), e = o + l
                }
        }, i.Text.prototype.updateShadow = function(t) {
            t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
        }, i.Text.prototype.measureLine = function(t) {
            for (var e = 0, i = 0; i < t.length; i++) {
                var n = t[i];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var s = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (s.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (s.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(s)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(n).width, this._charCount++
            }
            return Math.ceil(e)
        }, i.Text.prototype.updateLine = function(t, e, i) {
            for (var n = 0; n < t.length; n++) {
                var s = t[n];
                if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                    var r = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (r.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (r.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(r)
                }
                this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(s, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(s, e, i)), e += this.context.measureText(s).width, this._charCount++
            }
        }, i.Text.prototype.clearColors = function() {
            return this.colors = [], this.strokeColors = [], this.dirty = !0, this
        }, i.Text.prototype.clearFontValues = function() {
            return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
        }, i.Text.prototype.addColor = function(t, e) {
            return this.colors[e] = t, this.dirty = !0, this
        }, i.Text.prototype.addStrokeColor = function(t, e) {
            return this.strokeColors[e] = t, this.dirty = !0, this
        }, i.Text.prototype.addFontStyle = function(t, e) {
            return this.fontStyles[e] = t, this.dirty = !0, this
        }, i.Text.prototype.addFontWeight = function(t, e) {
            return this.fontWeights[e] = t, this.dirty = !0, this
        }, i.Text.prototype.precalculateWordWrap = function(t) {
            return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
        }, i.Text.prototype.runWordWrap = function(t) {
            return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
        }, i.Text.prototype.advancedWordWrap = function(t) {
            for (var e = this.context, i = this.style.wordWrapWidth, n = "", s = t.replace(/ +/gi, " ").split(/\r?\n/gi), r = s.length, o = 0; o < r; o++) {
                var a = s[o],
                    h = "";
                if (a = a.replace(/^ *|\s*$/gi, ""), e.measureText(a).width < i) n += a + "\n";
                else {
                    for (var l = i, c = a.split(" "), u = 0; u < c.length; u++) {
                        var d = c[u],
                            p = d + " ",
                            f = e.measureText(p).width;
                        if (f > l) {
                            if (0 === u) {
                                for (var g = p; g.length && (g = g.slice(0, -1), !((f = e.measureText(g).width) <= l)););
                                if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                var m = d.substr(g.length);
                                c[u] = m, h += g
                            }
                            var y = c[u].length ? u : u + 1,
                                v = c.slice(y).join(" ").replace(/[ \n]*$/gi, "");
                            s[o + 1] = v + " " + (s[o + 1] || ""), r = s.length;
                            break
                        }
                        h += p, l -= f
                    }
                    n += h.replace(/[ \n]*$/gi, "") + "\n"
                }
            }
            return n = n.replace(/[\s|\n]*$/gi, "")
        }, i.Text.prototype.basicWordWrap = function(t) {
            for (var e = "", i = t.split("\n"), n = 0; n < i.length; n++) {
                for (var s = this.style.wordWrapWidth, r = i[n].split(" "), o = 0; o < r.length; o++) {
                    var a = this.context.measureText(r[o]).width,
                        h = a + this.context.measureText(" ").width;
                    h > s ? (o > 0 && (e += "\n"), e += r[o] + " ", s = this.style.wordWrapWidth - a) : (s -= h, e += r[o] + " ")
                }
                n < i.length - 1 && (e += "\n")
            }
            return e
        }, i.Text.prototype.updateFont = function(t) {
            var e = this.componentsToFont(t);
            this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
        }, i.Text.prototype.fontToComponents = function(t) {
            var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
            if (e) {
                var i = e[5].trim();
                return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                    font: t,
                    fontStyle: e[1] || "normal",
                    fontVariant: e[2] || "normal",
                    fontWeight: e[3] || "normal",
                    fontSize: e[4] || "medium",
                    fontFamily: i
                }
            }
            return {
                font: t
            }
        }, i.Text.prototype.componentsToFont = function(t) {
            var e, i = [];
            return (e = t.fontStyle) && "normal" !== e && i.push(e), (e = t.fontVariant) && "normal" !== e && i.push(e), (e = t.fontWeight) && "normal" !== e && i.push(e), (e = t.fontSize) && "medium" !== e && i.push(e), (e = t.fontFamily) && i.push(e), i.length || i.push(t.font), i.join(" ")
        }, i.Text.prototype.setText = function(t, e) {
            return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this
        }, i.Text.prototype.parseList = function(t) {
            if (!Array.isArray(t)) return this;
            for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
            return this.text = e, this.dirty = !0, this
        }, i.Text.prototype.setTextBounds = function(t, e, n, s) {
            return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, n, s) : this.textBounds = new i.Rectangle(t, e, n, s), this.style.wordWrapWidth > n && (this.style.wordWrapWidth = n)), this.updateTexture(), this
        }, i.Text.prototype.updateTexture = function() {
            var t = this.texture.baseTexture,
                e = this.texture.crop,
                i = this.texture.frame,
                n = this.canvas.width,
                s = this.canvas.height;
            if (t.width = n, t.height = s, e.width = n, e.height = s, i.width = n, i.height = s, this.texture.width = n, this.texture.height = s, this._width = n, this._height = s, this.textBounds) {
                var r = this.textBounds.x,
                    o = this.textBounds.y;
                "right" === this.style.boundsAlignH ? r += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (r += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? o += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (o += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -r, this.pivot.y = -o
            }
            this.renderable = 0 !== n && 0 !== s, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
        }, i.Text.prototype._renderWebGL = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, i.Text.prototype._renderCanvas = function(t) {
            this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, i.Text.prototype.determineFontProperties = function(t) {
            var e = i.Text.fontPropertiesCache[t];
            if (!e) {
                e = {};
                var n = i.Text.fontPropertiesCanvas,
                    s = i.Text.fontPropertiesContext;
                s.font = t;
                var r = Math.ceil(s.measureText("|MÉq").width),
                    o = Math.ceil(s.measureText("|MÉq").width),
                    a = 2 * o;
                if (o = 1.4 * o | 0, n.width = r, n.height = a, s.fillStyle = "#f00", s.fillRect(0, 0, r, a), s.font = t, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText("|MÉq", 0, o), !s.getImageData(0, 0, r, a)) return e.ascent = o, e.descent = o + 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e, e;
                var h, l, c = s.getImageData(0, 0, r, a).data,
                    u = c.length,
                    d = 4 * r,
                    p = 0,
                    f = !1;
                for (h = 0; h < o; h++) {
                    for (l = 0; l < d; l += 4)
                        if (255 !== c[p + l]) {
                            f = !0;
                            break
                        }
                    if (f) break;
                    p += d
                }
                for (e.ascent = o - h, p = u - d, f = !1, h = a; h > o; h--) {
                    for (l = 0; l < d; l += 4)
                        if (255 !== c[p + l]) {
                            f = !0;
                            break
                        }
                    if (f) break;
                    p -= d
                }
                e.descent = h - o, e.descent += 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e
            }
            return e
        }, i.Text.prototype.getBounds = function(t) {
            return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
        }, Object.defineProperty(i.Text.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(i.Text.prototype, "cssFont", {
            get: function() {
                return this.componentsToFont(this._fontComponents)
            },
            set: function(t) {
                t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "font", {
            get: function() {
                return this._fontComponents.fontFamily
            },
            set: function(t) {
                t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontSize", {
            get: function() {
                var t = this._fontComponents.fontSize;
                return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
            },
            set: function(t) {
                "number" == typeof(t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontWeight", {
            get: function() {
                return this._fontComponents.fontWeight || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontStyle", {
            get: function() {
                return this._fontComponents.fontStyle || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fontVariant", {
            get: function() {
                return this._fontComponents.fontVariant || "normal"
            },
            set: function(t) {
                t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
            }
        }), Object.defineProperty(i.Text.prototype, "fill", {
            get: function() {
                return this.style.fill
            },
            set: function(t) {
                t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "align", {
            get: function() {
                return this.style.align
            },
            set: function(t) {
                t !== this.style.align && (this.style.align = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "resolution", {
            get: function() {
                return this._res
            },
            set: function(t) {
                t !== this._res && (this._res = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "tabs", {
            get: function() {
                return this.style.tabs
            },
            set: function(t) {
                t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "boundsAlignH", {
            get: function() {
                return this.style.boundsAlignH
            },
            set: function(t) {
                t !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "boundsAlignV", {
            get: function() {
                return this.style.boundsAlignV
            },
            set: function(t) {
                t !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "stroke", {
            get: function() {
                return this.style.stroke
            },
            set: function(t) {
                t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "strokeThickness", {
            get: function() {
                return this.style.strokeThickness
            },
            set: function(t) {
                t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "wordWrap", {
            get: function() {
                return this.style.wordWrap
            },
            set: function(t) {
                t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "wordWrapWidth", {
            get: function() {
                return this.style.wordWrapWidth
            },
            set: function(t) {
                t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "lineSpacing", {
            get: function() {
                return this._lineSpacing
            },
            set: function(t) {
                t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
            }
        }), Object.defineProperty(i.Text.prototype, "shadowOffsetX", {
            get: function() {
                return this.style.shadowOffsetX
            },
            set: function(t) {
                t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowOffsetY", {
            get: function() {
                return this.style.shadowOffsetY
            },
            set: function(t) {
                t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowColor", {
            get: function() {
                return this.style.shadowColor
            },
            set: function(t) {
                t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowBlur", {
            get: function() {
                return this.style.shadowBlur
            },
            set: function(t) {
                t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowStroke", {
            get: function() {
                return this.style.shadowStroke
            },
            set: function(t) {
                t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "shadowFill", {
            get: function() {
                return this.style.shadowFill
            },
            set: function(t) {
                t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
            }
        }), Object.defineProperty(i.Text.prototype, "width", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(i.Text.prototype, "height", {
            get: function() {
                return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), i.Text.fontPropertiesCache = {}, i.Text.fontPropertiesCanvas = document.createElement("canvas"), i.Text.fontPropertiesContext = i.Text.fontPropertiesCanvas.getContext("2d"), i.BitmapText = function(t, e, n, s, r, o, a) {
            e = e || 0, n = n || 0, s = s || "", r = r || "", o = o || 32, a = a || "left", PIXI.DisplayObjectContainer.call(this), this.type = i.BITMAPTEXT, this.physicsType = i.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new i.Point, this._prevAnchor = new i.Point, this._glyphs = [], this._maxWidth = 0, this._text = r.toString() || "", this._data = t.cache.getBitmapFont(s), this._font = s, this._fontSize = o, this._align = a, this._tint = 16777215, this.updateText(), this.dirty = !1, i.Component.Core.init.call(this, t, e, n, "", null)
        }, i.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.BitmapText.prototype.constructor = i.BitmapText, i.Component.Core.install.call(i.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.BitmapText.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.BitmapText.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.BitmapText.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.BitmapText.prototype.preUpdateCore = i.Component.Core.preUpdate, i.BitmapText.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.BitmapText.prototype.postUpdate = function() {
            i.Component.PhysicsBody.postUpdate.call(this), i.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === i.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
        }, i.BitmapText.prototype.setText = function(t) {
            this.text = t
        }, i.BitmapText.prototype.scanLine = function(t, e, i) {
            for (var n = 0, s = 0, r = -1, o = 0, a = null, h = this._maxWidth > 0 ? this._maxWidth : null, l = [], c = 0; c < i.length; c++) {
                var u = c === i.length - 1;
                if (/(?:\r\n|\r|\n)/.test(i.charAt(c))) return {
                    width: s,
                    text: i.substr(0, c),
                    end: u,
                    chars: l
                };
                var d, p = i.charCodeAt(c),
                    f = t.chars[p];
                void 0 === f && (p = 32, f = t.chars[p]);
                var g = a && f.kerning[a] ? f.kerning[a] : 0;
                if (/(\s)/.test(i.charAt(c)) && (r = c, o = s), d = (g + f.texture.width + f.xOffset) * e, h && s + d >= h && r > -1) return {
                    width: o || s,
                    text: i.substr(0, c - (c - r)),
                    end: u,
                    chars: l
                };
                s += (f.xAdvance + g) * e, l.push(n + (f.xOffset + g) * e), n += (f.xAdvance + g) * e, a = p
            }
            return {
                width: s,
                text: i,
                end: u,
                chars: l
            }
        }, i.BitmapText.prototype.cleanText = function(t, e) {
            void 0 === e && (e = "");
            var i = this._data.font;
            if (!i) return "";
            for (var n = t.replace(/\r\n|\n\r|\n|\r/g, "\n").split("\n"), s = 0; s < n.length; s++) {
                for (var r = "", o = n[s], a = 0; a < o.length; a++) r = i.chars[o.charCodeAt(a)] ? r.concat(o[a]) : r.concat(e);
                n[s] = r
            }
            return n.join("\n")
        }, i.BitmapText.prototype.updateText = function() {
            var t = this._data.font;
            if (t) {
                var e = this.text,
                    i = this._fontSize / t.size,
                    n = [],
                    s = 0;
                this.textWidth = 0;
                do {
                    (c = this.scanLine(t, i, e)).y = s, n.push(c), c.width > this.textWidth && (this.textWidth = c.width), s += t.lineHeight * i, e = e.substr(c.text.length + 1)
                } while (!1 === c.end);
                this.textHeight = s;
                for (var r = 0, o = 0, a = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, l = 0; l < n.length; l++) {
                    var c = n[l];
                    "right" === this._align ? o = this.textWidth - c.width : "center" === this._align && (o = (this.textWidth - c.width) / 2);
                    for (var u = 0; u < c.text.length; u++) {
                        var d = c.text.charCodeAt(u),
                            p = t.chars[d];
                        void 0 === p && (d = 32, p = t.chars[d]);
                        var f = this._glyphs[r];
                        f ? f.texture = p.texture : ((f = new PIXI.Sprite(p.texture)).name = c.text[u], this._glyphs.push(f)), f.position.x = c.chars[u] + o - a, f.position.y = c.y + p.yOffset * i - h, f.scale.set(i), f.tint = this.tint, f.texture.requiresReTint = !0, f.parent || this.addChild(f), r++
                    }
                }
                for (l = r; l < this._glyphs.length; l++) this.removeChild(this._glyphs[l])
            }
        }, i.BitmapText.prototype.purgeGlyphs = function() {
            for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
            return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
        }, i.BitmapText.prototype.updateTransform = function() {
            !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
        }, Object.defineProperty(i.BitmapText.prototype, "align", {
            get: function() {
                return this._align
            },
            set: function(t) {
                t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "tint", {
            get: function() {
                return this._tint
            },
            set: function(t) {
                t !== this._tint && (this._tint = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "font", {
            get: function() {
                return this._font
            },
            set: function(t) {
                t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "fontSize", {
            get: function() {
                return this._fontSize
            },
            set: function(t) {
                (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                t !== this._text && (this._text = t.toString() || "", this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "maxWidth", {
            get: function() {
                return this._maxWidth
            },
            set: function(t) {
                t !== this._maxWidth && (this._maxWidth = t, this.updateText())
            }
        }), Object.defineProperty(i.BitmapText.prototype, "smoothed", {
            get: function() {
                return !this._data.base.scaleMode
            },
            set: function(t) {
                this._data.base.scaleMode = t ? 0 : 1
            }
        }), i.RetroFont = function(t, e, n, s, r, o, a, h, l, c) {
            if (!t.cache.checkImageKey(e)) return !1;
            void 0 !== o && null !== o || (o = t.cache.getImage(e).width / n), this.characterWidth = n, this.characterHeight = s, this.characterSpacingX = a || 0, this.characterSpacingY = h || 0, this.characterPerRow = o, this.offsetX = l || 0, this.offsetY = c || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = t.cache.getImage(e), this._text = "", this.grabData = [], this.frameData = new i.FrameData;
            for (var u = this.offsetX, d = this.offsetY, p = 0, f = 0; f < r.length; f++) {
                var g = this.frameData.addFrame(new i.Frame(f, u, d, this.characterWidth, this.characterHeight));
                this.grabData[r.charCodeAt(f)] = g.index, ++p === this.characterPerRow ? (p = 0, u = this.offsetX, d += this.characterHeight + this.characterSpacingY) : u += this.characterWidth + this.characterSpacingX
            }
            t.cache.updateFrameData(e, this.frameData), this.stamp = new i.Image(t, 0, 0, e, 0), i.RenderTexture.call(this, t, 100, 100, "", i.scaleModes.NEAREST), this.type = i.RETROFONT
        }, i.RetroFont.prototype = Object.create(i.RenderTexture.prototype), i.RetroFont.prototype.constructor = i.RetroFont, i.RetroFont.ALIGN_LEFT = "left", i.RetroFont.ALIGN_RIGHT = "right", i.RetroFont.ALIGN_CENTER = "center", i.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", i.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", i.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", i.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", i.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", i.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", i.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", i.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", i.RetroFont.prototype.setFixedWidth = function(t, e) {
            void 0 === e && (e = "left"), this.fixedWidth = t, this.align = e
        }, i.RetroFont.prototype.setText = function(t, e, i, n, s, r) {
            this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = n || 0, this.align = s || "left", this.autoUpperCase = !r, t.length > 0 && (this.text = t)
        }, i.RetroFont.prototype.buildRetroFontText = function() {
            var t = 0,
                e = 0;
            if (this.clear(), this.multiLine) {
                var n = this._text.split("\n");
                this.fixedWidth > 0 ? this.resize(this.fixedWidth, n.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), n.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                for (var s = 0; s < n.length; s++) t = 0, this.align === i.RetroFont.ALIGN_RIGHT ? t = this.width - n[s].length * (this.characterWidth + this.customSpacingX) : this.align === i.RetroFont.ALIGN_CENTER && (t = this.width / 2 - n[s].length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(n[s], t, e, this.customSpacingX), e += this.characterHeight + this.customSpacingY
            } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), t = 0, this.align === i.RetroFont.ALIGN_RIGHT ? t = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === i.RetroFont.ALIGN_CENTER && (t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(this._text, t, 0, this.customSpacingX);
            this.requiresReTint = !0
        }, i.RetroFont.prototype.pasteLine = function(t, e, i, n) {
            for (var s = 0; s < t.length; s++)
                if (" " === t.charAt(s)) e += this.characterWidth + n;
                else if (this.grabData[t.charCodeAt(s)] >= 0 && (this.stamp.frame = this.grabData[t.charCodeAt(s)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + n) > this.width)) break
        }, i.RetroFont.prototype.getLongestLine = function() {
            var t = 0;
            if (this._text.length > 0)
                for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
            return t
        }, i.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
            for (var e = "", i = 0; i < this._text.length; i++) {
                var n = this._text[i],
                    s = n.charCodeAt(0);
                (this.grabData[s] >= 0 || !t && "\n" === n) && (e = e.concat(n))
            }
            return e
        }, i.RetroFont.prototype.updateOffset = function(t, e) {
            if (this.offsetX !== t || this.offsetY !== e) {
                for (var i = t - this.offsetX, n = e - this.offsetY, s = this.game.cache.getFrameData(this.stamp.key).getFrames(), r = s.length; r--;) s[r].x += i, s[r].y += n;
                this.buildRetroFontText()
            }
        }, Object.defineProperty(i.RetroFont.prototype, "text", {
            get: function() {
                return this._text
            },
            set: function(t) {
                var e;
                (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
            }
        }), Object.defineProperty(i.RetroFont.prototype, "smoothed", {
            get: function() {
                return this.stamp.smoothed
            },
            set: function(t) {
                this.stamp.smoothed = t, this.buildRetroFontText()
            }
        }), i.Rope = function(t, e, n, s, r, o) {
            this.points = [], this.points = o, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, e = e || 0, n = n || 0, s = s || null, r = r || null, this.type = i.ROPE, PIXI.Rope.call(this, i.Cache.DEFAULT, this.points), i.Component.Core.init.call(this, t, e, n, s, r)
        }, i.Rope.prototype = Object.create(PIXI.Rope.prototype), i.Rope.prototype.constructor = i.Rope, i.Component.Core.install.call(i.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Rope.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Rope.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Rope.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Rope.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Rope.prototype.preUpdate = function() {
            return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.Rope.prototype.update = function() {
            this._hasUpdateAnimation && this.updateAnimation.call(this)
        }, i.Rope.prototype.reset = function(t, e) {
            return i.Component.Reset.prototype.reset.call(this, t, e), this
        }, Object.defineProperty(i.Rope.prototype, "updateAnimation", {
            get: function() {
                return this._updateAnimation
            },
            set: function(t) {
                t && "function" == typeof t ? (this._hasUpdateAnimation = !0, this._updateAnimation = t) : (this._hasUpdateAnimation = !1, this._updateAnimation = null)
            }
        }), Object.defineProperty(i.Rope.prototype, "segments", {
            get: function() {
                for (var t, e, n, s, r, o, a, h, l = [], c = 0; c < this.points.length; c++) t = 4 * c, e = this.vertices[t] * this.scale.x, n = this.vertices[t + 1] * this.scale.y, s = this.vertices[t + 4] * this.scale.x, r = this.vertices[t + 3] * this.scale.y, o = i.Math.difference(e, s), a = i.Math.difference(n, r), e += this.world.x, n += this.world.y, h = new i.Rectangle(e, n, o, a), l.push(h);
                return l
            }
        }), i.TileSprite = function(t, e, n, s, r, o, a) {
            e = e || 0, n = n || 0, s = s || 256, r = r || 256, o = o || null, a = a || null, this.type = i.TILESPRITE, this.physicsType = i.SPRITE, this._scroll = new i.Point;
            var h = t.cache.getImage("__default", !0);
            PIXI.TilingSprite.call(this, new PIXI.Texture(h.base), s, r), i.Component.Core.init.call(this, t, e, n, o, a)
        }, i.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), i.TileSprite.prototype.constructor = i.TileSprite, i.Component.Core.install.call(i.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), i.TileSprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.TileSprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.TileSprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.TileSprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.TileSprite.prototype.preUpdate = function() {
            return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
        }, i.TileSprite.prototype.autoScroll = function(t, e) {
            this._scroll.set(t, e)
        }, i.TileSprite.prototype.stopScroll = function() {
            this._scroll.set(0, 0)
        }, i.TileSprite.prototype.destroy = function(t) {
            i.Component.Destroy.prototype.destroy.call(this, t), PIXI.TilingSprite.prototype.destroy.call(this)
        }, i.TileSprite.prototype.reset = function(t, e) {
            return i.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this
        }, i.Device = function() {
            this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
        }, i.Device = new i.Device, i.Device.onInitialized = new i.Signal, i.Device.whenReady = function(t, e, i) {
            var n = this._readyCheck;
            if (this.deviceReadyAt || !n) t.call(e, this);
            else if (n._monitor || i) n._queue = n._queue || [], n._queue.push([t, e]);
            else {
                n._monitor = n.bind(this), n._queue = n._queue || [], n._queue.push([t, e]);
                var s = void 0 !== window.cordova,
                    r = navigator.isCocoonJS;
                "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(n._monitor, 0) : s && !r ? document.addEventListener("deviceready", n._monitor, !1) : (document.addEventListener("DOMContentLoaded", n._monitor, !1), window.addEventListener("load", n._monitor, !1))
            }
        }, i.Device._readyCheck = function() {
            var t = this._readyCheck;
            if (document.body) {
                if (!this.deviceReadyAt) {
                    var e;
                    for (this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this); e = t._queue.shift();) {
                        var i = e[0],
                            n = e[1];
                        i.call(n, this)
                    }
                    this._readyCheck = null, this._initialize = null, this.onInitialized = null
                }
            } else window.setTimeout(t._monitor, 20)
        }, i.Device._initialize = function() {
            var t, e, i, n = this;
            ! function() {
                var t = navigator.userAgent;
                /Playstation Vita/.test(t) ? n.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? n.kindle = !0 : /Android/.test(t) ? n.android = !0 : /CrOS/.test(t) ? n.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (n.iOS = !0, navigator.appVersion.match(/OS (\d+)/), n.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? n.linux = !0 : /Mac OS/.test(t) ? n.macOS = !0 : /Windows/.test(t) && (n.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (n.android = !1, n.iOS = !1, n.macOS = !1, n.windows = !0, n.windowsPhone = !0);
                var e = /Silk/.test(t);
                (n.windows || n.macOS || n.linux && !e || n.chromeOS) && (n.desktop = !0), (n.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (n.desktop = !1)
            }(),
            function() {
                var t = navigator.userAgent;
                if (/Arora/.test(t) ? n.arora = !0 : /Edge\/\d+/.test(t) ? n.edge = !0 : /Chrome\/(\d+)/.test(t) && !n.windowsPhone ? (n.chrome = !0, n.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? n.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (n.firefox = !0, n.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && n.iOS ? n.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (n.ie = !0, n.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? n.midori = !0 : /Opera/.test(t) ? n.opera = !0 : /Safari\/(\d+)/.test(t) && !n.windowsPhone ? (n.safari = !0, /Version\/(\d+)\./.test(t) && (n.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (n.ie = !0, n.trident = !0, n.tridentVersion = parseInt(RegExp.$1, 10), n.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (n.silk = !0), navigator.standalone && (n.webApp = !0), void 0 !== window.cordova && (n.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (n.node = !0), n.node && "object" == typeof process.versions && (n.nodeWebkit = !!process.versions["node-webkit"], n.electron = !!process.versions.electron), navigator.isCocoonJS && (n.cocoonJS = !0), n.cocoonJS) try {
                    n.cocoonJSApp = "undefined" != typeof CocoonJS
                } catch (t) {
                    n.cocoonJSApp = !1
                }
                void 0 !== window.ejecta && (n.ejecta = !0), /Crosswalk/.test(t) && (n.crosswalk = !0)
            }(),
            function() {
                n.audioData = !!window.Audio, n.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                var t = document.createElement("audio");
                try {
                    if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (n.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (n.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (n.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (n.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (n.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (n.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                        if (n.edge) n.dolby = !0;
                        else if (n.safari && n.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                        var e = parseInt(RegExp.$1, 10),
                            i = parseInt(RegExp.$2, 10);
                        (10 === e && i >= 11 || e > 10) && (n.dolby = !0)
                    }
                } catch (t) {}
            }(),
            function() {
                var t = document.createElement("video");
                try {
                    t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (n.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.h264Video = !0, n.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (n.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (n.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (n.hlsVideo = !0))
                } catch (t) {}
            }(),
            function() {
                var t, e = document.createElement("p"),
                    i = {
                        webkitTransform: "-webkit-transform",
                        OTransform: "-o-transform",
                        msTransform: "-ms-transform",
                        MozTransform: "-moz-transform",
                        transform: "transform"
                    };
                for (var s in document.body.insertBefore(e, null), i) void 0 !== e.style[s] && (e.style[s] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(i[s]));
                document.body.removeChild(e), n.css3D = void 0 !== t && t.length > 0 && "none" !== t
            }(), n.pixelRatio = window.devicePixelRatio || 1, n.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), n.iPhone4 = 2 === n.pixelRatio && n.iPhone, n.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? n.typedArray = !0 : n.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (n.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null), n.LITTLE_ENDIAN = n.littleEndian), n.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== n.littleEndian && function() {
                    if (void 0 === Uint8ClampedArray) return !1;
                    var t = PIXI.CanvasPool.create(this, 1, 1).getContext("2d");
                    if (!t) return !1;
                    var e = t.createImageData(1, 1);
                    return PIXI.CanvasPool.remove(this), e.data instanceof Uint8ClampedArray
                }(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (n.vibration = !0),
                function() {
                    n.canvas = !!window.CanvasRenderingContext2D || n.cocoonJS;
                    try {
                        n.localStorage = !!localStorage.getItem
                    } catch (t) {
                        n.localStorage = !1
                    }
                    n.file = !!(window.File && window.FileReader && window.FileList && window.Blob), n.fileSystem = !!window.requestFileSystem, n.webGL = function() {
                        try {
                            var t = document.createElement("canvas");
                            return t.screencanvas = !1, !!window.WebGLRenderingContext && (t.getContext("webgl") || t.getContext("experimental-webgl"))
                        } catch (t) {
                            return !1
                        }
                    }(), n.webGL = !!n.webGL, n.worker = !!window.Worker, n.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, n.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, n.getUserMedia = n.getUserMedia && !!navigator.getUserMedia && !!window.URL, n.firefox && n.firefoxVersion < 21 && (n.getUserMedia = !1), !n.iOS && (n.ie || n.firefox || n.chrome) && (n.canvasBitBltShift = !0), (n.safari || n.mobileSafari) && (n.canvasBitBltShift = !1)
                }(),
                function() {
                    for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), i = 0; i < t.length; i++)
                        if (e[t[i]]) {
                            n.fullscreen = !0, n.requestFullscreen = t[i];
                            break
                        }
                    var s = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                    if (n.fullscreen)
                        for (i = 0; i < s.length; i++)
                            if (document[s[i]]) {
                                n.cancelFullscreen = s[i];
                                break
                            }
                    window.Element && Element.ALLOW_KEYBOARD_INPUT && (n.fullscreenKeyboard = !0)
                }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (n.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (n.mspointer = !0), n.cocoonJS || ("onwheel" in window || n.ie && "WheelEvent" in window ? n.wheelEvent = "wheel" : "onmousewheel" in window ? n.wheelEvent = "mousewheel" : n.firefox && "MouseScrollEvent" in window && (n.wheelEvent = "DOMMouseScroll"))
        }, i.Device.canPlayAudio = function(t) {
            return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby))))))
        }, i.Device.canPlayVideo = function(t) {
            return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo)))
        }, i.Device.isConsoleOpen = function() {
            return !(!window.console || !window.console.firebug) || !(!window.console || (console.clear, !console.profiles)) && console.profiles.length > 0
        }, i.Device.isAndroidStockBrowser = function() {
            var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
            return t && t[1] < 537
        }, i.Canvas = {
            create: function(t, e, i, n, s) {
                e = e || 256, i = i || 256;
                var r = s ? document.createElement("canvas") : PIXI.CanvasPool.create(t, e, i);
                return "string" == typeof n && "" !== n && (r.id = n), r.width = e, r.height = i, r.style.display = "block", r
            },
            setBackgroundColor: function(t, e) {
                return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
            },
            setTouchAction: function(t, e) {
                return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
            },
            setUserSelect: function(t, e) {
                return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
            },
            addToDOM: function(t, e, i) {
                var n;
                return void 0 === i && (i = !0), e && ("string" == typeof e ? n = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (n = e)), n || (n = document.body), i && n.style && (n.style.overflow = "hidden"), n.appendChild(t), t
            },
            removeFromDOM: function(t) {
                t.parentNode && t.parentNode.removeChild(t)
            },
            setTransform: function(t, e, i, n, s, r, o) {
                return t.setTransform(n, r, o, s, e, i), t
            },
            setSmoothingEnabled: function(t, e) {
                var n = i.Canvas.getSmoothingPrefix(t);
                return n && (t[n] = e), t
            },
            getSmoothingPrefix: function(t) {
                var e = ["i", "webkitI", "msI", "mozI", "oI"];
                for (var i in e) {
                    var n = e[i] + "mageSmoothingEnabled";
                    if (n in t) return n
                }
                return null
            },
            getSmoothingEnabled: function(t) {
                var e = i.Canvas.getSmoothingPrefix(t);
                if (e) return t[e]
            },
            setImageRenderingCrisp: function(t) {
                for (var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                return t.style.msInterpolationMode = "nearest-neighbor", t
            },
            setImageRenderingBicubic: function(t) {
                return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
            }
        }, i.RequestAnimationFrame = function(t, e) {
            void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
            for (var i = ["ms", "moz", "webkit", "o"], n = 0; n < i.length && !window.requestAnimationFrame; n++) window.requestAnimationFrame = window[i[n] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[n] + "CancelAnimationFrame"];
            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
        }, i.RequestAnimationFrame.prototype = {
            start: function() {
                this.isRunning = !0;
                var t = this;
                !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                    return t.updateSetTimeout()
                }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                    return t.updateRAF(e)
                }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateRAF: function(t) {
                this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
            },
            updateSetTimeout: function() {
                this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
            },
            stop: function() {
                this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
            },
            isSetTimeOut: function() {
                return this._isSetTimeOut
            },
            isRAF: function() {
                return !1 === this._isSetTimeOut
            }
        }, i.RequestAnimationFrame.prototype.constructor = i.RequestAnimationFrame, i.Math = {
            PI2: 2 * Math.PI,
            between: function(t, e) {
                return Math.floor(Math.random() * (e - t + 1) + t)
            },
            fuzzyEqual: function(t, e, i) {
                return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
            },
            fuzzyLessThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t < e + i
            },
            fuzzyGreaterThan: function(t, e, i) {
                return void 0 === i && (i = 1e-4), t > e - i
            },
            fuzzyCeil: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.ceil(t - e)
            },
            fuzzyFloor: function(t, e) {
                return void 0 === e && (e = 1e-4), Math.floor(t + e)
            },
            average: function() {
                for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                return t / e
            },
            shear: function(t) {
                return t % 1
            },
            snapTo: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.round(t / e)))
            },
            snapToFloor: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.floor(t / e)))
            },
            snapToCeil: function(t, e, i) {
                return void 0 === i && (i = 0), 0 === e ? t : (t -= i, i + (t = e * Math.ceil(t / e)))
            },
            roundTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var n = Math.pow(i, -e);
                return Math.round(t * n) / n
            },
            floorTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var n = Math.pow(i, -e);
                return Math.floor(t * n) / n
            },
            ceilTo: function(t, e, i) {
                void 0 === e && (e = 0), void 0 === i && (i = 10);
                var n = Math.pow(i, -e);
                return Math.ceil(t * n) / n
            },
            rotateToAngle: function(t, e, n) {
                return void 0 === n && (n = .05), t === e ? t : (Math.abs(e - t) <= n || Math.abs(e - t) >= i.Math.PI2 - n ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += i.Math.PI2 : e -= i.Math.PI2), e > t ? t += n : e < t && (t -= n)), t)
            },
            getShortestAngle: function(t, e) {
                var i = e - t;
                return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
            },
            angleBetween: function(t, e, i, n) {
                return Math.atan2(n - e, i - t)
            },
            angleBetweenY: function(t, e, i, n) {
                return Math.atan2(i - t, n - e)
            },
            angleBetweenPoints: function(t, e) {
                return Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenPointsY: function(t, e) {
                return Math.atan2(e.x - t.x, e.y - t.y)
            },
            reverseAngle: function(t) {
                return this.normalizeAngle(t + Math.PI, !0)
            },
            normalizeAngle: function(t) {
                return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI
            },
            maxAdd: function(t, e, i) {
                return Math.min(t + e, i)
            },
            minSub: function(t, e, i) {
                return Math.max(t - e, i)
            },
            wrap: function(t, e, i) {
                var n = i - e;
                if (n <= 0) return 0;
                var s = (t - e) % n;
                return s < 0 && (s += n), s + e
            },
            wrapValue: function(t, e, i) {
                return ((t = Math.abs(t)) + (e = Math.abs(e))) % (i = Math.abs(i))
            },
            isOdd: function(t) {
                return !!(1 & t)
            },
            isEven: function(t) {
                return !(1 & t)
            },
            min: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                else t = arguments;
                for (var e = 1, i = 0, n = t.length; e < n; e++) t[e] < t[i] && (i = e);
                return t[i]
            },
            max: function() {
                if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                else t = arguments;
                for (var e = 1, i = 0, n = t.length; e < n; e++) t[e] > t[i] && (i = e);
                return t[i]
            },
            minProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                else e = arguments.slice(1);
                for (var i = 1, n = 0, s = e.length; i < s; i++) e[i][t] < e[n][t] && (n = i);
                return e[n][t]
            },
            maxProperty: function(t) {
                if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                else e = arguments.slice(1);
                for (var i = 1, n = 0, s = e.length; i < s; i++) e[i][t] > e[n][t] && (n = i);
                return e[n][t]
            },
            wrapAngle: function(t, e) {
                return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
            },
            linearInterpolation: function(t, e) {
                var i = t.length - 1,
                    n = i * e,
                    s = Math.floor(n);
                return e < 0 ? this.linear(t[0], t[1], n) : e > 1 ? this.linear(t[i], t[i - 1], i - n) : this.linear(t[s], t[s + 1 > i ? i : s + 1], n - s)
            },
            bezierInterpolation: function(t, e) {
                for (var i = 0, n = t.length - 1, s = 0; s <= n; s++) i += Math.pow(1 - e, n - s) * Math.pow(e, s) * t[s] * this.bernstein(n, s);
                return i
            },
            catmullRomInterpolation: function(t, e) {
                var i = t.length - 1,
                    n = i * e,
                    s = Math.floor(n);
                return t[0] === t[i] ? (e < 0 && (s = Math.floor(n = i * (1 + e))), this.catmullRom(t[(s - 1 + i) % i], t[s], t[(s + 1) % i], t[(s + 2) % i], n - s)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -n) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], n - i) - t[i]) : this.catmullRom(t[s ? s - 1 : 0], t[s], t[i < s + 1 ? i : s + 1], t[i < s + 2 ? i : s + 2], n - s)
            },
            linear: function(t, e, i) {
                return (e - t) * i + t
            },
            bernstein: function(t, e) {
                return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
            },
            factorial: function(t) {
                if (0 === t) return 1;
                for (var e = t; --t;) e *= t;
                return e
            },
            catmullRom: function(t, e, i, n, s) {
                var r = .5 * (i - t),
                    o = .5 * (n - e),
                    a = s * s;
                return (2 * e - 2 * i + r + o) * (s * a) + (-3 * e + 3 * i - 2 * r - o) * a + r * s + e
            },
            difference: function(t, e) {
                return Math.abs(t - e)
            },
            roundAwayFromZero: function(t) {
                return t > 0 ? Math.ceil(t) : Math.floor(t)
            },
            sinCosGenerator: function(t, e, i, n) {
                void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = 1);
                for (var s = e, r = i, o = n * Math.PI / t, a = [], h = [], l = 0; l < t; l++) s += (r -= s * o) * o, a[l] = r, h[l] = s;
                return {
                    sin: h,
                    cos: a,
                    length: t
                }
            },
            distance: function(t, e, i, n) {
                var s = t - i,
                    r = e - n;
                return Math.sqrt(s * s + r * r)
            },
            distanceSq: function(t, e, i, n) {
                var s = t - i,
                    r = e - n;
                return s * s + r * r
            },
            distancePow: function(t, e, i, n, s) {
                return void 0 === s && (s = 2), Math.sqrt(Math.pow(i - t, s) + Math.pow(n - e, s))
            },
            clamp: function(t, e, i) {
                return t < e ? e : i < t ? i : t
            },
            clampBottom: function(t, e) {
                return t < e ? e : t
            },
            within: function(t, e, i) {
                return Math.abs(t - e) <= i
            },
            mapLinear: function(t, e, i, n, s) {
                return n + (t - e) * (s - n) / (i - e)
            },
            smoothstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
            },
            sign: function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : 0
            },
            percent: function(t, e, i) {
                return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
            }
        };
        var a = Math.PI / 180,
            h = 180 / Math.PI;
        return i.Math.degToRad = function(t) {
            return t * a
        }, i.Math.radToDeg = function(t) {
            return t * h
        }, i.RandomDataGenerator = function(t) {
            void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
        }, i.RandomDataGenerator.prototype = {
            rnd: function() {
                var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
            },
            sow: function(t) {
                if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                    for (var e = 0; e < t.length && null != t[e]; e++) {
                        var i = t[e];
                        this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                    }
            },
            hash: function(t) {
                var e, i, n;
                for (n = 4022871197, t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (n += t.charCodeAt(i)), e -= n = e >>> 0, n = (e *= n) >>> 0, n += 4294967296 * (e -= n);
                return 2.3283064365386963e-10 * (n >>> 0)
            },
            integer: function() {
                return 4294967296 * this.rnd.apply(this)
            },
            frac: function() {
                return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
            },
            real: function() {
                return this.integer() + this.frac()
            },
            integerInRange: function(t, e) {
                return Math.floor(this.realInRange(0, e - t + 1) + t)
            },
            between: function(t, e) {
                return this.integerInRange(t, e)
            },
            realInRange: function(t, e) {
                return this.frac() * (e - t) + t
            },
            normal: function() {
                return 1 - 2 * this.frac()
            },
            uuid: function() {
                var t = "",
                    e = "";
                for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                return e
            },
            pick: function(t) {
                return t[this.integerInRange(0, t.length - 1)]
            },
            sign: function() {
                return this.pick([-1, 1])
            },
            weightedPick: function(t) {
                return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
            },
            timestamp: function(t, e) {
                return this.realInRange(t || 9466848e5, e || 1577862e6)
            },
            angle: function() {
                return this.integerInRange(-180, 180)
            },
            state: function(t) {
                return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
            }
        }, i.RandomDataGenerator.prototype.constructor = i.RandomDataGenerator, i.QuadTree = function(t, e, i, n, s, r, o) {
            this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, n, s, r, o)
        }, i.QuadTree.prototype = {
            reset: function(t, e, i, n, s, r, o) {
                this.maxObjects = s || 10, this.maxLevels = r || 4, this.level = o || 0, this.bounds = {
                    x: Math.round(t),
                    y: Math.round(e),
                    width: i,
                    height: n,
                    subWidth: Math.floor(i / 2),
                    subHeight: Math.floor(n / 2),
                    right: Math.round(t) + Math.floor(i / 2),
                    bottom: Math.round(e) + Math.floor(n / 2)
                }, this.objects.length = 0, this.nodes.length = 0
            },
            populate: function(t) {
                t.forEach(this.populateHandler, this, !0)
            },
            populateHandler: function(t) {
                t.body && t.exists && this.insert(t.body)
            },
            split: function() {
                this.nodes[0] = new i.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new i.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new i.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new i.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
            },
            insert: function(t) {
                var e, i = 0;
                if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                    if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                        for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                } else this.nodes[e].insert(t)
            },
            getIndex: function(t) {
                var e = -1;
                return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
            },
            retrieve: function(t) {
                if (t instanceof i.Rectangle) var e = this.objects,
                    n = this.getIndex(t);
                else {
                    if (!t.body) return this._empty;
                    e = this.objects, n = this.getIndex(t.body)
                }
                return this.nodes[0] && (e = -1 !== n ? e.concat(this.nodes[n].retrieve(t)) : (e = (e = (e = e.concat(this.nodes[0].retrieve(t))).concat(this.nodes[1].retrieve(t))).concat(this.nodes[2].retrieve(t))).concat(this.nodes[3].retrieve(t))), e
            },
            clear: function() {
                this.objects.length = 0;
                for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                this.nodes.length = 0
            }
        }, i.QuadTree.prototype.constructor = i.QuadTree, i.Net = function(t) {
            this.game = t
        }, i.Net.prototype = {
            getHostName: function() {
                return window.location && window.location.hostname ? window.location.hostname : null
            },
            checkDomainName: function(t) {
                return -1 !== window.location.hostname.indexOf(t)
            },
            updateQueryString: function(t, e, i, n) {
                void 0 === i && (i = !1), void 0 !== n && "" !== n || (n = window.location.href);
                var s = "",
                    r = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                if (r.test(n)) s = void 0 !== e && null !== e ? n.replace(r, "$1" + t + "=" + e + "$2$3") : n.replace(r, "$1$3").replace(/(&|\?)$/, "");
                else if (void 0 !== e && null !== e) {
                    var o = -1 !== n.indexOf("?") ? "&" : "?",
                        a = n.split("#");
                    n = a[0] + o + t + "=" + e, a[1] && (n += "#" + a[1]), s = n
                } else s = n;
                if (!i) return s;
                window.location.href = s
            },
            getQueryString: function(t) {
                void 0 === t && (t = "");
                var e = {},
                    i = location.search.substring(1).split("&");
                for (var n in i) {
                    var s = i[n].split("=");
                    if (s.length > 1) {
                        if (t && t === this.decodeURI(s[0])) return this.decodeURI(s[1]);
                        e[this.decodeURI(s[0])] = this.decodeURI(s[1])
                    }
                }
                return e
            },
            decodeURI: function(t) {
                return decodeURIComponent(t.replace(/\+/g, " "))
            }
        }, i.Net.prototype.constructor = i.Net, i.TweenManager = function(t) {
            this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                Power0: i.Easing.Power0,
                Power1: i.Easing.Power1,
                Power2: i.Easing.Power2,
                Power3: i.Easing.Power3,
                Power4: i.Easing.Power4,
                Linear: i.Easing.Linear.None,
                Quad: i.Easing.Quadratic.Out,
                Cubic: i.Easing.Cubic.Out,
                Quart: i.Easing.Quartic.Out,
                Quint: i.Easing.Quintic.Out,
                Sine: i.Easing.Sinusoidal.Out,
                Expo: i.Easing.Exponential.Out,
                Circ: i.Easing.Circular.Out,
                Elastic: i.Easing.Elastic.Out,
                Back: i.Easing.Back.Out,
                Bounce: i.Easing.Bounce.Out,
                "Quad.easeIn": i.Easing.Quadratic.In,
                "Cubic.easeIn": i.Easing.Cubic.In,
                "Quart.easeIn": i.Easing.Quartic.In,
                "Quint.easeIn": i.Easing.Quintic.In,
                "Sine.easeIn": i.Easing.Sinusoidal.In,
                "Expo.easeIn": i.Easing.Exponential.In,
                "Circ.easeIn": i.Easing.Circular.In,
                "Elastic.easeIn": i.Easing.Elastic.In,
                "Back.easeIn": i.Easing.Back.In,
                "Bounce.easeIn": i.Easing.Bounce.In,
                "Quad.easeOut": i.Easing.Quadratic.Out,
                "Cubic.easeOut": i.Easing.Cubic.Out,
                "Quart.easeOut": i.Easing.Quartic.Out,
                "Quint.easeOut": i.Easing.Quintic.Out,
                "Sine.easeOut": i.Easing.Sinusoidal.Out,
                "Expo.easeOut": i.Easing.Exponential.Out,
                "Circ.easeOut": i.Easing.Circular.Out,
                "Elastic.easeOut": i.Easing.Elastic.Out,
                "Back.easeOut": i.Easing.Back.Out,
                "Bounce.easeOut": i.Easing.Bounce.Out,
                "Quad.easeInOut": i.Easing.Quadratic.InOut,
                "Cubic.easeInOut": i.Easing.Cubic.InOut,
                "Quart.easeInOut": i.Easing.Quartic.InOut,
                "Quint.easeInOut": i.Easing.Quintic.InOut,
                "Sine.easeInOut": i.Easing.Sinusoidal.InOut,
                "Expo.easeInOut": i.Easing.Exponential.InOut,
                "Circ.easeInOut": i.Easing.Circular.InOut,
                "Elastic.easeInOut": i.Easing.Elastic.InOut,
                "Back.easeInOut": i.Easing.Back.InOut,
                "Bounce.easeInOut": i.Easing.Bounce.InOut
            }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
        }, i.TweenManager.prototype = {
            getAll: function() {
                return this._tweens
            },
            removeAll: function() {
                for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                this._add = []
            },
            removeFrom: function(t, e) {
                if (void 0 === e && (e = !0), Array.isArray(t))
                    for (n = 0, s = t.length; n < s; n++) this.removeFrom(t[n]);
                else if (t.type === i.GROUP && e)
                    for (var n = 0, s = t.children.length; n < s; n++) this.removeFrom(t.children[n]);
                else {
                    for (n = 0, s = this._tweens.length; n < s; n++) t === this._tweens[n].target && this.remove(this._tweens[n]);
                    for (n = 0, s = this._add.length; n < s; n++) t === this._add[n].target && this.remove(this._add[n])
                }
            },
            add: function(t) {
                t._manager = this, this._add.push(t)
            },
            create: function(t) {
                return new i.Tween(t, this.game, this)
            },
            remove: function(t) {
                var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
            },
            update: function() {
                var t = this._add.length,
                    e = this._tweens.length;
                if (0 === e && 0 === t) return !1;
                for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
            },
            isTweening: function(t) {
                return this._tweens.some(function(e) {
                    return e.target === t
                })
            },
            _pauseAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
            },
            _resumeAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
            },
            pauseAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
            },
            resumeAll: function() {
                for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
            }
        }, i.TweenManager.prototype.constructor = i.TweenManager, i.Tween = function(t, e, n) {
            this.game = e, this.target = t, this.manager = n, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new i.Signal, this.onLoop = new i.Signal, this.onRepeat = new i.Signal, this.onChildComplete = new i.Signal, this.onComplete = new i.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = n.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
        }, i.Tween.prototype = {
            to: function(t, e, n, s, r, o, a) {
                return (void 0 === e || e <= 0) && (e = 1e3), void 0 !== n && null !== n || (n = i.Easing.Default), void 0 === s && (s = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof n && this.manager.easeMap[n] && (n = this.manager.easeMap[n]), this.isRunning ? this : (this.timeline.push(new i.TweenData(this).to(t, e, n, r, o, a)), s && this.start(), this)
            },
            from: function(t, e, n, s, r, o, a) {
                return void 0 === e && (e = 1e3), void 0 !== n && null !== n || (n = i.Easing.Default), void 0 === s && (s = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof n && this.manager.easeMap[n] && (n = this.manager.easeMap[n]), this.isRunning ? this : (this.timeline.push(new i.TweenData(this).from(t, e, n, r, o, a)), s && this.start(), this)
            },
            start: function(t) {
                if (void 0 === t && (t = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                for (var e = 0; e < this.timeline.length; e++)
                    for (var i in this.timeline[e].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                for (e = 0; e < this.timeline.length; e++) this.timeline[e].loadValues();
                return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
            },
            stop: function(t) {
                return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
            },
            updateTweenData: function(t, e, i) {
                if (0 === this.timeline.length) return this;
                if (void 0 === i && (i = 0), -1 === i)
                    for (var n = 0; n < this.timeline.length; n++) this.timeline[n][t] = e;
                else this.timeline[i][t] = e;
                return this
            },
            delay: function(t, e) {
                return this.updateTweenData("delay", t, e)
            },
            repeat: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatDelay", e, i)
            },
            repeatDelay: function(t, e) {
                return this.updateTweenData("repeatDelay", t, e)
            },
            yoyo: function(t, e, i) {
                return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
            },
            yoyoDelay: function(t, e) {
                return this.updateTweenData("yoyoDelay", t, e)
            },
            easing: function(t, e) {
                return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
            },
            interpolation: function(t, e, n) {
                return void 0 === e && (e = i.Math), this.updateTweenData("interpolationFunction", t, n), this.updateTweenData("interpolationContext", e, n)
            },
            repeatAll: function(t) {
                return void 0 === t && (t = 0), this.repeatCounter = t, this
            },
            chain: function() {
                for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                return this
            },
            loop: function(t) {
                return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
            },
            onUpdateCallback: function(t, e) {
                return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
            },
            pause: function() {
                this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
            },
            _pause: function() {
                this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
            },
            resume: function() {
                if (this.isPaused) {
                    this.isPaused = !1, this._codePaused = !1;
                    for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            update: function(t) {
                if (this.pendingDelete || !this.target) return !1;
                if (this.isPaused) return !0;
                var e = this.timeline[this.current].update(t);
                if (e === i.TweenData.PENDING) return !0;
                if (e === i.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                if (e === i.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                if (e === i.TweenData.COMPLETE) {
                    var n = !1;
                    return this.reverse ? (this.current--, this.current < 0 && (this.current = this.timeline.length - 1, n = !0)) : (this.current++, this.current === this.timeline.length && (this.current = 0, n = !0)), n ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                }
            },
            generateData: function(t, e) {
                if (null === this.game || null === this.target) return null;
                void 0 === t && (t = 60), void 0 === e && (e = []);
                for (var i = 0; i < this.timeline.length; i++)
                    for (var n in this.timeline[i].vEnd) this.properties[n] = this.target[n] || 0, Array.isArray(this.properties[n]) || (this.properties[n] *= 1);
                for (i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                for (i = 0; i < this.timeline.length; i++) e = e.concat(this.timeline[i].generateData(t));
                return e
            }
        }, Object.defineProperty(i.Tween.prototype, "totalDuration", {
            get: function() {
                for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                return t
            }
        }), i.Tween.prototype.constructor = i.Tween, i.TweenData = function(t) {
            this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = i.Easing.Default, this.interpolationFunction = i.Math.linearInterpolation, this.interpolationContext = i.Math, this.isRunning = !1, this.isFrom = !1
        }, i.TweenData.PENDING = 0, i.TweenData.RUNNING = 1, i.TweenData.LOOPED = 2, i.TweenData.COMPLETE = 3, i.TweenData.prototype = {
            to: function(t, e, i, n, s, r) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = n, this.repeatTotal = s, this.yoyo = r, this.isFrom = !1, this
            },
            from: function(t, e, i, n, s, r) {
                return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = n, this.repeatTotal = s, this.yoyo = r, this.isFrom = !0, this
            },
            start: function() {
                if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
            },
            loadValues: function() {
                for (var t in this.parent.properties) {
                    if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                        if (0 === this.vEnd[t].length) continue;
                        0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                    }
                    void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                }
                return this
            },
            update: function(t) {
                if (this.isRunning) {
                    if (t < this.startTime) return i.TweenData.RUNNING
                } else {
                    if (!(t >= this.startTime)) return i.TweenData.PENDING;
                    this.isRunning = !0
                }
                var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                for (var n in this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent), this.vEnd) {
                    var s = this.vStart[n],
                        r = this.vEnd[n];
                    Array.isArray(r) ? this.parent.target[n] = this.interpolationFunction.call(this.interpolationContext, r, this.value) : this.parent.target[n] = s + (r - s) * this.value
                }
                return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : i.TweenData.RUNNING
            },
            generateData: function(t) {
                this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                var e = [],
                    i = !1,
                    n = 1 / t * 1e3;
                do {
                    this.parent.reverse ? (this.dt -= n, this.dt = Math.max(this.dt, 0)) : (this.dt += n, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                    var s = {};
                    for (var r in this.vEnd) {
                        var o = this.vStart[r],
                            a = this.vEnd[r];
                        Array.isArray(a) ? s[r] = this.interpolationFunction(a, this.value) : s[r] = o + (a - o) * this.value
                    }
                    e.push(s), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                } while (!i);
                if (this.yoyo) {
                    var h = e.slice();
                    h.reverse(), e = e.concat(h)
                }
                return e
            },
            repeat: function() {
                if (this.yoyo) {
                    if (this.inReverse && 0 === this.repeatCounter) {
                        for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                        return this.inReverse = !1, i.TweenData.COMPLETE
                    }
                    this.inReverse = !this.inReverse
                } else if (0 === this.repeatCounter) return i.TweenData.COMPLETE;
                if (this.inReverse)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                else {
                    for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                    this.repeatCounter > 0 && this.repeatCounter--
                }
                return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, i.TweenData.LOOPED
            }
        }, i.TweenData.prototype.constructor = i.TweenData, i.Easing = {
            Linear: {
                None: function(t) {
                    return t
                }
            },
            Quadratic: {
                In: function(t) {
                    return t * t
                },
                Out: function(t) {
                    return t * (2 - t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                }
            },
            Cubic: {
                In: function(t) {
                    return t * t * t
                },
                Out: function(t) {
                    return --t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                }
            },
            Quartic: {
                In: function(t) {
                    return t * t * t * t
                },
                Out: function(t) {
                    return 1 - --t * t * t * t
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                }
            },
            Quintic: {
                In: function(t) {
                    return t * t * t * t * t
                },
                Out: function(t) {
                    return --t * t * t * t * t + 1
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                }
            },
            Sinusoidal: {
                In: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                },
                Out: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                }
            },
            Exponential: {
                In: function(t) {
                    return 0 === t ? 0 : Math.pow(1024, t - 1)
                },
                Out: function(t) {
                    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                },
                InOut: function(t) {
                    return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                }
            },
            Circular: {
                In: function(t) {
                    return 1 - Math.sqrt(1 - t * t)
                },
                Out: function(t) {
                    return Math.sqrt(1 - --t * t)
                },
                InOut: function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                }
            },
            Elastic: {
                In: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
                },
                Out: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
                },
                InOut: function(t) {
                    var e, i = .1;
                    return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
                }
            },
            Back: {
                In: function(t) {
                    var e = 1.70158;
                    return t * t * ((e + 1) * t - e)
                },
                Out: function(t) {
                    var e = 1.70158;
                    return --t * t * ((e + 1) * t + e) + 1
                },
                InOut: function(t) {
                    var e = 2.5949095;
                    return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                }
            },
            Bounce: {
                In: function(t) {
                    return 1 - i.Easing.Bounce.Out(1 - t)
                },
                Out: function(t) {
                    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                },
                InOut: function(t) {
                    return t < .5 ? .5 * i.Easing.Bounce.In(2 * t) : .5 * i.Easing.Bounce.Out(2 * t - 1) + .5
                }
            }
        }, i.Easing.Default = i.Easing.Linear.None, i.Easing.Power0 = i.Easing.Linear.None, i.Easing.Power1 = i.Easing.Quadratic.Out, i.Easing.Power2 = i.Easing.Cubic.Out, i.Easing.Power3 = i.Easing.Quartic.Out, i.Easing.Power4 = i.Easing.Quintic.Out, i.Time = function(t) {
            this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new i.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
        }, i.Time.prototype = {
            boot: function() {
                this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
            },
            add: function(t) {
                return this._timers.push(t), t
            },
            create: function(t) {
                void 0 === t && (t = !0);
                var e = new i.Timer(this.game, t);
                return this._timers.push(e), e
            },
            removeAll: function() {
                for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                this._timers = [], this.events.removeAll()
            },
            refresh: function() {
                var t = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - t
            },
            update: function(t) {
                var e = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
            },
            updateTimers: function() {
                for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
            },
            updateAdvancedTiming: function() {
                this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)
            },
            gamePaused: function() {
                this._pauseStarted = Date.now(), this.events.pause();
                for (var t = this._timers.length; t--;) this._timers[t]._pause()
            },
            gameResumed: function() {
                this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                for (var t = this._timers.length; t--;) this._timers[t]._resume()
            },
            totalElapsedSeconds: function() {
                return .001 * (this.time - this._started)
            },
            elapsedSince: function(t) {
                return this.time - t
            },
            elapsedSecondsSince: function(t) {
                return .001 * (this.time - t)
            },
            reset: function() {
                this._started = this.time, this.removeAll()
            }
        }, Object.defineProperty(i.Time.prototype, "desiredFps", {
            get: function() {
                return this._desiredFps
            },
            set: function(t) {
                this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
            }
        }), i.Time.prototype.constructor = i.Time, i.Timer = function(t, e) {
            void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new i.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
        }, i.Timer.MINUTE = 6e4, i.Timer.SECOND = 1e3, i.Timer.HALF = 500, i.Timer.QUARTER = 250, i.Timer.prototype = {
            create: function(t, e, n, s, r, o) {
                var a = t = Math.round(t);
                0 === this._now ? a += this.game.time.time : a += this._now;
                var h = new i.TimerEvent(this, t, a, n, e, s, r, o);
                return this.events.push(h), this.order(), this.expired = !1, h
            },
            add: function(t, e, i) {
                return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            repeat: function(t, e, i, n) {
                return this.create(t, !1, e, i, n, Array.prototype.slice.call(arguments, 4))
            },
            loop: function(t, e, i) {
                return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
            },
            start: function(t) {
                if (!this.running) {
                    this._started = this.game.time.time + (t || 0), this.running = !0;
                    for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                }
            },
            stop: function(t) {
                this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
            },
            remove: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0;
                return !1
            },
            order: function() {
                this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
            },
            sortHandler: function(t, e) {
                return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
            },
            clearPendingEvents: function() {
                for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length, this._i = 0
            },
            update: function(t) {
                if (this.paused) return !0;
                if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                    for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                }
                return !this.expired || !this.autoDestroy
            },
            pause: function() {
                this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
            },
            _pause: function() {
                !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
            },
            adjustEvents: function(t) {
                for (var e = 0; e < this.events.length; e++)
                    if (!this.events[e].pendingDelete) {
                        var i = this.events[e].tick - t;
                        i < 0 && (i = 0), this.events[e].tick = this._now + i
                    }
                var n = this.nextTick - t;
                this.nextTick = n < 0 ? this._now : this._now + n
            },
            resume: function() {
                if (this.paused) {
                    var t = this.game.time.time;
                    this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                }
            },
            _resume: function() {
                this._codePaused || this.resume()
            },
            removeAll: function() {
                this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
            },
            destroy: function() {
                this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
            }
        }, Object.defineProperty(i.Timer.prototype, "next", {
            get: function() {
                return this.nextTick
            }
        }), Object.defineProperty(i.Timer.prototype, "duration", {
            get: function() {
                return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
            }
        }), Object.defineProperty(i.Timer.prototype, "length", {
            get: function() {
                return this.events.length
            }
        }), Object.defineProperty(i.Timer.prototype, "ms", {
            get: function() {
                return this.running ? this._now - this._started - this._pauseTotal : 0
            }
        }), Object.defineProperty(i.Timer.prototype, "seconds", {
            get: function() {
                return this.running ? .001 * this.ms : 0
            }
        }), i.Timer.prototype.constructor = i.Timer, i.TimerEvent = function(t, e, i, n, s, r, o, a) {
            this.timer = t, this.delay = e, this.tick = i, this.repeatCount = n - 1, this.loop = s, this.callback = r, this.callbackContext = o, this.args = a, this.pendingDelete = !1
        }, i.TimerEvent.prototype.constructor = i.TimerEvent, i.AnimationManager = function(t) {
            this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
        }, i.AnimationManager.prototype = {
            loadFrameData: function(t, e) {
                if (void 0 === t) return !1;
                if (this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(t);
                return this._frameData = t, void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            },
            copyFrameData: function(t, e) {
                if (this._frameData = t.clone(), this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                return void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
            },
            add: function(t, e, n, s, r) {
                return e = e || [], n = n || 60, void 0 === s && (s = !1), void 0 === r && (r = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, r, this._outputFrames), this._anims[t] = new i.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, n, s), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
            },
            validateFrames: function(t, e) {
                void 0 === e && (e = !0);
                for (var i = 0; i < t.length; i++)
                    if (!0 === e) {
                        if (t[i] > this._frameData.total) return !1
                    } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                return !0
            },
            play: function(t, e, i, n) {
                if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, n)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, n))
            },
            stop: function(t, e) {
                void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
            },
            update: function() {
                return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0))
            },
            next: function(t) {
                this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            previous: function(t) {
                this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
            },
            getAnimation: function(t) {
                return "string" == typeof t && this._anims[t] ? this._anims[t] : null
            },
            refreshFrame: function() {},
            destroy: function() {
                var t = null;
                for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
            }
        }, i.AnimationManager.prototype.constructor = i.AnimationManager, Object.defineProperty(i.AnimationManager.prototype, "frameData", {
            get: function() {
                return this._frameData
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "frameTotal", {
            get: function() {
                return this._frameData.total
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "paused", {
            get: function() {
                return this.currentAnim.isPaused
            },
            set: function(t) {
                this.currentAnim.paused = t
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "name", {
            get: function() {
                if (this.currentAnim) return this.currentAnim.name
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "frame", {
            get: function() {
                if (this.currentFrame) return this.currentFrame.index
            },
            set: function(t) {
                "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && this.sprite.setFrame(this.currentFrame))
            }
        }), Object.defineProperty(i.AnimationManager.prototype, "frameName", {
            get: function() {
                if (this.currentFrame) return this.currentFrame.name
            },
            set: function(t) {
                "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) && (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)))
            }
        }), i.Animation = function(t, e, n, s, r, o, a) {
            void 0 === a && (a = !1), this.game = t, this._parent = e, this._frameData = s, this.name = n, this._frames = [], this._frames = this._frames.concat(r), this.delay = 1e3 / o, this.loop = a, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new i.Signal, this.onUpdate = null, this.onComplete = new i.Signal, this.onLoop = new i.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
        }, i.Animation.prototype = {
            play: function(t, e, i) {
                return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
            },
            restart: function() {
                this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
            },
            reverse: function() {
                return this.reversed = !this.reversed, this
            },
            reverseOnce: function() {
                return this.onComplete.addOnce(this.reverse, this), this.reverse()
            },
            setFrame: function(t, e) {
                var i;
                if (void 0 === e && (e = !1), "string" == typeof t)
                    for (var n = 0; n < this._frames.length; n++) this._frameData.getFrame(this._frames[n]).name === t && (i = n);
                else if ("number" == typeof t)
                    if (e) i = t;
                    else
                        for (n = 0; n < this._frames.length; n++) this._frames[n] === t && (i = n);
                i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.time, this.update())
            },
            stop: function(t, e) {
                void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
            },
            onPause: function() {
                this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
            },
            onResume: function() {
                this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
            },
            update: function() {
                return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0)))
            },
            updateCurrentFrame: function(t, e) {
                if (void 0 === e && (e = !1), !this._frameData) return !1;
                var i = this.currentFrame.index;
                return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
            },
            next: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex + t;
                e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            previous: function(t) {
                void 0 === t && (t = 1);
                var e = this._frameIndex - t;
                e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
            },
            updateFrameData: function(t) {
                this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
            },
            destroy: function() {
                this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
            },
            complete: function() {
                this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
            }
        }, i.Animation.prototype.constructor = i.Animation, Object.defineProperty(i.Animation.prototype, "paused", {
            get: function() {
                return this.isPaused
            },
            set: function(t) {
                this.isPaused = t, t ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
            }
        }), Object.defineProperty(i.Animation.prototype, "reversed", {
            get: function() {
                return this.isReversed
            },
            set: function(t) {
                this.isReversed = t
            }
        }), Object.defineProperty(i.Animation.prototype, "frameTotal", {
            get: function() {
                return this._frames.length
            }
        }), Object.defineProperty(i.Animation.prototype, "frame", {
            get: function() {
                return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
            },
            set: function(t) {
                this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
            }
        }), Object.defineProperty(i.Animation.prototype, "speed", {
            get: function() {
                return 1e3 / this.delay
            },
            set: function(t) {
                t > 0 && (this.delay = 1e3 / t)
            }
        }), Object.defineProperty(i.Animation.prototype, "enableUpdate", {
            get: function() {
                return null !== this.onUpdate
            },
            set: function(t) {
                t && null === this.onUpdate ? this.onUpdate = new i.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
            }
        }), i.Animation.generateFrameNames = function(t, e, n, s, r) {
            void 0 === s && (s = "");
            var o = [],
                a = "";
            if (e < n)
                for (var h = e; h <= n; h++) a = t + (a = "number" == typeof r ? i.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + s, o.push(a);
            else
                for (h = e; h >= n; h--) a = t + (a = "number" == typeof r ? i.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + s, o.push(a);
            return o
        }, i.Frame = function(t, e, n, s, r, o) {
            this.index = t, this.x = e, this.y = n, this.width = s, this.height = r, this.name = o, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(r / 2), this.distance = i.Math.distance(0, 0, s, r), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = s, this.sourceSizeH = r, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
        }, i.Frame.prototype = {
            resize: function(t, e) {
                this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = i.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
            },
            setTrim: function(t, e, i, n, s, r, o) {
                this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = n, this.spriteSourceSizeY = s, this.spriteSourceSizeW = r, this.spriteSourceSizeH = o)
            },
            clone: function() {
                var t = new i.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                for (var e in this) this.hasOwnProperty(e) && (t[e] = this[e]);
                return t
            },
            getRect: function(t) {
                return void 0 === t ? t = new i.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
            }
        }, i.Frame.prototype.constructor = i.Frame, i.FrameData = function() {
            this._frames = [], this._frameNames = []
        }, i.FrameData.prototype = {
            addFrame: function(t) {
                return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
            },
            getFrame: function(t) {
                return t >= this._frames.length && (t = 0), this._frames[t]
            },
            getFrameByName: function(t) {
                return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
            },
            checkFrameName: function(t) {
                return null != this._frameNames[t]
            },
            clone: function() {
                for (var t = new i.FrameData, e = 0; e < this._frames.length; e++) t._frames.push(this._frames[e].clone());
                for (var n in this._frameNames) this._frameNames.hasOwnProperty(n) && t._frameNames.push(this._frameNames[n]);
                return t
            },
            getFrameRange: function(t, e, i) {
                void 0 === i && (i = []);
                for (var n = t; n <= e; n++) i.push(this._frames[n]);
                return i
            },
            getFrames: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (var n = 0; n < this._frames.length; n++) i.push(this._frames[n]);
                else
                    for (n = 0; n < t.length; n++) e ? i.push(this.getFrame(t[n])) : i.push(this.getFrameByName(t[n]));
                return i
            },
            getFrameIndexes: function(t, e, i) {
                if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (var n = 0; n < this._frames.length; n++) i.push(this._frames[n].index);
                else
                    for (n = 0; n < t.length; n++) e && this._frames[t[n]] ? i.push(this._frames[t[n]].index) : this.getFrameByName(t[n]) && i.push(this.getFrameByName(t[n]).index);
                return i
            },
            destroy: function() {
                this._frames = null, this._frameNames = null
            }
        }, i.FrameData.prototype.constructor = i.FrameData, Object.defineProperty(i.FrameData.prototype, "total", {
            get: function() {
                return this._frames.length
            }
        }), i.AnimationParser = {
            spriteSheet: function(t, e, n, s, r, o, a) {
                var h = e;
                if ("string" == typeof e && (h = t.cache.getImage(e)), null === h) return null;
                var l = h.width,
                    c = h.height;
                n <= 0 && (n = Math.floor(-l / Math.min(-1, n))), s <= 0 && (s = Math.floor(-c / Math.min(-1, s)));
                var u = Math.floor((l - o) / (n + a)) * Math.floor((c - o) / (s + a));
                if (-1 !== r && (u = r), 0 === l || 0 === c || l < n || c < s || 0 === u) return null;
                for (var d = new i.FrameData, p = o, f = o, g = 0; g < u; g++) d.addFrame(new i.Frame(g, p, f, n, s, "")), (p += n + a) + n > l && (p = o, f += s + a);
                return d
            },
            JSONData: function(t, e) {
                if (e.frames) {
                    for (var n, s = new i.FrameData, r = e.frames, o = 0; o < r.length; o++) n = s.addFrame(new i.Frame(o, r[o].frame.x, r[o].frame.y, r[o].frame.w, r[o].frame.h, r[o].filename)), r[o].trimmed && n.setTrim(r[o].trimmed, r[o].sourceSize.w, r[o].sourceSize.h, r[o].spriteSourceSize.x, r[o].spriteSourceSize.y, r[o].spriteSourceSize.w, r[o].spriteSourceSize.h);
                    return s
                }
            },
            JSONDataPyxel: function(t, e) {
                if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                        e[t]
                    }), 1 === e.layers.length) {
                    for (var n = new i.FrameData, s = e.tileheight, r = e.tilewidth, o = e.layers[0].tiles, a = 0; a < o.length; a++) n.addFrame(new i.Frame(a, o[a].x, o[a].y, r, s, "frame_" + a)).setTrim(!1);
                    return n
                }
            },
            JSONDataHash: function(t, e) {
                if (e.frames) {
                    var n, s = new i.FrameData,
                        r = e.frames,
                        o = 0;
                    for (var a in r) n = s.addFrame(new i.Frame(o, r[a].frame.x, r[a].frame.y, r[a].frame.w, r[a].frame.h, a)), r[a].trimmed && n.setTrim(r[a].trimmed, r[a].sourceSize.w, r[a].sourceSize.h, r[a].spriteSourceSize.x, r[a].spriteSourceSize.y, r[a].spriteSourceSize.w, r[a].spriteSourceSize.h), o++;
                    return s
                }
            },
            XMLData: function(t, e) {
                if (e.getElementsByTagName("TextureAtlas")) {
                    for (var n, s, r, o, a, h, l, c, u, d, p, f = new i.FrameData, g = e.getElementsByTagName("SubTexture"), m = 0; m < g.length; m++) s = (r = g[m].attributes).name.value, o = parseInt(r.x.value, 10), a = parseInt(r.y.value, 10), h = parseInt(r.width.value, 10), l = parseInt(r.height.value, 10), c = null, u = null, r.frameX && (c = Math.abs(parseInt(r.frameX.value, 10)), u = Math.abs(parseInt(r.frameY.value, 10)), d = parseInt(r.frameWidth.value, 10), p = parseInt(r.frameHeight.value, 10)), n = f.addFrame(new i.Frame(m, o, a, h, l, s)), null === c && null === u || n.setTrim(!0, h, l, c, u, d, p);
                    return f
                }
            }
        }, i.Cache = function(t) {
            this.game = t, this.autoResolveURL = !1, this._cache = {
                canvas: {},
                image: {},
                texture: {},
                sound: {},
                video: {},
                text: {},
                json: {},
                xml: {},
                physics: {},
                tilemap: {},
                binary: {},
                bitmapData: {},
                bitmapFont: {},
                shader: {},
                renderTexture: {}
            }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new i.Signal, this._cacheMap = [], this._cacheMap[i.Cache.CANVAS] = this._cache.canvas, this._cacheMap[i.Cache.IMAGE] = this._cache.image, this._cacheMap[i.Cache.TEXTURE] = this._cache.texture, this._cacheMap[i.Cache.SOUND] = this._cache.sound, this._cacheMap[i.Cache.TEXT] = this._cache.text, this._cacheMap[i.Cache.PHYSICS] = this._cache.physics, this._cacheMap[i.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[i.Cache.BINARY] = this._cache.binary, this._cacheMap[i.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[i.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[i.Cache.JSON] = this._cache.json, this._cacheMap[i.Cache.XML] = this._cache.xml, this._cacheMap[i.Cache.VIDEO] = this._cache.video, this._cacheMap[i.Cache.SHADER] = this._cache.shader, this._cacheMap[i.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage()
        }, i.Cache.CANVAS = 1, i.Cache.IMAGE = 2, i.Cache.TEXTURE = 3, i.Cache.SOUND = 4, i.Cache.TEXT = 5, i.Cache.PHYSICS = 6, i.Cache.TILEMAP = 7, i.Cache.BINARY = 8, i.Cache.BITMAPDATA = 9, i.Cache.BITMAPFONT = 10, i.Cache.JSON = 11, i.Cache.XML = 12, i.Cache.VIDEO = 13, i.Cache.SHADER = 14, i.Cache.RENDER_TEXTURE = 15, i.Cache.DEFAULT = null, i.Cache.MISSING = null, i.Cache.prototype = {
            addCanvas: function(t, e, i) {
                void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                    canvas: e,
                    context: i
                }
            },
            addImage: function(t, e, n) {
                this.checkImageKey(t) && this.removeImage(t);
                var s = {
                    key: t,
                    url: e,
                    data: n,
                    base: new PIXI.BaseTexture(n),
                    frame: new i.Frame(0, 0, 0, n.width, n.height, t),
                    frameData: new i.FrameData
                };
                return s.frameData.addFrame(new i.Frame(0, 0, 0, n.width, n.height, e)), this._cache.image[t] = s, this._resolveURL(e, s), "__default" === t ? i.Cache.DEFAULT = new PIXI.Texture(s.base) : "__missing" === t && (i.Cache.MISSING = new PIXI.Texture(s.base)), s
            },
            addDefaultImage: function() {
                var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
                var e = this.addImage("__default", null, t);
                e.base.skipRender = !0, i.Cache.DEFAULT = new PIXI.Texture(e.base)
            },
            addMissingImage: function() {
                var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
                var e = this.addImage("__missing", null, t);
                i.Cache.MISSING = new PIXI.Texture(e.base)
            },
            addSound: function(t, e, i, n, s) {
                void 0 === n && (n = !0, s = !1), void 0 === s && (n = !1, s = !0);
                var r = !1;
                s && (r = !0), this._cache.sound[t] = {
                    url: e,
                    data: i,
                    isDecoding: !1,
                    decoded: r,
                    webAudio: n,
                    audioTag: s,
                    locked: this.game.sound.touchLocked
                }, this._resolveURL(e, this._cache.sound[t])
            },
            addText: function(t, e, i) {
                this._cache.text[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.text[t])
            },
            addPhysicsData: function(t, e, i, n) {
                this._cache.physics[t] = {
                    url: e,
                    data: i,
                    format: n
                }, this._resolveURL(e, this._cache.physics[t])
            },
            addTilemap: function(t, e, i, n) {
                this._cache.tilemap[t] = {
                    url: e,
                    data: i,
                    format: n
                }, this._resolveURL(e, this._cache.tilemap[t])
            },
            addBinary: function(t, e) {
                this._cache.binary[t] = e
            },
            addBitmapData: function(t, e, n) {
                return e.key = t, void 0 === n && (n = new i.FrameData).addFrame(e.textureFrame), this._cache.bitmapData[t] = {
                    data: e,
                    frameData: n
                }, e
            },
            addBitmapFont: function(t, e, n, s, r, o, a) {
                var h = {
                    url: e,
                    data: n,
                    font: null,
                    base: new PIXI.BaseTexture(n)
                };
                void 0 === o && (o = 0), void 0 === a && (a = 0), h.font = "json" === r ? i.LoaderParser.jsonBitmapFont(s, h.base, o, a) : i.LoaderParser.xmlBitmapFont(s, h.base, o, a), this._cache.bitmapFont[t] = h, this._resolveURL(e, h)
            },
            addJSON: function(t, e, i) {
                this._cache.json[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.json[t])
            },
            addXML: function(t, e, i) {
                this._cache.xml[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.xml[t])
            },
            addVideo: function(t, e, i, n) {
                this._cache.video[t] = {
                    url: e,
                    data: i,
                    isBlob: n,
                    locked: !0
                }, this._resolveURL(e, this._cache.video[t])
            },
            addShader: function(t, e, i) {
                this._cache.shader[t] = {
                    url: e,
                    data: i
                }, this._resolveURL(e, this._cache.shader[t])
            },
            addRenderTexture: function(t, e) {
                this._cache.renderTexture[t] = {
                    texture: e,
                    frame: new i.Frame(0, 0, 0, e.width, e.height, "", "")
                }
            },
            addSpriteSheet: function(t, e, n, s, r, o, a, h) {
                void 0 === o && (o = -1), void 0 === a && (a = 0), void 0 === h && (h = 0);
                var l = {
                    key: t,
                    url: e,
                    data: n,
                    frameWidth: s,
                    frameHeight: r,
                    margin: a,
                    spacing: h,
                    base: new PIXI.BaseTexture(n),
                    frameData: i.AnimationParser.spriteSheet(this.game, n, s, r, o, a, h)
                };
                this._cache.image[t] = l, this._resolveURL(e, l)
            },
            addTextureAtlas: function(t, e, n, s, r) {
                var o = {
                    key: t,
                    url: e,
                    data: n,
                    base: new PIXI.BaseTexture(n)
                };
                r === i.Loader.TEXTURE_ATLAS_XML_STARLING ? o.frameData = i.AnimationParser.XMLData(this.game, s, t) : r === i.Loader.TEXTURE_ATLAS_JSON_PYXEL ? o.frameData = i.AnimationParser.JSONDataPyxel(this.game, s, t) : Array.isArray(s.frames) ? o.frameData = i.AnimationParser.JSONData(this.game, s, t) : o.frameData = i.AnimationParser.JSONDataHash(this.game, s, t), this._cache.image[t] = o, this._resolveURL(e, o)
            },
            reloadSound: function(t) {
                var e = this,
                    i = this.getSound(t);
                i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                    return e.reloadSoundComplete(t)
                }, !1), i.data.load())
            },
            reloadSoundComplete: function(t) {
                var e = this.getSound(t);
                e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
            },
            updateSound: function(t, e, i) {
                var n = this.getSound(t);
                n && (n[e] = i)
            },
            decodedSound: function(t, e) {
                var i = this.getSound(t);
                i.data = e, i.decoded = !0, i.isDecoding = !1
            },
            isSoundDecoded: function(t) {
                var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded");
                if (e) return e.decoded
            },
            isSoundReady: function(t) {
                var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded");
                if (e) return e.decoded && !this.game.sound.touchLocked
            },
            checkKey: function(t, e) {
                return !!this._cacheMap[t][e]
            },
            checkURL: function(t) {
                return !!this._urlMap[this._resolveURL(t)]
            },
            checkCanvasKey: function(t) {
                return this.checkKey(i.Cache.CANVAS, t)
            },
            checkImageKey: function(t) {
                return this.checkKey(i.Cache.IMAGE, t)
            },
            checkTextureKey: function(t) {
                return this.checkKey(i.Cache.TEXTURE, t)
            },
            checkSoundKey: function(t) {
                return this.checkKey(i.Cache.SOUND, t)
            },
            checkTextKey: function(t) {
                return this.checkKey(i.Cache.TEXT, t)
            },
            checkPhysicsKey: function(t) {
                return this.checkKey(i.Cache.PHYSICS, t)
            },
            checkTilemapKey: function(t) {
                return this.checkKey(i.Cache.TILEMAP, t)
            },
            checkBinaryKey: function(t) {
                return this.checkKey(i.Cache.BINARY, t)
            },
            checkBitmapDataKey: function(t) {
                return this.checkKey(i.Cache.BITMAPDATA, t)
            },
            checkBitmapFontKey: function(t) {
                return this.checkKey(i.Cache.BITMAPFONT, t)
            },
            checkJSONKey: function(t) {
                return this.checkKey(i.Cache.JSON, t)
            },
            checkXMLKey: function(t) {
                return this.checkKey(i.Cache.XML, t)
            },
            checkVideoKey: function(t) {
                return this.checkKey(i.Cache.VIDEO, t)
            },
            checkShaderKey: function(t) {
                return this.checkKey(i.Cache.SHADER, t)
            },
            checkRenderTextureKey: function(t) {
                return this.checkKey(i.Cache.RENDER_TEXTURE, t)
            },
            getItem: function(t, e, i, n) {
                return this.checkKey(e, t) ? void 0 === n ? this._cacheMap[e][t] : this._cacheMap[e][t][n] : null
            },
            getCanvas: function(t) {
                return this.getItem(t, i.Cache.CANVAS, "getCanvas", "canvas")
            },
            getImage: function(t, e) {
                void 0 !== t && null !== t || (t = "__default"), void 0 === e && (e = !1);
                var n = this.getItem(t, i.Cache.IMAGE, "getImage");
                return null === n && (n = this.getItem("__missing", i.Cache.IMAGE, "getImage")), e ? n : n.data
            },
            getTextureFrame: function(t) {
                return this.getItem(t, i.Cache.TEXTURE, "getTextureFrame", "frame")
            },
            getSound: function(t) {
                return this.getItem(t, i.Cache.SOUND, "getSound")
            },
            getSoundData: function(t) {
                return this.getItem(t, i.Cache.SOUND, "getSoundData", "data")
            },
            getText: function(t) {
                return this.getItem(t, i.Cache.TEXT, "getText", "data")
            },
            getPhysicsData: function(t, e, n) {
                var s = this.getItem(t, i.Cache.PHYSICS, "getPhysicsData", "data");
                if (null === s || void 0 === e || null === e) return s;
                if (s[e]) {
                    var r = s[e];
                    if (!r || !n) return r;
                    for (var o in r)
                        if ((o = r[o]).fixtureKey === n) return o
                }
                return null
            },
            getTilemapData: function(t) {
                return this.getItem(t, i.Cache.TILEMAP, "getTilemapData")
            },
            getBinary: function(t) {
                return this.getItem(t, i.Cache.BINARY, "getBinary")
            },
            getBitmapData: function(t) {
                return this.getItem(t, i.Cache.BITMAPDATA, "getBitmapData", "data")
            },
            getBitmapFont: function(t) {
                return this.getItem(t, i.Cache.BITMAPFONT, "getBitmapFont")
            },
            getJSON: function(t, e) {
                var n = this.getItem(t, i.Cache.JSON, "getJSON", "data");
                return n ? e ? i.Utils.extend(!0, Array.isArray(n) ? [] : {}, n) : n : null
            },
            getXML: function(t) {
                return this.getItem(t, i.Cache.XML, "getXML", "data")
            },
            getVideo: function(t) {
                return this.getItem(t, i.Cache.VIDEO, "getVideo")
            },
            getShader: function(t) {
                return this.getItem(t, i.Cache.SHADER, "getShader", "data")
            },
            getRenderTexture: function(t) {
                return this.getItem(t, i.Cache.RENDER_TEXTURE, "getRenderTexture")
            },
            getBaseTexture: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
            },
            getFrame: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
            },
            getFrameCount: function(t, e) {
                var i = this.getFrameData(t, e);
                return i ? i.total : 0
            },
            getFrameData: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
            },
            hasFrameData: function(t, e) {
                return void 0 === e && (e = i.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
            },
            updateFrameData: function(t, e, n) {
                void 0 === n && (n = i.Cache.IMAGE), this._cacheMap[n][t] && (this._cacheMap[n][t].frameData = e)
            },
            getFrameByIndex: function(t, e, i) {
                var n = this.getFrameData(t, i);
                return n ? n.getFrame(e) : null
            },
            getFrameByName: function(t, e, i) {
                var n = this.getFrameData(t, i);
                return n ? n.getFrameByName(e) : null
            },
            getURL: function(t) {
                return (t = this._resolveURL(t)) ? this._urlMap[t] : null
            },
            getKeys: function(t) {
                void 0 === t && (t = i.Cache.IMAGE);
                var e = [];
                if (this._cacheMap[t])
                    for (var n in this._cacheMap[t]) "__default" !== n && "__missing" !== n && e.push(n);
                return e
            },
            removeCanvas: function(t) {
                delete this._cache.canvas[t]
            },
            removeImage: function(t, e) {
                void 0 === e && (e = !0);
                var i = this.getImage(t, !0);
                e && i.base && i.base.destroy(), delete this._cache.image[t]
            },
            removeSound: function(t) {
                delete this._cache.sound[t]
            },
            removeText: function(t) {
                delete this._cache.text[t]
            },
            removePhysics: function(t) {
                delete this._cache.physics[t]
            },
            removeTilemap: function(t) {
                delete this._cache.tilemap[t]
            },
            removeBinary: function(t) {
                delete this._cache.binary[t]
            },
            removeBitmapData: function(t) {
                delete this._cache.bitmapData[t]
            },
            removeBitmapFont: function(t) {
                delete this._cache.bitmapFont[t]
            },
            removeJSON: function(t) {
                delete this._cache.json[t]
            },
            removeXML: function(t) {
                delete this._cache.xml[t]
            },
            removeVideo: function(t) {
                delete this._cache.video[t]
            },
            removeShader: function(t) {
                delete this._cache.shader[t]
            },
            removeRenderTexture: function(t) {
                delete this._cache.renderTexture[t]
            },
            removeSpriteSheet: function(t) {
                delete this._cache.spriteSheet[t]
            },
            removeTextureAtlas: function(t) {
                delete this._cache.atlas[t]
            },
            clearGLTextures: function() {
                for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
            },
            _resolveURL: function(t, e) {
                return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
            },
            destroy: function() {
                for (var t = 0; t < this._cacheMap.length; t++) {
                    var e = this._cacheMap[t];
                    for (var i in e) "__default" !== i && "__missing" !== i && (e[i].destroy && e[i].destroy(), delete e[i])
                }
                this._urlMap = null, this._urlResolver = null, this._urlTemp = null
            }
        }, i.Cache.prototype.constructor = i.Cache, i.Loader = function(t) {
            this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                requestedWith: !1,
                json: "application/json",
                xml: "application/xml"
            }, this.onLoadStart = new i.Signal, this.onLoadComplete = new i.Signal, this.onPackComplete = new i.Signal, this.onFileStart = new i.Signal, this.onFileComplete = new i.Signal, this.onFileError = new i.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
        }, i.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, i.Loader.TEXTURE_ATLAS_JSON_HASH = 1, i.Loader.TEXTURE_ATLAS_XML_STARLING = 2, i.Loader.PHYSICS_LIME_CORONA_JSON = 3, i.Loader.PHYSICS_PHASER_JSON = 4, i.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, i.Loader.prototype = {
            setPreloadSprite: function(t, e) {
                e = e || 0, this.preloadSprite = {
                    sprite: t,
                    direction: e,
                    width: t.width,
                    height: t.height,
                    rect: null
                }, this.preloadSprite.rect = 0 === e ? new i.Rectangle(0, 0, 1, t.height) : new i.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
            },
            resize: function() {
                this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
            },
            checkKeyExists: function(t, e) {
                return this.getAssetIndex(t, e) > -1
            },
            getAssetIndex: function(t, e) {
                for (var i = -1, n = 0; n < this._fileList.length; n++) {
                    var s = this._fileList[n];
                    if (s.type === t && s.key === e && (i = n, !s.loaded && !s.loading)) break
                }
                return i
            },
            getAsset: function(t, e) {
                var i = this.getAssetIndex(t, e);
                return i > -1 && {
                    index: i,
                    file: this._fileList[i]
                }
            },
            reset: function(t, e) {
                void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
            },
            addToFileList: function(t, e, i, n, s, r) {
                if (void 0 === s && (s = !1), void 0 === e || "" === e) return this;
                if (void 0 === i || null === i) {
                    if (!r) return this;
                    i = e + r
                }
                var o = {
                    type: t,
                    key: e,
                    path: this.path,
                    url: i,
                    syncPoint: this._withSyncPointDepth > 0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1
                };
                if (n)
                    for (var a in n) o[a] = n[a];
                var h = this.getAssetIndex(t, e);
                if (s && h > -1) {
                    var l = this._fileList[h];
                    l.loading || l.loaded ? (this._fileList.push(o), this._totalFileCount++) : this._fileList[h] = o
                } else -1 === h && (this._fileList.push(o), this._totalFileCount++);
                return this
            },
            replaceInFileList: function(t, e, i, n) {
                return this.addToFileList(t, e, i, n, !0)
            },
            pack: function(t, e, i, n) {
                if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null), !e && !i) return this;
                var s = {
                    type: "packfile",
                    key: t,
                    url: e,
                    path: this.path,
                    syncPoint: !0,
                    data: null,
                    loading: !1,
                    loaded: !1,
                    error: !1,
                    callbackContext: n
                };
                i && ("string" == typeof i && (i = JSON.parse(i)), s.data = i || {}, s.loaded = !0);
                for (var r = 0; r < this._fileList.length + 1; r++) {
                    var o = this._fileList[r];
                    if (!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                        this._fileList.splice(r, 0, s), this._totalPackCount++;
                        break
                    }
                }
                return this
            },
            image: function(t, e, i) {
                return this.addToFileList("image", t, e, void 0, i, ".png")
            },
            images: function(t, e) {
                if (Array.isArray(e))
                    for (var i = 0; i < t.length; i++) this.image(t[i], e[i]);
                else
                    for (i = 0; i < t.length; i++) this.image(t[i]);
                return this
            },
            text: function(t, e, i) {
                return this.addToFileList("text", t, e, void 0, i, ".txt")
            },
            json: function(t, e, i) {
                return this.addToFileList("json", t, e, void 0, i, ".json")
            },
            shader: function(t, e, i) {
                return this.addToFileList("shader", t, e, void 0, i, ".frag")
            },
            xml: function(t, e, i) {
                return this.addToFileList("xml", t, e, void 0, i, ".xml")
            },
            script: function(t, e, i, n) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === n && (n = this), this.addToFileList("script", t, e, {
                    syncPoint: !0,
                    callback: i,
                    callbackContext: n
                }, !1, ".js")
            },
            binary: function(t, e, i, n) {
                return void 0 === i && (i = !1), !1 !== i && void 0 === n && (n = i), this.addToFileList("binary", t, e, {
                    callback: i,
                    callbackContext: n
                }, !1, ".bin")
            },
            spritesheet: function(t, e, i, n, s, r, o) {
                return void 0 === s && (s = -1), void 0 === r && (r = 0), void 0 === o && (o = 0), this.addToFileList("spritesheet", t, e, {
                    frameWidth: i,
                    frameHeight: n,
                    frameMax: s,
                    margin: r,
                    spacing: o
                }, !1, ".png")
            },
            audio: function(t, e, i) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                    buffer: null,
                    autoDecode: i
                }))
            },
            audioSprite: function(t, e, i, n, s) {
                return this.game.sound.noAudio ? this : (void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = !0), this.audio(t, e, s), i ? this.json(t + "-audioatlas", i) : n && ("string" == typeof n && (n = JSON.parse(n)), this.cache.addJSON(t + "-audioatlas", "", n)), this)
            },
            audiosprite: function(t, e, i, n, s) {
                return this.audioSprite(t, e, i, n, s)
            },
            video: function(t, e, i, n) {
                return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === n && (n = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                    buffer: null,
                    asBlob: n,
                    loadEvent: i
                })
            },
            tilemap: function(t, e, n, s) {
                if (void 0 === e && (e = null), void 0 === n && (n = null), void 0 === s && (s = i.Tilemap.CSV), e || n || (e = s === i.Tilemap.CSV ? t + ".csv" : t + ".json"), n) {
                    switch (s) {
                        case i.Tilemap.CSV:
                            break;
                        case i.Tilemap.TILED_JSON:
                            "string" == typeof n && (n = JSON.parse(n))
                    }
                    this.cache.addTilemap(t, null, n, s)
                } else this.addToFileList("tilemap", t, e, {
                    format: s
                });
                return this
            },
            physics: function(t, e, n, s) {
                return void 0 === e && (e = null), void 0 === n && (n = null), void 0 === s && (s = i.Physics.LIME_CORONA_JSON), e || n || (e = t + ".json"), n ? ("string" == typeof n && (n = JSON.parse(n)), this.cache.addPhysicsData(t, null, n, s)) : this.addToFileList("physics", t, e, {
                    format: s
                }), this
            },
            bitmapFont: function(t, e, i, n, s, r) {
                if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === n && (n = null), null === i && null === n && (i = t + ".xml"), void 0 === s && (s = 0), void 0 === r && (r = 0), i) this.addToFileList("bitmapfont", t, e, {
                    atlasURL: i,
                    xSpacing: s,
                    ySpacing: r
                });
                else if ("string" == typeof n) {
                    var o, a;
                    try {
                        o = JSON.parse(n)
                    } catch (t) {
                        a = this.parseXml(n)
                    }
                    if (!a && !o) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", t, e, {
                        atlasURL: null,
                        atlasData: o || a,
                        atlasType: o ? "json" : "xml",
                        xSpacing: s,
                        ySpacing: r
                    })
                }
                return this
            },
            atlasJSONArray: function(t, e, n, s) {
                return this.atlas(t, e, n, s, i.Loader.TEXTURE_ATLAS_JSON_ARRAY)
            },
            atlasJSONHash: function(t, e, n, s) {
                return this.atlas(t, e, n, s, i.Loader.TEXTURE_ATLAS_JSON_HASH)
            },
            atlasXML: function(t, e, n, s) {
                return void 0 === n && (n = null), void 0 === s && (s = null), n || s || (n = t + ".xml"), this.atlas(t, e, n, s, i.Loader.TEXTURE_ATLAS_XML_STARLING)
            },
            atlas: function(t, e, n, s, r) {
                if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === n && (n = null), void 0 === s && (s = null), void 0 === r && (r = i.Loader.TEXTURE_ATLAS_JSON_ARRAY), n || s || (n = r === i.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), n) this.addToFileList("textureatlas", t, e, {
                    atlasURL: n,
                    format: r
                });
                else {
                    switch (r) {
                        case i.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            "string" == typeof s && (s = JSON.parse(s));
                            break;
                        case i.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if ("string" == typeof s) {
                                var o = this.parseXml(s);
                                if (!o) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                s = o
                            }
                    }
                    this.addToFileList("textureatlas", t, e, {
                        atlasURL: null,
                        atlasData: s,
                        format: r
                    })
                }
                return this
            },
            withSyncPoint: function(t, e) {
                this._withSyncPointDepth++;
                try {
                    t.call(e || this, this)
                } finally {
                    this._withSyncPointDepth--
                }
                return this
            },
            addSyncPoint: function(t, e) {
                var i = this.getAsset(t, e);
                return i && (i.file.syncPoint = !0), this
            },
            removeFile: function(t, e) {
                var i = this.getAsset(t, e);
                i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
            },
            removeAll: function() {
                this._fileList.length = 0, this._flightQueue.length = 0
            },
            start: function() {
                this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
            },
            processLoadQueue: function() {
                if (this.isLoading) {
                    for (var t = 0; t < this._flightQueue.length; t++) {
                        ((s = this._flightQueue[t]).loaded || s.error) && (this._flightQueue.splice(t, 1), t--, s.loading = !1, s.requestUrl = null, s.requestObject = null, s.error && this.onFileError.dispatch(s.key, s), "packfile" !== s.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, s.key, !s.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === s.type && s.error && (this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)))
                    }
                    var e = !1,
                        n = this.enableParallel ? i.Math.clamp(this.maxParallelDownloads, 1, 12) : 1;
                    for (t = this._processingHead; t < this._fileList.length; t++) {
                        var s;
                        if ("packfile" === (s = this._fileList[t]).type && !s.error && s.loaded && t === this._processingHead && (this.processPack(s), this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)), s.loaded || s.error ? t === this._processingHead && (this._processingHead = t + 1) : !s.loading && this._flightQueue.length < n && ("packfile" !== s.type || s.data ? e || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(s), s.loading = !0, this.onFileStart.dispatch(this.progress, s.key, s.url), this.loadFile(s)) : (this._flightQueue.push(s), s.loading = !0, this.loadFile(s))), !s.loaded && s.syncPoint && (e = !0), this._flightQueue.length >= n || e && this._loadedPackCount === this._totalPackCount) break
                    }
                    if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                    else if (!this._flightQueue.length) {
                        var r = this;
                        setTimeout(function() {
                            r.finishedLoading(!0)
                        }, 2e3)
                    }
                } else this.finishedLoading(!0)
            },
            finishedLoading: function(t) {
                this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset())
            },
            asyncComplete: function(t, e) {
                void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e), this.processLoadQueue()
            },
            processPack: function(t) {
                var e = t.data[t.key];
                if (e)
                    for (var n = 0; n < e.length; n++) {
                        var s = e[n];
                        switch (s.type) {
                            case "image":
                                this.image(s.key, s.url, s.overwrite);
                                break;
                            case "text":
                                this.text(s.key, s.url, s.overwrite);
                                break;
                            case "json":
                                this.json(s.key, s.url, s.overwrite);
                                break;
                            case "xml":
                                this.xml(s.key, s.url, s.overwrite);
                                break;
                            case "script":
                                this.script(s.key, s.url, s.callback, t.callbackContext || this);
                                break;
                            case "binary":
                                this.binary(s.key, s.url, s.callback, t.callbackContext || this);
                                break;
                            case "spritesheet":
                                this.spritesheet(s.key, s.url, s.frameWidth, s.frameHeight, s.frameMax, s.margin, s.spacing);
                                break;
                            case "video":
                                this.video(s.key, s.urls);
                                break;
                            case "audio":
                                this.audio(s.key, s.urls, s.autoDecode);
                                break;
                            case "audiosprite":
                                this.audiosprite(s.key, s.urls, s.jsonURL, s.jsonData, s.autoDecode);
                                break;
                            case "tilemap":
                                this.tilemap(s.key, s.url, s.data, i.Tilemap[s.format]);
                                break;
                            case "physics":
                                this.physics(s.key, s.url, s.data, i.Loader[s.format]);
                                break;
                            case "bitmapFont":
                                this.bitmapFont(s.key, s.textureURL, s.atlasURL, s.atlasData, s.xSpacing, s.ySpacing);
                                break;
                            case "atlasJSONArray":
                                this.atlasJSONArray(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                break;
                            case "atlasJSONHash":
                                this.atlasJSONHash(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                break;
                            case "atlasXML":
                                this.atlasXML(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                break;
                            case "atlas":
                                this.atlas(s.key, s.textureURL, s.atlasURL, s.atlasData, i.Loader[s.format]);
                                break;
                            case "shader":
                                this.shader(s.key, s.url, s.overwrite)
                        }
                    }
            },
            transformUrl: function(t, e) {
                return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
            },
            loadFile: function(t) {
                switch (t.type) {
                    case "packfile":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case "image":
                    case "spritesheet":
                    case "textureatlas":
                    case "bitmapfont":
                        this.loadImageTag(t);
                        break;
                    case "audio":
                        t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                        break;
                    case "video":
                        t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                        break;
                    case "json":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                        break;
                    case "xml":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                        break;
                    case "tilemap":
                        t.format === i.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === i.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                        break;
                    case "text":
                    case "script":
                    case "shader":
                    case "physics":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                        break;
                    case "binary":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                }
            },
            loadImageTag: function(t) {
                var e = this;
                t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                }, t.data.onerror = function() {
                    t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
            },
            loadVideoTag: function(t) {
                var e = this;
                t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1;
                var n = function() {
                    t.data.removeEventListener(t.loadEvent, n, !1), t.data.onerror = null, t.data.canplay = !0, i.GAMES[e.game.id].load.fileComplete(t)
                };
                t.data.onerror = function() {
                    t.data.removeEventListener(t.loadEvent, n, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t)
                }, t.data.addEventListener(t.loadEvent, n, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
            },
            loadAudioTag: function(t) {
                var e = this;
                if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                else {
                    t.data = new Audio, t.data.name = t.key;
                    var i = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                    };
                    t.data.onerror = function() {
                        t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                    }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
                }
            },
            xhrLoad: function(t, e, i, n, s) {
                if (this.useXDomainRequest && window.XDomainRequest) this.xhrLoadWithXDR(t, e, i, n, s);
                else {
                    var r = new XMLHttpRequest;
                    r.open("GET", e, !0), r.responseType = i, !1 !== this.headers.requestedWith && r.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && r.setRequestHeader("Accept", this.headers[t.type]), s = s || this.fileError;
                    var o = this;
                    r.onload = function() {
                        try {
                            return 4 === r.readyState && r.status >= 400 && r.status <= 599 ? s.call(o, t, r) : n.call(o, t, r)
                        } catch (e) {
                            o.hasLoaded ? window.console : o.asyncComplete(t, e.message || "Exception")
                        }
                    }, r.onerror = function() {
                        try {
                            return s.call(o, t, r)
                        } catch (e) {
                            o.hasLoaded ? window.console : o.asyncComplete(t, e.message || "Exception")
                        }
                    }, t.requestObject = r, t.requestUrl = e, r.send()
                }
            },
            xhrLoadWithXDR: function(t, e, i, n, s) {
                this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0);
                var r = new window.XDomainRequest;
                r.open("GET", e, !0), r.responseType = i, r.timeout = 3e3, s = s || this.fileError;
                var o = this;
                r.onerror = function() {
                    try {
                        return s.call(o, t, r)
                    } catch (e) {
                        o.asyncComplete(t, e.message || "Exception")
                    }
                }, r.ontimeout = function() {
                    try {
                        return s.call(o, t, r)
                    } catch (e) {
                        o.asyncComplete(t, e.message || "Exception")
                    }
                }, r.onprogress = function() {}, r.onload = function() {
                    try {
                        return 4 === r.readyState && r.status >= 400 && r.status <= 599 ? s.call(o, t, r) : n.call(o, t, r)
                    } catch (e) {
                        o.asyncComplete(t, e.message || "Exception")
                    }
                }, t.requestObject = r, t.requestUrl = e, setTimeout(function() {
                    r.send()
                }, 0)
            },
            getVideoURL: function(t) {
                for (var e = 0; e < t.length; e++) {
                    var i, n = t[e];
                    if (n.uri) {
                        if (i = n.type, n = n.uri, this.game.device.canPlayVideo(i)) return n
                    } else {
                        if (0 === n.indexOf("blob:") || 0 === n.indexOf("data:")) return n;
                        if (n.indexOf("?") >= 0 && (n = n.substr(0, n.indexOf("?"))), i = n.substr((Math.max(0, n.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                    }
                }
                return null
            },
            getAudioURL: function(t) {
                if (this.game.sound.noAudio) return null;
                for (var e = 0; e < t.length; e++) {
                    var i, n = t[e];
                    if (n.uri) {
                        if (i = n.type, n = n.uri, this.game.device.canPlayAudio(i)) return n
                    } else {
                        if (0 === n.indexOf("blob:") || 0 === n.indexOf("data:")) return n;
                        if (n.indexOf("?") >= 0 && (n = n.substr(0, n.indexOf("?"))), i = n.substr((Math.max(0, n.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                    }
                }
                return null
            },
            fileError: function(t, e, i) {
                var n = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
                !i && e && (i = e.status), i && (n = n + " (" + i + ")"), this.asyncComplete(t, n)
            },
            fileComplete: function(t, e) {
                var n = !0;
                switch (t.type) {
                    case "packfile":
                        var s = JSON.parse(e.responseText);
                        t.data = s || {};
                        break;
                    case "image":
                        this.cache.addImage(t.key, t.url, t.data);
                        break;
                    case "spritesheet":
                        this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing);
                        break;
                    case "textureatlas":
                        if (null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format);
                        else if (n = !1, t.format === i.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === i.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === i.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete);
                        else {
                            if (t.format !== i.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                            this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete)
                        }
                        break;
                    case "bitmapfont":
                        t.atlasURL ? (n = !1, this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", function(t, e) {
                            var i;
                            try {
                                i = JSON.parse(e.responseText)
                            } catch (t) {}
                            i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                        })) : this.cache.addBitmapFont(t.key, t.url, t.data, t.atlasData, t.atlasType, t.xSpacing, t.ySpacing);
                        break;
                    case "video":
                        if (t.asBlob) try {
                            t.data = e.response
                        } catch (e) {
                            throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + t.key)
                        }
                        this.cache.addVideo(t.key, t.url, t.data, t.asBlob);
                        break;
                    case "audio":
                        this.game.sound.usingWebAudio ? (t.data = e.response, this.cache.addSound(t.key, t.url, t.data, !0, !1), t.autoDecode && this.game.sound.decode(t.key)) : this.cache.addSound(t.key, t.url, t.data, !1, !0);
                        break;
                    case "text":
                        t.data = e.responseText, this.cache.addText(t.key, t.url, t.data);
                        break;
                    case "shader":
                        t.data = e.responseText, this.cache.addShader(t.key, t.url, t.data);
                        break;
                    case "physics":
                        s = JSON.parse(e.responseText);
                        this.cache.addPhysicsData(t.key, t.url, s, t.format);
                        break;
                    case "script":
                        t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = e.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, e.responseText));
                        break;
                    case "binary":
                        t.callback ? t.data = t.callback.call(t.callbackContext, t.key, e.response) : t.data = e.response, this.cache.addBinary(t.key, t.data)
                }
                n && this.asyncComplete(t)
            },
            jsonLoadComplete: function(t, e) {
                var i = JSON.parse(e.responseText);
                "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
            },
            csvLoadComplete: function(t, e) {
                var i = e.responseText;
                this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
            },
            xmlLoadComplete: function(t, e) {
                var i = e.responseText,
                    n = this.parseXml(i);
                if (n) "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, n, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, n, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, n), this.asyncComplete(t);
                else {
                    e.responseType || e.contentType;
                    this.asyncComplete(t, "invalid XML")
                }
            },
            parseXml: function(t) {
                var e;
                try {
                    if (window.DOMParser) e = (new DOMParser).parseFromString(t, "text/xml");
                    else(e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t)
                } catch (t) {
                    e = null
                }
                return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
            },
            updateProgress: function() {
                this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
            },
            totalLoadedFiles: function() {
                return this._loadedFileCount
            },
            totalQueuedFiles: function() {
                return this._totalFileCount - this._loadedFileCount
            },
            totalLoadedPacks: function() {
                return this._totalPackCount
            },
            totalQueuedPacks: function() {
                return this._totalPackCount - this._loadedPackCount
            }
        }, Object.defineProperty(i.Loader.prototype, "progressFloat", {
            get: function() {
                var t = this._loadedFileCount / this._totalFileCount * 100;
                return i.Math.clamp(t || 0, 0, 100)
            }
        }), Object.defineProperty(i.Loader.prototype, "progress", {
            get: function() {
                return Math.round(this.progressFloat)
            }
        }), i.Loader.prototype.constructor = i.Loader, i.LoaderParser = {
            bitmapFont: function(t, e, i, n) {
                return this.xmlBitmapFont(t, e, i, n)
            },
            xmlBitmapFont: function(t, e, i, n) {
                var s = {},
                    r = t.getElementsByTagName("info")[0],
                    o = t.getElementsByTagName("common")[0];
                s.font = r.getAttribute("face"), s.size = parseInt(r.getAttribute("size"), 10), s.lineHeight = parseInt(o.getAttribute("lineHeight"), 10) + n, s.chars = {};
                for (var a = t.getElementsByTagName("char"), h = 0; h < a.length; h++) {
                    var l = parseInt(a[h].getAttribute("id"), 10);
                    s.chars[l] = {
                        x: parseInt(a[h].getAttribute("x"), 10),
                        y: parseInt(a[h].getAttribute("y"), 10),
                        width: parseInt(a[h].getAttribute("width"), 10),
                        height: parseInt(a[h].getAttribute("height"), 10),
                        xOffset: parseInt(a[h].getAttribute("xoffset"), 10),
                        yOffset: parseInt(a[h].getAttribute("yoffset"), 10),
                        xAdvance: parseInt(a[h].getAttribute("xadvance"), 10) + i,
                        kerning: {}
                    }
                }
                var c = t.getElementsByTagName("kerning");
                for (h = 0; h < c.length; h++) {
                    var u = parseInt(c[h].getAttribute("first"), 10),
                        d = parseInt(c[h].getAttribute("second"), 10),
                        p = parseInt(c[h].getAttribute("amount"), 10);
                    s.chars[d].kerning[u] = p
                }
                return this.finalizeBitmapFont(e, s)
            },
            jsonBitmapFont: function(t, e, i, n) {
                var s = {
                    font: t.font.info._face,
                    size: parseInt(t.font.info._size, 10),
                    lineHeight: parseInt(t.font.common._lineHeight, 10) + n,
                    chars: {}
                };
                return t.font.chars.char.forEach(function(t) {
                    var e = parseInt(t._id, 10);
                    s.chars[e] = {
                        x: parseInt(t._x, 10),
                        y: parseInt(t._y, 10),
                        width: parseInt(t._width, 10),
                        height: parseInt(t._height, 10),
                        xOffset: parseInt(t._xoffset, 10),
                        yOffset: parseInt(t._yoffset, 10),
                        xAdvance: parseInt(t._xadvance, 10) + i,
                        kerning: {}
                    }
                }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                    s.chars[t._second].kerning[t._first] = parseInt(t._amount, 10)
                }), this.finalizeBitmapFont(e, s)
            },
            finalizeBitmapFont: function(t, e) {
                return Object.keys(e.chars).forEach(function(n) {
                    var s = e.chars[n];
                    s.texture = new PIXI.Texture(t, new i.Rectangle(s.x, s.y, s.width, s.height))
                }), e
            }
        }, i.AudioSprite = function(t, e) {
            for (var i in this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {}, this.config.spritemap) {
                var n = this.config.spritemap[i],
                    s = this.game.add.sound(this.key);
                s.addMarker(i, n.start, n.end - n.start, null, n.loop), this.sounds[i] = s
            }
            this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
        }, i.AudioSprite.prototype = {
            play: function(t, e) {
                return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
            },
            stop: function(t) {
                if (t) this.sounds[t].stop();
                else
                    for (var e in this.sounds) this.sounds[e].stop()
            },
            get: function(t) {
                return this.sounds[t]
            }
        }, i.AudioSprite.prototype.constructor = i.AudioSprite, i.Sound = function(t, e, n, s, r) {
            void 0 === n && (n = 1), void 0 === s && (s = !1), void 0 === r && (r = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = s, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = n * this.game.sound.volume, r && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new i.Signal, this.onPlay = new i.Signal, this.onPause = new i.Signal, this.onResume = new i.Signal, this.onLoop = new i.Signal, this.onStop = new i.Signal, this.onMute = new i.Signal, this.onMarkerComplete = new i.Signal, this.onFadeComplete = new i.Signal, this._volume = n, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
        }, i.Sound.prototype = {
            soundHasUnlocked: function(t) {
                t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
            },
            addMarker: function(t, e, i, n, s) {
                void 0 !== i && null !== i || (i = 1), void 0 !== n && null !== n || (n = 1), void 0 === s && (s = !1), this.markers[t] = {
                    name: t,
                    start: e,
                    stop: e + i,
                    volume: n,
                    duration: i,
                    durationMS: 1e3 * i,
                    loop: s
                }
            },
            removeMarker: function(t) {
                delete this.markers[t]
            },
            onEndedHandler: function() {
                this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop()
            },
            update: function() {
                this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0)) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))) : this.destroy()
            },
            loopFull: function(t) {
                return this.play(null, 0, t, !0)
            },
            play: function(t, e, i, n, s) {
                if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === s && (s = !0), this.isPlaying && !this.allowMultiple && !s && !this.override) return this;
                if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || s)) {
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try {
                            this._sound.stop(0)
                        } catch (t) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                    this.isPlaying = !1
                }
                if ("" === t && Object.keys(this.markers).length > 0) return this;
                if ("" !== t) {
                    if (!this.markers[t]) return this;
                    this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== n && (this.loop = n), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                } else e = e || 0, void 0 === i && (i = this._volume), void 0 === n && (n = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = n, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = n;
                return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : (this.loop, this._sound.start(0, this.position, this.duration)), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
            },
            restart: function(t, e, i, n) {
                t = t || "", e = e || 0, i = i || 1, void 0 === n && (n = !1), this.play(t, e, i, n, !0)
            },
            pause: function() {
                this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
            },
            resume: function() {
                if (this.paused && this._sound) {
                    if (this.usingWebAudio) {
                        var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                        this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                        var e = this.duration - this.pausedPosition / 1e3;
                        void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e)
                    } else this._sound.currentTime = this._tempPause, this._sound.play();
                    this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                }
            },
            stop: function() {
                if (this.isPlaying && this._sound)
                    if (this.usingWebAudio) {
                        if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try {
                            this._sound.stop(0)
                        } catch (t) {}
                        this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                    } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                    var t = this.currentMarker;
                    "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
                }
            },
            fadeIn: function(t, e, i) {
                void 0 === e && (e = !0), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, .6))
            },
            fadeOut: function(t) {
                this.fadeTo(t, 0)
            },
            fadeTo: function(t, e) {
                this.isPlaying && !this.paused && e !== this.volume && (void 0 === t && (t = 1e3), void 0 !== e && (this.fadeTween = this.game.add.tween(this).to({
                    volume: e
                }, t, i.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)))
            },
            fadeComplete: function() {
                this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
            },
            updateGlobalVolume: function(t) {
                this.usingAudioTag && this._sound && (this._sound.volume = t * this._volume)
            },
            destroy: function(t) {
                void 0 === t && (t = !0), this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
            }
        }, i.Sound.prototype.constructor = i.Sound, Object.defineProperty(i.Sound.prototype, "isDecoding", {
            get: function() {
                return this.game.cache.getSound(this.key).isDecoding
            }
        }), Object.defineProperty(i.Sound.prototype, "isDecoded", {
            get: function() {
                return this.game.cache.isSoundDecoded(this.key)
            }
        }), Object.defineProperty(i.Sound.prototype, "mute", {
            get: function() {
                return this._muted || this.game.sound.mute
            },
            set: function(t) {
                (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
            }
        }), Object.defineProperty(i.Sound.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                this.game.device.firefox && this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? this._muteVolume = t : (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = t))
            }
        }), i.SoundManager = function(t) {
            this.game = t, this.onSoundDecode = new i.Signal, this.onVolumeChange = new i.Signal, this.onMute = new i.Signal, this.onUnMute = new i.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new i.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null
        }, i.SoundManager.prototype = {
            boot: function() {
                if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1), window.PhaserGlobal) {
                    if (!0 === window.PhaserGlobal.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                    if (!0 === window.PhaserGlobal.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                }
                if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
                else if (window.AudioContext) try {
                    this.context = new window.AudioContext
                } catch (t) {
                    this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                } else if (window.webkitAudioContext) try {
                    this.context = new window.webkitAudioContext
                } catch (t) {
                    this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                }
                if (null === this.context) {
                    if (void 0 === window.Audio) return void(this.noAudio = !0);
                    this.usingAudioTag = !0
                } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
            },
            setTouchLock: function() {
                this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.device.iOSVersion > 8 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0)
            },
            unlock: function() {
                if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null;
                else if (this.usingWebAudio) {
                    var t = this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0)
                }
                return !0
            },
            stopAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
            },
            pauseAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
            },
            resumeAll: function() {
                if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
            },
            decode: function(t, e) {
                e = e || null;
                var i = this.game.cache.getSoundData(t);
                if (i && !1 === this.game.cache.isSoundDecoded(t)) {
                    this.game.cache.updateSound(t, "isDecoding", !0);
                    var n = this;
                    try {
                        this.context.decodeAudioData(i, function(i) {
                            i && (n.game.cache.decodedSound(t, i), n.onSoundDecode.dispatch(t, e))
                        })
                    } catch (t) {}
                }
            },
            setDecodedCallback: function(t, e, n) {
                "string" == typeof t && (t = [t]), this._watchList.reset();
                for (var s = 0; s < t.length; s++) t[s] instanceof i.Sound ? this.game.cache.isSoundDecoded(t[s].key) || this._watchList.add(t[s].key) : this.game.cache.isSoundDecoded(t[s]) || this._watchList.add(t[s]);
                0 === this._watchList.total ? (this._watching = !1, e.call(n)) : (this._watching = !0, this._watchCallback = e, this._watchContext = n)
            },
            update: function() {
                if (!this.noAudio) {
                    !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                    if (this._watching) {
                        for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                        0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                    }
                }
            },
            add: function(t, e, n, s) {
                void 0 === e && (e = 1), void 0 === n && (n = !1), void 0 === s && (s = this.connectToMaster);
                var r = new i.Sound(this.game, t, e, n, s);
                return this._sounds.push(r), r
            },
            addSprite: function(t) {
                return new i.AudioSprite(this.game, t)
            },
            remove: function(t) {
                for (var e = this._sounds.length; e--;)
                    if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                return !1
            },
            removeByKey: function(t) {
                for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                return i
            },
            play: function(t, e, i) {
                if (!this.noAudio) {
                    var n = this.add(t, e, i);
                    return n.play(), n
                }
            },
            setMute: function() {
                if (!this._muted) {
                    this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                    this.onMute.dispatch()
                }
            },
            unsetMute: function() {
                if (this._muted && !this._codeMuted) {
                    this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                    this.onUnMute.dispatch()
                }
            },
            destroy: function() {
                this.stopAll();
                for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
            }
        }, i.SoundManager.prototype.constructor = i.SoundManager, Object.defineProperty(i.SoundManager.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || !1) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(i.SoundManager.prototype, "volume", {
            get: function() {
                return this._volume
            },
            set: function(t) {
                if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) {
                    if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                    else
                        for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                    this.onVolumeChange.dispatch(t)
                }
            }
        }), i.ScaleManager = function(t, e, n) {
            this.game = t, this.dom = i.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new i.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new i.Signal, this.enterIncorrectOrientation = new i.Signal, this.leaveIncorrectOrientation = new i.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new i.Signal, this.onFullScreenChange = new i.Signal, this.onFullScreenError = new i.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new i.Point(1, 1), this.scaleFactorInversed = new i.Point(1, 1), this.margin = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
                x: 0,
                y: 0
            }, this.bounds = new i.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                right: "layout",
                bottom: ""
            }, this.compatibility = {
                supportsFullScreen: !1,
                orientationFallback: null,
                noMargins: !1,
                scrollTo: null,
                forceMinimumDocumentHeight: !1,
                canExpandParent: !0,
                clickTrampoline: ""
            }, this._scaleMode = i.ScaleManager.NO_SCALE, this._fullScreenScaleMode = i.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new i.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new i.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new i.Rectangle, this._userScaleFactor = new i.Point(1, 1), this._userScaleTrim = new i.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new i.Rectangle, this._tempBounds = new i.Rectangle, this._lastReportedCanvasSize = new i.Rectangle, this._lastReportedGameSize = new i.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, n)
        }, i.ScaleManager.EXACT_FIT = 0, i.ScaleManager.NO_SCALE = 1, i.ScaleManager.SHOW_ALL = 2, i.ScaleManager.RESIZE = 3, i.ScaleManager.USER_SCALE = 4, i.ScaleManager.prototype = {
            boot: function() {
                var t = this.compatibility;
                t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new i.Point(0, 1) : t.scrollTo = new i.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                var e = this;
                this._orientationChange = function(t) {
                    return e.orientationChange(t)
                }, this._windowResize = function(t) {
                    return e.windowResize(t)
                }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                    return e.fullScreenChange(t)
                }, this._fullScreenError = function(t) {
                    return e.fullScreenError(t)
                }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), i.FlexGrid && (this.grid = new i.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
            },
            parseConfig: function(t) {
                void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget)
            },
            setupScale: function(t, e) {
                var n, s = new i.Rectangle;
                "" !== this.game.parent && ("string" == typeof this.game.parent ? n = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (n = this.game.parent)), n ? (this.parentNode = n, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), s.width = this._parentBounds.width, s.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, s.width = this.dom.visualBounds.width, s.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                var r = 0,
                    o = 0;
                "number" == typeof t ? r = t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, r = s.width * this.parentScaleFactor.x), "number" == typeof e ? o = e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, o = s.height * this.parentScaleFactor.y), r = Math.floor(r), o = Math.floor(o), this._gameSize.setTo(0, 0, r, o), this.updateDimensions(r, o, !1)
            },
            _gameResumed: function() {
                this.queueUpdate(!0)
            },
            setGameSize: function(t, e) {
                this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== i.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
            },
            setUserScale: function(t, e, i, n) {
                this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | n), this.queueUpdate(!0)
            },
            setResizeCallback: function(t, e) {
                this.onResize = t, this.onResizeContext = e
            },
            signalSizeChange: function() {
                if (!i.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !i.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                    var t = this.width,
                        e = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === i.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e))
                }
            },
            setMinMax: function(t, e, i, n) {
                this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== n && (this.maxHeight = n)
            },
            preUpdate: function() {
                if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                    var t = this._updateThrottle;
                    this._updateThrottleReset = t >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                    var e = this._parentBounds.width,
                        n = this._parentBounds.height,
                        s = this.getParentBounds(this._parentBounds),
                        r = s.width !== e || s.height !== n,
                        o = this.updateOrientationState();
                    (r || o) && (this.onResize && this.onResize.call(this.onResizeContext, this, s), this.updateLayout(), this.signalSizeChange());
                    var a = 2 * this._updateThrottle;
                    this._updateThrottle < t && (a = Math.min(t, this._updateThrottleReset)), this._updateThrottle = i.Math.clamp(a, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                }
            },
            pauseUpdate: function() {
                this.preUpdate(), this._updateThrottle = this.trackParentInterval
            },
            updateDimensions: function(t, e, i) {
                this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
            },
            updateScalingAndBounds: function() {
                this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
            },
            forceOrientation: function(t, e) {
                void 0 === e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)
            },
            classifyOrientation: function(t) {
                return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
            },
            updateOrientationState: function() {
                var t = this.screenOrientation,
                    e = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                var i = t !== this.screenOrientation,
                    n = e !== this.incorrectOrientation;
                return n && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || n) && this.onOrientationChange.dispatch(this, t, e), i || n
            },
            orientationChange: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            windowResize: function(t) {
                this.event = t, this.queueUpdate(!0)
            },
            scrollTop: function() {
                var t = this.compatibility.scrollTo;
                t && window.scrollTo(t.x, t.y)
            },
            refresh: function() {
                this.scrollTop(), this.queueUpdate(!0)
            },
            updateLayout: function() {
                var t = this.currentScaleMode;
                if (t !== i.ScaleManager.RESIZE) {
                    if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === i.ScaleManager.EXACT_FIT ? this.setExactFit() : t === i.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : t === i.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === i.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === i.ScaleManager.SHOW_ALL || t === i.ScaleManager.USER_SCALE)) {
                        var e = this.getParentBounds(this._tempBounds);
                        this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height)
                    }
                    this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
                } else this.reflowGame()
            },
            getParentBounds: function(t) {
                var e = t || new i.Rectangle,
                    n = this.boundingParent,
                    s = this.dom.visualBounds,
                    r = this.dom.layoutBounds;
                if (n) {
                    var o = n.getBoundingClientRect(),
                        a = n.offsetParent ? n.offsetParent.getBoundingClientRect() : n.getBoundingClientRect();
                    e.setTo(o.left - a.left, o.top - a.top, o.width, o.height);
                    var h = this.windowConstraints;
                    if (h.right) {
                        var l = "layout" === h.right ? r : s;
                        e.right = Math.min(e.right, l.width)
                    }
                    if (h.bottom) {
                        l = "layout" === h.bottom ? r : s;
                        e.bottom = Math.min(e.bottom, l.height)
                    }
                } else e.setTo(0, 0, s.width, s.height);
                return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)), e
            },
            alignCanvas: function(t, e) {
                var i = this.getParentBounds(this._tempBounds),
                    n = this.game.canvas,
                    s = this.margin;
                if (t) {
                    s.left = s.right = 0;
                    var r = n.getBoundingClientRect();
                    if (this.width < i.width && !this.incorrectOrientation) {
                        var o = r.left - i.x,
                            a = i.width / 2 - this.width / 2,
                            h = (a = Math.max(a, 0)) - o;
                        s.left = Math.round(h)
                    }
                    n.style.marginLeft = s.left + "px", 0 !== s.left && (s.right = -(i.width - r.width - s.left), n.style.marginRight = s.right + "px")
                }
                if (e) {
                    s.top = s.bottom = 0;
                    r = n.getBoundingClientRect();
                    if (this.height < i.height && !this.incorrectOrientation) {
                        o = r.top - i.y, a = i.height / 2 - this.height / 2, h = (a = Math.max(a, 0)) - o;
                        s.top = Math.round(h)
                    }
                    n.style.marginTop = s.top + "px", 0 !== s.top && (s.bottom = -(i.height - r.height - s.top), n.style.marginBottom = s.bottom + "px")
                }
                s.x = s.left, s.y = s.top
            },
            reflowGame: function() {
                this.resetCanvas("", "");
                var t = this.getParentBounds(this._tempBounds);
                this.updateDimensions(t.width, t.height, !0)
            },
            reflowCanvas: function() {
                this.incorrectOrientation || (this.width = i.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = i.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
            },
            resetCanvas: function(t, e) {
                void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                var i = this.game.canvas;
                this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
            },
            queueUpdate: function(t) {
                t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
            },
            reset: function(t) {
                t && this.grid && this.grid.reset()
            },
            setMaximum: function() {
                this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
            },
            setShowAll: function(t) {
                var e, i = this.getParentBounds(this._tempBounds),
                    n = i.width,
                    s = i.height;
                e = t ? Math.max(s / this.game.height, n / this.game.width) : Math.min(s / this.game.height, n / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
            },
            setExactFit: function() {
                var t = this.getParentBounds(this._tempBounds);
                this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
            },
            createFullScreenTarget: function() {
                var t = document.createElement("div");
                return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
            },
            startFullScreen: function(t, e) {
                if (this.isFullScreen) return !1;
                if (this.compatibility.supportsFullScreen) {
                    if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                        var n = this.game.input;
                        if (n.activePointer && n.activePointer !== n.mousePointer && (e || !1 !== e)) return void n.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                    }
                    void 0 !== t && this.game.renderType === i.CANVAS && (this.game.stage.smoothed = t);
                    var s = this.fullScreenTarget;
                    s || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), s = this._createdFullScreenTarget);
                    var r = {
                        targetElement: s
                    };
                    if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, r), this._createdFullScreenTarget) {
                        var o = this.game.canvas;
                        o.parentNode.insertBefore(s, o), s.appendChild(o)
                    }
                    return this.game.device.fullscreenKeyboard ? s[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : s[this.game.device.requestFullscreen](), !0
                }
                var a = this;
                setTimeout(function() {
                    a.fullScreenError()
                }, 10)
            },
            stopFullScreen: function() {
                return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0)
            },
            cleanupCreatedTarget: function() {
                var t = this._createdFullScreenTarget;
                if (t && t.parentNode) {
                    var e = t.parentNode;
                    e.insertBefore(this.game.canvas, t), e.removeChild(t)
                }
                this._createdFullScreenTarget = null
            },
            prepScreenMode: function(t) {
                var e = !!this._createdFullScreenTarget,
                    n = this._createdFullScreenTarget || this.fullScreenTarget;
                t ? (e || this.fullScreenScaleMode === i.ScaleManager.EXACT_FIT) && n !== this.game.canvas && (this._fullScreenRestore = {
                    targetWidth: n.style.width,
                    targetHeight: n.style.height
                }, n.style.width = "100%", n.style.height = "100%") : (this._fullScreenRestore && (n.style.width = this._fullScreenRestore.targetWidth, n.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
            },
            fullScreenChange: function(t) {
                this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
            },
            fullScreenError: function(t) {
                this.event = t, this.cleanupCreatedTarget(), this.onFullScreenError.dispatch(this)
            },
            scaleSprite: function(t, e, i, n) {
                if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === n && (n = !1), !t || !t.scale) return t;
                if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                var s = e,
                    r = t.height * e / t.width,
                    o = t.width * i / t.height,
                    a = i,
                    h = o > e;
                return (h = h ? n : !n) ? (t.width = Math.floor(s), t.height = Math.floor(r)) : (t.width = Math.floor(o), t.height = Math.floor(a)), t
            },
            destroy: function() {
                this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
            }
        }, i.ScaleManager.prototype.constructor = i.ScaleManager, Object.defineProperty(i.ScaleManager.prototype, "boundingParent", {
            get: function() {
                return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "scaleMode", {
            get: function() {
                return this._scaleMode
            },
            set: function(t) {
                return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "fullScreenScaleMode", {
            get: function() {
                return this._fullScreenScaleMode
            },
            set: function(t) {
                return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "currentScaleMode", {
            get: function() {
                return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignHorizontally", {
            get: function() {
                return this._pageAlignHorizontally
            },
            set: function(t) {
                t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignVertically", {
            get: function() {
                return this._pageAlignVertically
            },
            set: function(t) {
                t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isFullScreen", {
            get: function() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isPortrait", {
            get: function() {
                return "portrait" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isLandscape", {
            get: function() {
                return "landscape" === this.classifyOrientation(this.screenOrientation)
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isGamePortrait", {
            get: function() {
                return this.height > this.width
            }
        }), Object.defineProperty(i.ScaleManager.prototype, "isGameLandscape", {
            get: function() {
                return this.width > this.height
            }
        }), i.Utils.Debug = function(t) {
            this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1
        }, i.Utils.Debug.prototype = {
            boot: function() {
                this.game.renderType === i.CANVAS ? this.context = this.game.context : (this.bmd = new i.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d"))
            },
            resize: function(t, e, i) {
                this.bmd.resize(e, i), this.canvas.width = e, this.canvas.height = i
            },
            preUpdate: function() {
                this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
            },
            reset: function() {
                this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
            },
            start: function(t, e, i, n) {
                "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === n && (n = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = n, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
            },
            stop: function() {
                this.context.restore()
            },
            line: function() {
                for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                this.currentY += this.lineHeight
            },
            soundInfo: function(t, e, i, n) {
                this.start(e, i, n), this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying), this.line("Time: " + t.currentTime), this.line("Volume: " + t.volume + " Muted: " + t.mute), this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
            },
            cameraInfo: function(t, e, i, n) {
                this.start(e, i, n), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("X: " + t.x + " Y: " + t.y), t.bounds && this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height), this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height), this.line("Total in view: " + t.totalInView), this.stop()
            },
            timer: function(t, e, i, n) {
                this.start(e, i, n), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
            },
            pointer: function(t, e, i, n, s) {
                null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", n = n || "rgba(255,0,0,0.5)", !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, s), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = i : this.context.fillStyle = n, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop()))
            },
            spriteInputInfo: function(t, e, i, n) {
                this.start(e, i, n), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
            },
            key: function(t, e, i, n) {
                this.start(e, i, n, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
            },
            inputInfo: function(t, e, i) {
                this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
            },
            spriteBounds: function(t, e, i) {
                var n = t.getBounds();
                n.x += this.game.camera.x, n.y += this.game.camera.y, this.rectangle(n, e, i)
            },
            ropeSegments: function(t, e, i) {
                var n = this;
                t.segments.forEach(function(t) {
                    n.rectangle(t, e, i)
                }, this)
            },
            spriteInfo: function(t, e, i, n) {
                this.start(e, i, n), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.stop()
            },
            spriteCoords: function(t, e, i, n) {
                this.start(e, i, n, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
            },
            lineInfo: function(t, e, i, n) {
                this.start(e, i, n, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
            },
            pixel: function(t, e, i, n) {
                n = n || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, n, n), this.stop()
            },
            geom: function(t, e, n, s) {
                void 0 === n && (n = !0), void 0 === s && (s = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, t instanceof i.Rectangle || 1 === s ? n ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof i.Circle || 2 === s ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), n ? this.context.fill() : this.context.stroke()) : t instanceof i.Point || 3 === s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof i.Line || 4 === s) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop()
            },
            rectangle: function(t, e, i) {
                void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
            },
            text: function(t, e, i, n, s) {
                n = n || "rgb(255,255,255)", s = s || "16px Courier", this.start(), this.context.font = s, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = n, this.context.fillText(t, e, i), this.stop()
            },
            quadTree: function(t, e) {
                e = e || "rgba(255,0,0,0.3)", this.start();
                var i = t.bounds;
                if (0 === t.nodes.length) {
                    this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                    for (var n = 0; n < t.objects.length; n++) this.context.strokeRect(t.objects[n].x, t.objects[n].y, t.objects[n].width, t.objects[n].height)
                } else
                    for (n = 0; n < t.nodes.length; n++) this.quadTree(t.nodes[n]);
                this.stop()
            },
            body: function(t, e, n) {
                t.body && (this.start(), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.render(this.context, t.body, e, n) : t.body.type === i.Physics.NINJA ? i.Physics.Ninja.Body.render(this.context, t.body, e, n) : t.body.type === i.Physics.BOX2D && i.Physics.Box2D.renderBody(this.context, t.body, e), this.stop())
            },
            bodyInfo: function(t, e, n, s) {
                t.body && (this.start(e, n, s, 210), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === i.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
            },
            box2dWorld: function() {
                this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
            },
            box2dBody: function(t, e) {
                this.start(), i.Physics.Box2D.renderBody(this.context, t, e), this.stop()
            },
            displayList: function(t) {
                if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID"), t.children && t.children.length > 0)
                    for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
            },
            destroy: function() {
                PIXI.CanvasPool.remove(this)
            }
        }, i.Utils.Debug.prototype.constructor = i.Utils.Debug, i.DOM = {
            getOffset: function(t, e) {
                e = e || new i.Point;
                var n = t.getBoundingClientRect(),
                    s = i.DOM.scrollY,
                    r = i.DOM.scrollX,
                    o = document.documentElement.clientTop,
                    a = document.documentElement.clientLeft;
                return e.x = n.left + r - a, e.y = n.top + s - o, e
            },
            getBounds: function(t, e) {
                return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
            },
            calibrate: function(t, e) {
                e = +e || 0;
                var i = {
                    width: 0,
                    height: 0,
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
            },
            getAspectRatio: function(t) {
                var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width,
                    i = t.height;
                return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
            },
            inLayoutViewport: function(t, e) {
                var i = this.getBounds(t, e);
                return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
            },
            getScreenOrientation: function(t) {
                var e = window.screen,
                    i = e.orientation || e.mozOrientation || e.msOrientation;
                if (i && "string" == typeof i.type) return i.type;
                if ("string" == typeof i) return i;
                var n = "portrait-primary",
                    s = "landscape-primary";
                if ("screen" === t) return e.height > e.width ? n : s;
                if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? n : s;
                if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? n : s;
                if (window.matchMedia) {
                    if (window.matchMedia("(orientation: portrait)").matches) return n;
                    if (window.matchMedia("(orientation: landscape)").matches) return s
                }
                return this.visualBounds.height > this.visualBounds.width ? n : s
            },
            visualBounds: new i.Rectangle,
            layoutBounds: new i.Rectangle,
            documentBounds: new i.Rectangle
        }, i.Device.whenReady(function(t) {
            var e = window && "pageXOffset" in window ? function() {
                    return window.pageXOffset
                } : function() {
                    return document.documentElement.scrollLeft
                },
                n = window && "pageYOffset" in window ? function() {
                    return window.pageYOffset
                } : function() {
                    return document.documentElement.scrollTop
                };
            if (Object.defineProperty(i.DOM, "scrollX", {
                    get: e
                }), Object.defineProperty(i.DOM, "scrollY", {
                    get: n
                }), Object.defineProperty(i.DOM.visualBounds, "x", {
                    get: e
                }), Object.defineProperty(i.DOM.visualBounds, "y", {
                    get: n
                }), Object.defineProperty(i.DOM.layoutBounds, "x", {
                    value: 0
                }), Object.defineProperty(i.DOM.layoutBounds, "y", {
                    value: 0
                }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                var s = function() {
                        return Math.max(window.innerWidth, document.documentElement.clientWidth)
                    },
                    r = function() {
                        return Math.max(window.innerHeight, document.documentElement.clientHeight)
                    };
                Object.defineProperty(i.DOM.visualBounds, "width", {
                    get: s
                }), Object.defineProperty(i.DOM.visualBounds, "height", {
                    get: r
                }), Object.defineProperty(i.DOM.layoutBounds, "width", {
                    get: s
                }), Object.defineProperty(i.DOM.layoutBounds, "height", {
                    get: r
                })
            } else Object.defineProperty(i.DOM.visualBounds, "width", {
                get: function() {
                    return window.innerWidth
                }
            }), Object.defineProperty(i.DOM.visualBounds, "height", {
                get: function() {
                    return window.innerHeight
                }
            }), Object.defineProperty(i.DOM.layoutBounds, "width", {
                get: function() {
                    var t = document.documentElement.clientWidth,
                        e = window.innerWidth;
                    return t < e ? e : t
                }
            }), Object.defineProperty(i.DOM.layoutBounds, "height", {
                get: function() {
                    var t = document.documentElement.clientHeight,
                        e = window.innerHeight;
                    return t < e ? e : t
                }
            });
            Object.defineProperty(i.DOM.documentBounds, "x", {
                value: 0
            }), Object.defineProperty(i.DOM.documentBounds, "y", {
                value: 0
            }), Object.defineProperty(i.DOM.documentBounds, "width", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                }
            }), Object.defineProperty(i.DOM.documentBounds, "height", {
                get: function() {
                    var t = document.documentElement;
                    return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                }
            })
        }, null, !0), i.ArraySet = function(t) {
            this.position = 0, this.list = t || []
        }, i.ArraySet.prototype = {
            add: function(t) {
                return this.exists(t) || this.list.push(t), t
            },
            getIndex: function(t) {
                return this.list.indexOf(t)
            },
            getByKey: function(t, e) {
                for (var i = this.list.length; i--;)
                    if (this.list[i][t] === e) return this.list[i];
                return null
            },
            exists: function(t) {
                return this.list.indexOf(t) > -1
            },
            reset: function() {
                this.list.length = 0
            },
            remove: function(t) {
                var e = this.list.indexOf(t);
                if (e > -1) return this.list.splice(e, 1), t
            },
            setAll: function(t, e) {
                for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
            },
            callAll: function(t) {
                for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
            },
            removeAll: function(t) {
                void 0 === t && (t = !1);
                for (var e = this.list.length; e--;)
                    if (this.list[e]) {
                        var i = this.remove(this.list[e]);
                        t && i.destroy()
                    }
                this.position = 0, this.list = []
            }
        }, Object.defineProperty(i.ArraySet.prototype, "total", {
            get: function() {
                return this.list.length
            }
        }), Object.defineProperty(i.ArraySet.prototype, "first", {
            get: function() {
                return this.position = 0, this.list.length > 0 ? this.list[0] : null
            }
        }), Object.defineProperty(i.ArraySet.prototype, "next", {
            get: function() {
                return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
            }
        }), i.ArraySet.prototype.constructor = i.ArraySet, i.ArrayUtils = {
            getRandomItem: function(t, e, i) {
                if (null === t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var n = e + Math.floor(Math.random() * i);
                return void 0 === t[n] ? null : t[n]
            },
            removeRandomItem: function(t, e, i) {
                if (null == t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length);
                var n = e + Math.floor(Math.random() * i);
                if (n < t.length) {
                    var s = t.splice(n, 1);
                    return void 0 === s[0] ? null : s[0]
                }
                return null
            },
            shuffle: function(t) {
                for (var e = t.length - 1; e > 0; e--) {
                    var i = Math.floor(Math.random() * (e + 1)),
                        n = t[e];
                    t[e] = t[i], t[i] = n
                }
                return t
            },
            transposeMatrix: function(t) {
                for (var e = t.length, i = t[0].length, n = new Array(i), s = 0; s < i; s++) {
                    n[s] = new Array(e);
                    for (var r = e - 1; r > -1; r--) n[s][r] = t[r][s]
                }
                return n
            },
            rotateMatrix: function(t, e) {
                if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = (t = i.ArrayUtils.transposeMatrix(t)).reverse();
                else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = i.ArrayUtils.transposeMatrix(t);
                else if (180 === Math.abs(e) || "rotate180" === e) {
                    for (var n = 0; n < t.length; n++) t[n].reverse();
                    t = t.reverse()
                }
                return t
            },
            findClosest: function(t, e) {
                if (!e.length) return NaN;
                if (1 === e.length || t < e[0]) return e[0];
                for (var i = 1; e[i] < t;) i++;
                var n = e[i - 1],
                    s = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                return s - t <= t - n ? s : n
            },
            rotateRight: function(t) {
                var e = t.pop();
                return t.unshift(e), e
            },
            rotateLeft: function(t) {
                var e = t.shift();
                return t.push(e), e
            },
            rotate: function(t) {
                var e = t.shift();
                return t.push(e), e
            },
            numberArray: function(t, e) {
                for (var i = [], n = t; n <= e; n++) i.push(n);
                return i
            },
            numberArrayStep: function(t, e, n) {
                void 0 !== t && null !== t || (t = 0), void 0 !== e && null !== e || (e = t, t = 0), void 0 === n && (n = 1);
                for (var s = [], r = Math.max(i.Math.roundAwayFromZero((e - t) / (n || 1)), 0), o = 0; o < r; o++) s.push(t), t += n;
                return s
            }
        }, i.LinkedList = function() {
            this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
        }, i.LinkedList.prototype = {
            add: function(t) {
                return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
            },
            reset: function() {
                this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
            },
            remove: function(t) {
                if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total--
            },
            callAll: function(t) {
                if (this.first && this.last) {
                    var e = this.first;
                    do {
                        e && e[t] && e[t].call(e), e = e.next
                    } while (e !== this.last.next)
                }
            }
        }, i.LinkedList.prototype.constructor = i.LinkedList, i.Create = function(t) {
            this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                0: "#000",
                1: "#9D9D9D",
                2: "#FFF",
                3: "#BE2633",
                4: "#E06F8B",
                5: "#493C2B",
                6: "#A46422",
                7: "#EB8931",
                8: "#F7E26B",
                9: "#2F484E",
                A: "#44891A",
                B: "#A3CE27",
                C: "#1B2632",
                D: "#005784",
                E: "#31A2F2",
                F: "#B2DCEF"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#f5f4eb"
            }, {
                0: "#000",
                1: "#2234d1",
                2: "#0c7e45",
                3: "#44aacc",
                4: "#8a3622",
                5: "#5c2e78",
                6: "#aa5c3d",
                7: "#b5b5b5",
                8: "#5e606e",
                9: "#4c81fb",
                A: "#6cd947",
                B: "#7be2f9",
                C: "#eb8a60",
                D: "#e23d69",
                E: "#ffd93f",
                F: "#fff"
            }, {
                0: "#000",
                1: "#fff",
                2: "#8b4131",
                3: "#7bbdc5",
                4: "#8b41ac",
                5: "#6aac41",
                6: "#3931a4",
                7: "#d5de73",
                8: "#945a20",
                9: "#5a4100",
                A: "#bd736a",
                B: "#525252",
                C: "#838383",
                D: "#acee8b",
                E: "#7b73de",
                F: "#acacac"
            }, {
                0: "#000",
                1: "#191028",
                2: "#46af45",
                3: "#a1d685",
                4: "#453e78",
                5: "#7664fe",
                6: "#833129",
                7: "#9ec2e8",
                8: "#dc534b",
                9: "#e18d79",
                A: "#d6b97b",
                B: "#e9d8a1",
                C: "#216c4b",
                D: "#d365c8",
                E: "#afaab9",
                F: "#fff"
            }]
        }, i.Create.PALETTE_ARNE = 0, i.Create.PALETTE_JMP = 1, i.Create.PALETTE_CGA = 2, i.Create.PALETTE_C64 = 3, i.Create.PALETTE_JAPANESE_MACHINE = 4, i.Create.prototype = {
            texture: function(t, e, i, n, s) {
                void 0 === i && (i = 8), void 0 === n && (n = i), void 0 === s && (s = 0);
                var r = e[0].length * i,
                    o = e.length * n;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(r, o), this.bmd.clear();
                for (var a = 0; a < e.length; a++)
                    for (var h = e[a], l = 0; l < h.length; l++) {
                        var c = h[l];
                        "." !== c && " " !== c && (this.ctx.fillStyle = this.palettes[s][c], this.ctx.fillRect(l * i, a * n, i, n))
                    }
                return this.bmd.generateTexture(t)
            },
            grid: function(t, e, i, n, s, r) {
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = r;
                for (var o = 0; o < i; o += s) this.ctx.fillRect(0, o, e, 1);
                for (var a = 0; a < e; a += n) this.ctx.fillRect(a, 0, 1, i);
                return this.bmd.generateTexture(t)
            }
        }, i.Create.prototype.constructor = i.Create, i.FlexGrid = function(t, e, n) {
            this.game = t.game, this.manager = t, this.width = e, this.height = n, this.boundsCustom = new i.Rectangle(0, 0, e, n), this.boundsFluid = new i.Rectangle(0, 0, e, n), this.boundsFull = new i.Rectangle(0, 0, e, n), this.boundsNone = new i.Rectangle(0, 0, e, n), this.positionCustom = new i.Point(0, 0), this.positionFluid = new i.Point(0, 0), this.positionFull = new i.Point(0, 0), this.positionNone = new i.Point(0, 0), this.scaleCustom = new i.Point(1, 1), this.scaleFluid = new i.Point(1, 1), this.scaleFluidInversed = new i.Point(1, 1), this.scaleFull = new i.Point(1, 1), this.scaleNone = new i.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = e / n, this.ratioV = n / e, this.multiplier = 0, this.layers = []
        }, i.FlexGrid.prototype = {
            setSize: function(t, e) {
                this.width = t, this.height = e, this.ratioH = t / e, this.ratioV = e / t, this.scaleNone = new i.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
            },
            createCustomLayer: function(t, e, n, s) {
                void 0 === s && (s = !0), this.customWidth = t, this.customHeight = e, this.boundsCustom.width = t, this.boundsCustom.height = e;
                var r = new i.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                return s && this.game.world.add(r), this.layers.push(r), void 0 !== n && null !== typeof n && r.addMultiple(n), r
            },
            createFluidLayer: function(t, e) {
                void 0 === e && (e = !0);
                var n = new i.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                return e && this.game.world.add(n), this.layers.push(n), void 0 !== t && null !== typeof t && n.addMultiple(t), n
            },
            createFullLayer: function(t) {
                var e = new i.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
            },
            createFixedLayer: function(t) {
                var e = new i.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
            },
            reset: function() {
                for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
            },
            onResize: function(t, e) {
                this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e)
            },
            refresh: function() {
                this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
            },
            fitSprite: function(t) {
                this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY
            },
            debug: function() {
                this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
            }
        }, i.FlexGrid.prototype.constructor = i.FlexGrid, i.FlexLayer = function(t, e, n, s) {
            i.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1), this.manager = t.manager, this.grid = t, this.persist = !1, this.position = e, this.bounds = n, this.scale = s, this.topLeft = n.topLeft, this.topMiddle = new i.Point(n.halfWidth, 0), this.topRight = n.topRight, this.bottomLeft = n.bottomLeft, this.bottomMiddle = new i.Point(n.halfWidth, n.bottom), this.bottomRight = n.bottomRight
        }, i.FlexLayer.prototype = Object.create(i.Group.prototype), i.FlexLayer.prototype.constructor = i.FlexLayer, i.FlexLayer.prototype.resize = function() {}, i.FlexLayer.prototype.debug = function() {
            this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
        }, i.Color = {
            packPixel: function(t, e, n, s) {
                return i.Device.LITTLE_ENDIAN ? (s << 24 | n << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | n << 8 | s) >>> 0
            },
            unpackPixel: function(t, e, n, s) {
                return void 0 !== e && null !== e || (e = i.Color.createColor()), void 0 !== n && null !== n || (n = !1), void 0 !== s && null !== s || (s = !1), i.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", n && i.Color.RGBtoHSL(e.r, e.g, e.b, e), s && i.Color.RGBtoHSV(e.r, e.g, e.b, e), e
            },
            fromRGBA: function(t, e) {
                return e || (e = i.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
            },
            toRGBA: function(t, e, i, n) {
                return t << 24 | e << 16 | i << 8 | n
            },
            toABGR: function(t, e, i, n) {
                return (n << 24 | i << 16 | e << 8 | t) >>> 0
            },
            RGBtoHSL: function(t, e, n, s) {
                s || (s = i.Color.createColor(t, e, n, 1)), t /= 255, e /= 255, n /= 255;
                var r = Math.min(t, e, n),
                    o = Math.max(t, e, n);
                if (s.h = 0, s.s = 0, s.l = (o + r) / 2, o !== r) {
                    var a = o - r;
                    s.s = s.l > .5 ? a / (2 - o - r) : a / (o + r), o === t ? s.h = (e - n) / a + (e < n ? 6 : 0) : o === e ? s.h = (n - t) / a + 2 : o === n && (s.h = (t - e) / a + 4), s.h /= 6
                }
                return s
            },
            HSLtoRGB: function(t, e, n, s) {
                if (s ? (s.r = n, s.g = n, s.b = n) : s = i.Color.createColor(n, n, n), 0 !== e) {
                    var r = n < .5 ? n * (1 + e) : n + e - n * e,
                        o = 2 * n - r;
                    s.r = i.Color.hueToColor(o, r, t + 1 / 3), s.g = i.Color.hueToColor(o, r, t), s.b = i.Color.hueToColor(o, r, t - 1 / 3)
                }
                return s.r = Math.floor(255 * s.r | 0), s.g = Math.floor(255 * s.g | 0), s.b = Math.floor(255 * s.b | 0), i.Color.updateColor(s), s
            },
            RGBtoHSV: function(t, e, n, s) {
                s || (s = i.Color.createColor(t, e, n, 255)), t /= 255, e /= 255, n /= 255;
                var r = Math.min(t, e, n),
                    o = Math.max(t, e, n),
                    a = o - r;
                return s.h = 0, s.s = 0 === o ? 0 : a / o, s.v = o, o !== r && (o === t ? s.h = (e - n) / a + (e < n ? 6 : 0) : o === e ? s.h = (n - t) / a + 2 : o === n && (s.h = (t - e) / a + 4), s.h /= 6), s
            },
            HSVtoRGB: function(t, e, n, s) {
                var r, o, a;
                void 0 === s && (s = i.Color.createColor(0, 0, 0, 1, t, e, 0, n));
                var h = Math.floor(6 * t),
                    l = 6 * t - h,
                    c = n * (1 - e),
                    u = n * (1 - l * e),
                    d = n * (1 - (1 - l) * e);
                switch (h % 6) {
                    case 0:
                        r = n, o = d, a = c;
                        break;
                    case 1:
                        r = u, o = n, a = c;
                        break;
                    case 2:
                        r = c, o = n, a = d;
                        break;
                    case 3:
                        r = c, o = u, a = n;
                        break;
                    case 4:
                        r = d, o = c, a = n;
                        break;
                    case 5:
                        r = n, o = c, a = u
                }
                return s.r = Math.floor(255 * r), s.g = Math.floor(255 * o), s.b = Math.floor(255 * a), i.Color.updateColor(s), s
            },
            hueToColor: function(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
            },
            createColor: function(t, e, n, s, r, o, a, h) {
                var l = {
                    r: t || 0,
                    g: e || 0,
                    b: n || 0,
                    a: s || 1,
                    h: r || 0,
                    s: o || 0,
                    l: a || 0,
                    v: h || 0,
                    color: 0,
                    color32: 0,
                    rgba: ""
                };
                return i.Color.updateColor(l)
            },
            updateColor: function(t) {
                return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")", t.color = i.Color.getColor(t.r, t.g, t.b), t.color32 = i.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
            },
            getColor32: function(t, e, i, n) {
                return t << 24 | e << 16 | i << 8 | n
            },
            getColor: function(t, e, i) {
                return t << 16 | e << 8 | i
            },
            RGBtoString: function(t, e, n, s, r) {
                return void 0 === s && (s = 255), void 0 === r && (r = "#"), "#" === r ? "#" + ((1 << 24) + (t << 16) + (e << 8) + n).toString(16).slice(1) : "0x" + i.Color.componentToHex(s) + i.Color.componentToHex(t) + i.Color.componentToHex(e) + i.Color.componentToHex(n)
            },
            hexToRGB: function(t) {
                var e = i.Color.hexToColor(t);
                if (e) return i.Color.getColor32(e.a, e.r, e.g, e.b)
            },
            hexToColor: function(t, e) {
                t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, n) {
                    return e + e + i + i + n + n
                });
                var n = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                if (n) {
                    var s = parseInt(n[1], 16),
                        r = parseInt(n[2], 16),
                        o = parseInt(n[3], 16);
                    e ? (e.r = s, e.g = r, e.b = o) : e = i.Color.createColor(s, r, o)
                }
                return e
            },
            webToColor: function(t, e) {
                e || (e = i.Color.createColor());
                var n = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                return n && (e.r = parseInt(n[1], 10), e.g = parseInt(n[2], 10), e.b = parseInt(n[3], 10), e.a = void 0 !== n[4] ? parseFloat(n[4]) : 1, i.Color.updateColor(e)), e
            },
            valueToColor: function(t, e) {
                if (e || (e = i.Color.createColor()), "string" == typeof t) return 0 === t.indexOf("rgb") ? i.Color.webToColor(t, e) : (e.a = 1, i.Color.hexToColor(t, e));
                if ("number" == typeof t) {
                    var n = i.Color.getRGB(t);
                    return e.r = n.r, e.g = n.g, e.b = n.b, e.a = n.a / 255, e
                }
                return e
            },
            componentToHex: function(t) {
                var e = t.toString(16);
                return 1 === e.length ? "0" + e : e
            },
            HSVColorWheel: function(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = 1);
                for (var n = [], s = 0; s <= 359; s++) n.push(i.Color.HSVtoRGB(s / 359, t, e));
                return n
            },
            HSLColorWheel: function(t, e) {
                void 0 === t && (t = .5), void 0 === e && (e = .5);
                for (var n = [], s = 0; s <= 359; s++) n.push(i.Color.HSLtoRGB(s / 359, t, e));
                return n
            },
            interpolateColor: function(t, e, n, s, r) {
                void 0 === r && (r = 255);
                var o = i.Color.getRGB(t),
                    a = i.Color.getRGB(e),
                    h = (a.red - o.red) * s / n + o.red,
                    l = (a.green - o.green) * s / n + o.green,
                    c = (a.blue - o.blue) * s / n + o.blue;
                return i.Color.getColor32(r, h, l, c)
            },
            interpolateColorWithRGB: function(t, e, n, s, r, o) {
                var a = i.Color.getRGB(t),
                    h = (e - a.red) * o / r + a.red,
                    l = (n - a.green) * o / r + a.green,
                    c = (s - a.blue) * o / r + a.blue;
                return i.Color.getColor(h, l, c)
            },
            interpolateRGB: function(t, e, n, s, r, o, a, h) {
                var l = (s - t) * h / a + t,
                    c = (r - e) * h / a + e,
                    u = (o - n) * h / a + n;
                return i.Color.getColor(l, c, u)
            },
            getRandomColor: function(t, e, n) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === n && (n = 255), e > 255 || t > e) return i.Color.getColor(255, 255, 255);
                var s = t + Math.round(Math.random() * (e - t)),
                    r = t + Math.round(Math.random() * (e - t)),
                    o = t + Math.round(Math.random() * (e - t));
                return i.Color.getColor32(n, s, r, o)
            },
            getRGB: function(t) {
                return t > 16777215 ? {
                    alpha: t >>> 24,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: t >>> 24,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                } : {
                    alpha: 255,
                    red: t >> 16 & 255,
                    green: t >> 8 & 255,
                    blue: 255 & t,
                    a: 255,
                    r: t >> 16 & 255,
                    g: t >> 8 & 255,
                    b: 255 & t
                }
            },
            getWebRGB: function(t) {
                if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                var e = i.Color.getRGB(t);
                return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")"
            },
            getAlpha: function(t) {
                return t >>> 24
            },
            getAlphaFloat: function(t) {
                return (t >>> 24) / 255
            },
            getRed: function(t) {
                return t >> 16 & 255
            },
            getGreen: function(t) {
                return t >> 8 & 255
            },
            getBlue: function(t) {
                return 255 & t
            },
            blendNormal: function(t) {
                return t
            },
            blendLighten: function(t, e) {
                return e > t ? e : t
            },
            blendDarken: function(t, e) {
                return e > t ? t : e
            },
            blendMultiply: function(t, e) {
                return t * e / 255
            },
            blendAverage: function(t, e) {
                return (t + e) / 2
            },
            blendAdd: function(t, e) {
                return Math.min(255, t + e)
            },
            blendSubtract: function(t, e) {
                return Math.max(0, t + e - 255)
            },
            blendDifference: function(t, e) {
                return Math.abs(t - e)
            },
            blendNegation: function(t, e) {
                return 255 - Math.abs(255 - t - e)
            },
            blendScreen: function(t, e) {
                return 255 - ((255 - t) * (255 - e) >> 8)
            },
            blendExclusion: function(t, e) {
                return t + e - 2 * t * e / 255
            },
            blendOverlay: function(t, e) {
                return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
            },
            blendSoftLight: function(t, e) {
                return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
            },
            blendHardLight: function(t, e) {
                return i.Color.blendOverlay(e, t)
            },
            blendColorDodge: function(t, e) {
                return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
            },
            blendColorBurn: function(t, e) {
                return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
            },
            blendLinearDodge: function(t, e) {
                return i.Color.blendAdd(t, e)
            },
            blendLinearBurn: function(t, e) {
                return i.Color.blendSubtract(t, e)
            },
            blendLinearLight: function(t, e) {
                return e < 128 ? i.Color.blendLinearBurn(t, 2 * e) : i.Color.blendLinearDodge(t, 2 * (e - 128))
            },
            blendVividLight: function(t, e) {
                return e < 128 ? i.Color.blendColorBurn(t, 2 * e) : i.Color.blendColorDodge(t, 2 * (e - 128))
            },
            blendPinLight: function(t, e) {
                return e < 128 ? i.Color.blendDarken(t, 2 * e) : i.Color.blendLighten(t, 2 * (e - 128))
            },
            blendHardMix: function(t, e) {
                return i.Color.blendVividLight(t, e) < 128 ? 0 : 255
            },
            blendReflect: function(t, e) {
                return 255 === e ? e : Math.min(255, t * t / (255 - e))
            },
            blendGlow: function(t, e) {
                return i.Color.blendReflect(e, t)
            },
            blendPhoenix: function(t, e) {
                return Math.min(t, e) - Math.max(t, e) + 255
            }
        }, i.Physics = function(t, e) {
            e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
        }, i.Physics.ARCADE = 0, i.Physics.P2JS = 1, i.Physics.NINJA = 2, i.Physics.BOX2D = 3, i.Physics.CHIPMUNK = 4, i.Physics.MATTERJS = 5, i.Physics.prototype = {
            parseConfig: function() {
                this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !i.Physics.hasOwnProperty("Arcade") || (this.arcade = new i.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && i.Physics.hasOwnProperty("Ninja") && (this.ninja = new i.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && i.Physics.hasOwnProperty("P2") && (this.p2 = new i.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && i.Physics.hasOwnProperty("BOX2D") && (this.box2d = new i.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && i.Physics.hasOwnProperty("Matter") && (this.matter = new i.Physics.Matter(this.game, this.config))
            },
            startSystem: function(t) {
                t === i.Physics.ARCADE ? this.arcade = new i.Physics.Arcade(this.game) : t === i.Physics.P2JS ? null === this.p2 ? this.p2 = new i.Physics.P2(this.game, this.config) : this.p2.reset() : t === i.Physics.NINJA ? this.ninja = new i.Physics.Ninja(this.game) : t === i.Physics.BOX2D ? null === this.box2d ? this.box2d = new i.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === i.Physics.MATTERJS && (null === this.matter ? this.matter = new i.Physics.Matter(this.game, this.config) : this.matter.reset())
            },
            enable: function(t, e, n) {
                void 0 === e && (e = i.Physics.ARCADE), void 0 === n && (n = !1), e === i.Physics.ARCADE ? this.arcade.enable(t) : e === i.Physics.P2JS && this.p2 ? this.p2.enable(t, n) : e === i.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === i.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === i.Physics.MATTERJS && this.matter && this.matter.enable(t)
            },
            preUpdate: function() {
                this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
            },
            update: function() {
                this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
            },
            setBoundsToWorld: function() {
                this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
            },
            clear: function() {
                this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
            },
            reset: function() {
                this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
            },
            destroy: function() {
                this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
            }
        }, i.Physics.prototype.constructor = i.Physics, i.Physics.Arcade = function(t) {
            this.game = t, this.gravity = new i.Point, this.bounds = new i.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = {
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = i.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new i.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
        }, i.Physics.Arcade.prototype.constructor = i.Physics.Arcade, i.Physics.Arcade.SORT_NONE = 0, i.Physics.Arcade.LEFT_RIGHT = 1, i.Physics.Arcade.RIGHT_LEFT = 2, i.Physics.Arcade.TOP_BOTTOM = 3, i.Physics.Arcade.BOTTOM_TOP = 4, i.Physics.Arcade.prototype = {
            setBounds: function(t, e, i, n) {
                this.bounds.setTo(t, e, i, n)
            },
            setBoundsToWorld: function() {
                this.bounds.copyFrom(this.game.world.bounds)
            },
            enable: function(t, e) {
                void 0 === e && (e = !0);
                var n = 1;
                if (Array.isArray(t))
                    for (n = t.length; n--;) t[n] instanceof i.Group ? this.enable(t[n].children, e) : (this.enableBody(t[n]), e && t[n].hasOwnProperty("children") && t[n].children.length > 0 && this.enable(t[n], !0));
                else t instanceof i.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, !0))
            },
            enableBody: function(t) {
                t.hasOwnProperty("body") && null === t.body && (t.body = new i.Physics.Arcade.Body(t), t.parent && t.parent instanceof i.Group && t.parent.addToHash(t))
            },
            updateMotion: function(t) {
                var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
            },
            computeVelocity: function(t, e, i, n, s, r) {
                return void 0 === r && (r = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), n ? i += n * this.game.time.physicsElapsed : s && (i - (s *= this.game.time.physicsElapsed) > 0 ? i -= s : i + s < 0 ? i += s : i = 0), i > r ? i = r : i < -r && (i = -r), i
            },
            overlap: function(t, e, i, n, s) {
                if (i = i || null, n = n || null, s = s || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                    for (var r = 0; r < e.length; r++) this.collideHandler(t, e[r], i, n, s, !0);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (r = 0; r < t.length; r++) this.collideHandler(t[r], e, i, n, s, !0);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (r = 0; r < t.length; r++)
                        for (var o = 0; o < e.length; o++) this.collideHandler(t[r], e[o], i, n, s, !0);
                else this.collideHandler(t, e, i, n, s, !0);
                return this._total > 0
            },
            collide: function(t, e, i, n, s) {
                if (i = i || null, n = n || null, s = s || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                    for (var r = 0; r < e.length; r++) this.collideHandler(t, e[r], i, n, s, !1);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (r = 0; r < t.length; r++) this.collideHandler(t[r], e, i, n, s, !1);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (r = 0; r < t.length; r++)
                        for (var o = 0; o < e.length; o++) this.collideHandler(t[r], e[o], i, n, s, !1);
                else this.collideHandler(t, e, i, n, s, !1);
                return this._total > 0
            },
            sortLeftRight: function(t, e) {
                return t.body && e.body ? t.body.x - e.body.x : 0
            },
            sortRightLeft: function(t, e) {
                return t.body && e.body ? e.body.x - t.body.x : 0
            },
            sortTopBottom: function(t, e) {
                return t.body && e.body ? t.body.y - e.body.y : 0
            },
            sortBottomTop: function(t, e) {
                return t.body && e.body ? e.body.y - t.body.y : 0
            },
            sort: function(t, e) {
                null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection), e === i.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === i.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === i.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === i.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop)
            },
            collideHandler: function(t, e, n, s, r, o) {
                if (void 0 === e && t.physicsType === i.GROUP) return this.sort(t), void this.collideGroupVsSelf(t, n, s, r, o);
                t && e && t.exists && e.exists && (this.sortDirection !== i.Physics.Arcade.SORT_NONE && (t.physicsType === i.GROUP && this.sort(t), e.physicsType === i.GROUP && this.sort(e)), t.physicsType === i.SPRITE ? e.physicsType === i.SPRITE ? this.collideSpriteVsSprite(t, e, n, s, r, o) : e.physicsType === i.GROUP ? this.collideSpriteVsGroup(t, e, n, s, r, o) : e.physicsType === i.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, n, s, r, o) : t.physicsType === i.GROUP ? e.physicsType === i.SPRITE ? this.collideSpriteVsGroup(e, t, n, s, r, o) : e.physicsType === i.GROUP ? this.collideGroupVsGroup(t, e, n, s, r, o) : e.physicsType === i.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, n, s, r, o) : t.physicsType === i.TILEMAPLAYER && (e.physicsType === i.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, n, s, r, o) : e.physicsType === i.GROUP && this.collideGroupVsTilemapLayer(e, t, n, s, r, o)))
            },
            collideSpriteVsSprite: function(t, e, i, n, s, r) {
                return !(!t.body || !e.body) && (this.separate(t.body, e.body, n, s, r) && (i && i.call(s, t, e), this._total++), !0)
            },
            collideSpriteVsGroup: function(t, e, n, s, r, o) {
                if (0 !== e.length && t.body)
                    if (this.skipQuadTree || t.body.skipQuadTree)
                        for (var a = {}, h = 0; h < e.hash.length; h++) {
                            var l = e.hash[h];
                            if (l && l.exists && l.body) {
                                if (a = l.body.getBounds(a), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) {
                                    if (t.body.right < a.x) break;
                                    if (a.right < t.body.x) continue
                                } else if (this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) {
                                    if (t.body.x > a.right) break;
                                    if (a.x > t.body.right) continue
                                } else if (this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) {
                                    if (t.body.bottom < a.y) break;
                                    if (a.bottom < t.body.y) continue
                                } else if (this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) {
                                    if (t.body.y > a.bottom) break;
                                    if (a.y > t.body.bottom) continue
                                }
                                this.collideSpriteVsSprite(t, l, n, s, r, o)
                            }
                        } else {
                            this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e);
                            var c = this.quadTree.retrieve(t);
                            for (h = 0; h < c.length; h++) this.separate(t.body, c[h], s, r, o) && (n && n.call(r, t, c[h].sprite), this._total++)
                        }
            },
            collideGroupVsSelf: function(t, e, n, s, r) {
                if (0 !== t.length)
                    for (var o = 0; o < t.hash.length; o++) {
                        var a = {},
                            h = t.hash[o];
                        if (h && h.exists && h.body) {
                            a = h.body.getBounds(a);
                            for (var l = o + 1; l < t.hash.length; l++) {
                                var c = {},
                                    u = t.hash[l];
                                if (u && u.exists && u.body) {
                                    if (c = u.body.getBounds(c), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) {
                                        if (a.right < c.x) break;
                                        if (c.right < a.x) continue
                                    } else if (this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) {
                                        if (a.x > c.right) continue;
                                        if (c.x > a.right) break
                                    } else if (this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) {
                                        if (a.bottom < c.y) continue;
                                        if (c.bottom < a.y) break
                                    } else if (this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) {
                                        if (a.y > c.bottom) continue;
                                        if (c.y > h.body.bottom) break
                                    }
                                    this.collideSpriteVsSprite(h, u, e, n, s, r)
                                }
                            }
                        }
                    }
            },
            collideGroupVsGroup: function(t, e, n, s, r, o) {
                if (0 !== t.length && 0 !== e.length)
                    for (var a = 0; a < t.children.length; a++) t.children[a].exists && (t.children[a].physicsType === i.GROUP ? this.collideGroupVsGroup(t.children[a], e, n, s, r, o) : this.collideSpriteVsGroup(t.children[a], e, n, s, r, o))
            },
            separate: function(t, e, i, n, s) {
                if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1;
                if (i && !1 === i.call(n, t.sprite, e.sprite)) return !1;
                if (t.isCircle && e.isCircle) return this.separateCircle(t, e, s);
                if (t.isCircle !== e.isCircle) {
                    var r = t.isCircle ? e : t,
                        o = t.isCircle ? t : e,
                        a = {
                            x: r.x,
                            y: r.y,
                            right: r.right,
                            bottom: r.bottom
                        },
                        h = {
                            x: o.x + o.radius,
                            y: o.y + o.radius
                        };
                    if ((h.y < a.y || h.y > a.bottom) && (h.x < a.x || h.x > a.right)) return this.separateCircle(t, e, s)
                }
                var l = !1,
                    c = !1;
                this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = this.separateX(t, e, s), this.intersects(t, e) && (c = this.separateY(t, e, s))) : (c = this.separateY(t, e, s), this.intersects(t, e) && (l = this.separateX(t, e, s)));
                var u = l || c;
                return u && (s ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), u
            },
            intersects: function(t, e) {
                return t !== e && (t.isCircle ? e.isCircle ? i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x) && (!(t.bottom <= e.position.y) && (!(t.position.x >= e.right) && !(t.position.y >= e.bottom))))
            },
            circleBodyIntersects: function(t, e) {
                var n = i.Math.clamp(t.center.x, e.left, e.right),
                    s = i.Math.clamp(t.center.y, e.top, e.bottom);
                return (t.center.x - n) * (t.center.x - n) + (t.center.y - s) * (t.center.y - s) <= t.radius * t.radius
            },
            separateCircle: function(t, e, n) {
                this.getOverlapX(t, e), this.getOverlapY(t, e);
                var s = e.center.x - t.center.x,
                    r = e.center.y - t.center.y,
                    o = Math.atan2(r, s),
                    a = 0;
                if (t.isCircle !== e.isCircle) {
                    var h = {
                            x: e.isCircle ? t.position.x : e.position.x,
                            y: e.isCircle ? t.position.y : e.position.y,
                            right: e.isCircle ? t.right : e.right,
                            bottom: e.isCircle ? t.bottom : e.bottom
                        },
                        l = {
                            x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius,
                            y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius,
                            radius: t.isCircle ? t.radius : e.radius
                        };
                    l.y < h.y ? l.x < h.x ? a = i.Math.distance(l.x, l.y, h.x, h.y) - l.radius : l.x > h.right && (a = i.Math.distance(l.x, l.y, h.right, h.y) - l.radius) : l.y > h.bottom && (l.x < h.x ? a = i.Math.distance(l.x, l.y, h.x, h.bottom) - l.radius : l.x > h.right && (a = i.Math.distance(l.x, l.y, h.right, h.bottom) - l.radius)), a *= -1
                } else a = t.radius + e.radius - i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y);
                if (n || 0 === a || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== a && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)), 0 !== a;
                var c = t.velocity.x * Math.cos(o) + t.velocity.y * Math.sin(o),
                    u = t.velocity.x * Math.sin(o) - t.velocity.y * Math.cos(o),
                    d = e.velocity.x * Math.cos(o) + e.velocity.y * Math.sin(o),
                    p = e.velocity.x * Math.sin(o) - e.velocity.y * Math.cos(o),
                    f = ((t.mass - e.mass) * c + 2 * e.mass * d) / (t.mass + e.mass),
                    g = (2 * t.mass * c + (e.mass - t.mass) * d) / (t.mass + e.mass);
                return t.immovable || (t.velocity.x = (f * Math.cos(o) - u * Math.sin(o)) * t.bounce.x, t.velocity.y = (u * Math.cos(o) + f * Math.sin(o)) * t.bounce.y), e.immovable || (e.velocity.x = (g * Math.cos(o) - p * Math.sin(o)) * e.bounce.x, e.velocity.y = (p * Math.cos(o) + g * Math.sin(o)) * e.bounce.y), Math.abs(o) < Math.PI / 2 ? t.velocity.x > 0 && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : t.velocity.y > 0 && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(o) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : e.velocity.x > 0 && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : e.velocity.y > 0 && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - a * Math.cos(o), t.y += t.velocity.y * this.game.time.physicsElapsed - a * Math.sin(o)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + a * Math.cos(o), e.y += e.velocity.y * this.game.time.physicsElapsed + a * Math.sin(o)), t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite), !0
            },
            getOverlapX: function(t, e, i) {
                var n = 0,
                    s = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
                return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (n = t.right - e.x) > s && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? n = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0) : t.deltaX() < e.deltaX() && (-(n = t.x - e.width - e.x) > s && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? n = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = n, e.overlapX = n, n
            },
            getOverlapY: function(t, e, i) {
                var n = 0,
                    s = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
                return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (n = t.bottom - e.y) > s && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? n = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0) : t.deltaY() < e.deltaY() && (-(n = t.y - e.bottom) > s && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? n = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = n, e.overlapY = n, n
            },
            separateX: function(t, e, i) {
                var n = this.getOverlapX(t, e, i);
                if (i || 0 === n || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== n || t.embedded && e.embedded;
                var s = t.velocity.x,
                    r = e.velocity.x;
                if (t.immovable || e.immovable) t.immovable ? (e.x += n, e.velocity.x = s - r * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= n, t.velocity.x = r - s * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y));
                else {
                    n *= .5, t.x -= n, e.x += n;
                    var o = Math.sqrt(r * r * e.mass / t.mass) * (r > 0 ? 1 : -1),
                        a = Math.sqrt(s * s * t.mass / e.mass) * (s > 0 ? 1 : -1),
                        h = .5 * (o + a);
                    o -= h, a -= h, t.velocity.x = h + o * t.bounce.x, e.velocity.x = h + a * e.bounce.x
                }
                return !0
            },
            separateY: function(t, e, i) {
                var n = this.getOverlapY(t, e, i);
                if (i || 0 === n || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== n || t.embedded && e.embedded;
                var s = t.velocity.y,
                    r = e.velocity.y;
                if (t.immovable || e.immovable) t.immovable ? (e.y += n, e.velocity.y = s - r * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= n, t.velocity.y = r - s * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x));
                else {
                    n *= .5, t.y -= n, e.y += n;
                    var o = Math.sqrt(r * r * e.mass / t.mass) * (r > 0 ? 1 : -1),
                        a = Math.sqrt(s * s * t.mass / e.mass) * (s > 0 ? 1 : -1),
                        h = .5 * (o + a);
                    o -= h, a -= h, t.velocity.y = h + o * t.bounce.y, e.velocity.y = h + a * e.bounce.y
                }
                return !0
            },
            getObjectsUnderPointer: function(t, e, i, n) {
                if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, n, t)
            },
            getObjectsAtLocation: function(t, e, n, s, r, o) {
                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(n);
                for (var a = new i.Rectangle(t, e, 1, 1), h = [], l = this.quadTree.retrieve(a), c = 0; c < l.length; c++) l[c].hitTest(t, e) && (s && s.call(r, o, l[c].sprite), h.push(l[c].sprite));
                return h
            },
            moveToObject: function(t, e, i, n) {
                void 0 === i && (i = 60), void 0 === n && (n = 0);
                var s = Math.atan2(e.y - t.y, e.x - t.x);
                return n > 0 && (i = this.distanceBetween(t, e) / (n / 1e3)), t.body.velocity.x = Math.cos(s) * i, t.body.velocity.y = Math.sin(s) * i, s
            },
            moveToPointer: function(t, e, i, n) {
                void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === n && (n = 0);
                var s = this.angleToPointer(t, i);
                return n > 0 && (e = this.distanceToPointer(t, i) / (n / 1e3)), t.body.velocity.x = Math.cos(s) * e, t.body.velocity.y = Math.sin(s) * e, s
            },
            moveToXY: function(t, e, i, n, s) {
                void 0 === n && (n = 60), void 0 === s && (s = 0);
                var r = Math.atan2(i - t.y, e - t.x);
                return s > 0 && (n = this.distanceToXY(t, e, i) / (s / 1e3)), t.body.velocity.x = Math.cos(r) * n, t.body.velocity.y = Math.sin(r) * n, r
            },
            velocityFromAngle: function(t, e, n) {
                return void 0 === e && (e = 60), (n = n || new i.Point).setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e)
            },
            velocityFromRotation: function(t, e, n) {
                return void 0 === e && (e = 60), (n = n || new i.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
            },
            accelerationFromRotation: function(t, e, n) {
                return void 0 === e && (e = 60), (n = n || new i.Point).setTo(Math.cos(t) * e, Math.sin(t) * e)
            },
            accelerateToObject: function(t, e, i, n, s) {
                void 0 === i && (i = 60), void 0 === n && (n = 1e3), void 0 === s && (s = 1e3);
                var r = this.angleBetween(t, e);
                return t.body.acceleration.setTo(Math.cos(r) * i, Math.sin(r) * i), t.body.maxVelocity.setTo(n, s), r
            },
            accelerateToPointer: function(t, e, i, n, s) {
                void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === n && (n = 1e3), void 0 === s && (s = 1e3);
                var r = this.angleToPointer(t, e);
                return t.body.acceleration.setTo(Math.cos(r) * i, Math.sin(r) * i), t.body.maxVelocity.setTo(n, s), r
            },
            accelerateToXY: function(t, e, i, n, s, r) {
                void 0 === n && (n = 60), void 0 === s && (s = 1e3), void 0 === r && (r = 1e3);
                var o = this.angleToXY(t, e, i);
                return t.body.acceleration.setTo(Math.cos(o) * n, Math.sin(o) * n), t.body.maxVelocity.setTo(s, r), o
            },
            distanceBetween: function(t, e, i) {
                void 0 === i && (i = !1);
                var n = i ? t.world.x - e.world.x : t.x - e.x,
                    s = i ? t.world.y - e.world.y : t.y - e.y;
                return Math.sqrt(n * n + s * s)
            },
            distanceToXY: function(t, e, i, n) {
                void 0 === n && (n = !1);
                var s = n ? t.world.x - e : t.x - e,
                    r = n ? t.world.y - i : t.y - i;
                return Math.sqrt(s * s + r * r)
            },
            distanceToPointer: function(t, e, i) {
                void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1);
                var n = i ? t.world.x - e.worldX : t.x - e.worldX,
                    s = i ? t.world.y - e.worldY : t.y - e.worldY;
                return Math.sqrt(n * n + s * s)
            },
            angleBetween: function(t, e, i) {
                return void 0 === i && (i = !1), i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x)
            },
            angleBetweenCenters: function(t, e) {
                var i = e.centerX - t.centerX,
                    n = e.centerY - t.centerY;
                return Math.atan2(n, i)
            },
            angleToXY: function(t, e, i, n) {
                return void 0 === n && (n = !1), n ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
            },
            angleToPointer: function(t, e, i) {
                return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
            },
            worldAngleToPointer: function(t, e) {
                return this.angleToPointer(t, e, !0)
            }
        }, i.Physics.Arcade.Body = function(t) {
            this.sprite = t, this.game = t.game, this.type = i.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new i.Point, this.position = new i.Point(t.x, t.y), this.prev = new i.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.angle, this.preRotation = t.angle, this.width = t.width, this.height = t.height, this.sourceWidth = t.width, this.sourceHeight = t.height, t.texture && (this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height), this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new i.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new i.Point, this.newVelocity = new i.Point, this.deltaMax = new i.Point, this.acceleration = new i.Point, this.drag = new i.Point, this.allowGravity = !0, this.gravity = new i.Point, this.bounce = new i.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new i.Point(1e4, 1e4), this.friction = new i.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = i.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                none: !1,
                any: !0,
                up: !0,
                down: !0,
                left: !0,
                right: !0
            }, this.touching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.wasTouching = {
                none: !0,
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.blocked = {
                up: !1,
                down: !1,
                left: !1,
                right: !1
            }, this.tilePadding = new i.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new i.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0
        }, i.Physics.Arcade.Body.prototype = {
            updateBounds: function() {
                if (this.syncBounds) {
                    var t = this.sprite.getBounds();
                    t.ceilAll(), t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0)
                } else {
                    var e = Math.abs(this.sprite.scale.x),
                        i = Math.abs(this.sprite.scale.y);
                    e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0)
                }
                this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
            },
            preUpdate: function() {
                this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
            },
            updateMovement: function() {
                var t = 0,
                    e = 0 !== this.overlapX || 0 !== this.overlapY;
                if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, t = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), t = this.moveTarget.length / this.moveDistance), this.movementCallback) var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
                return !(e || t >= 1 || void 0 !== i && !0 !== i) || (this.stopMovement(t >= 1 || this.stopVelocityOnCollide && e), !1)
            },
            stopMovement: function(t) {
                this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
            },
            postUpdate: function() {
                this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = i.LEFT : this.deltaX() > 0 && (this.facing = i.RIGHT), this.deltaY() < 0 ? this.facing = i.UP : this.deltaY() > 0 && (this.facing = i.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
            },
            checkWorldBounds: function() {
                var t = this.position,
                    e = this.game.physics.arcade.bounds,
                    i = this.game.physics.arcade.checkCollision,
                    n = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                    s = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                if (this.isCircle) {
                    var r = {
                        x: this.center.x - this.radius,
                        y: this.center.y - this.radius,
                        right: this.center.x + this.radius,
                        bottom: this.center.y + this.radius
                    };
                    r.x < e.x && i.left ? (t.x = e.x - this.halfWidth + this.radius, this.velocity.x *= n, this.blocked.left = !0) : r.right > e.right && i.right && (t.x = e.right - this.halfWidth - this.radius, this.velocity.x *= n, this.blocked.right = !0), r.y < e.y && i.up ? (t.y = e.y - this.halfHeight + this.radius, this.velocity.y *= s, this.blocked.up = !0) : r.bottom > e.bottom && i.down && (t.y = e.bottom - this.halfHeight - this.radius, this.velocity.y *= s, this.blocked.down = !0)
                } else t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= n, this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= n, this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= s, this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= s, this.blocked.down = !0);
                return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
            },
            moveFrom: function(t, e, i) {
                return void 0 === e && (e = this.speed), 0 !== e && (void 0 === i ? (n = this.angle, i = this.game.math.radToDeg(n)) : n = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(n) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(n) * e) : this.velocity.set(Math.cos(n) * e, Math.sin(n) * e), this.isMoving = !0, !0);
                var n
            },
            moveTo: function(t, e, n) {
                var s, r = e / (t / 1e3);
                return 0 !== r && (void 0 === n ? (s = this.angle, n = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(n), e = Math.abs(e), this.moveDuration = 0, this.moveDistance = e, null === this.moveTarget && (this.moveTarget = new i.Line, this.moveEnd = new i.Point), this.moveTarget.fromAngle(this.x, this.y, s, e), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === n || 180 === n ? this.velocity.set(Math.cos(s) * r, 0) : 90 === n || 270 === n ? this.velocity.set(0, Math.sin(s) * r) : this.velocity.set(Math.cos(s) * r, Math.sin(s) * r), this.isMoving = !0, !0)
            },
            setSize: function(t, e, i, n) {
                void 0 === i && (i = this.offset.x), void 0 === n && (n = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, n), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0
            },
            setCircle: function(t, e, i) {
                void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
            },
            reset: function(t, e) {
                this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
            },
            getBounds: function(t) {
                return this.isCircle ? (t.x = this.center.x - this.radius, t.y = this.center.y - this.radius, t.right = this.center.x + this.radius, t.bottom = this.center.y + this.radius) : (t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom), t
            },
            hitTest: function(t, e) {
                return this.isCircle ? i.Circle.contains(this, t, e) : i.Rectangle.contains(this, t, e)
            },
            onFloor: function() {
                return this.blocked.down
            },
            onCeiling: function() {
                return this.blocked.up
            },
            onWall: function() {
                return this.blocked.left || this.blocked.right
            },
            deltaAbsX: function() {
                return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
            },
            deltaAbsY: function() {
                return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
            },
            deltaX: function() {
                return this.position.x - this.prev.x
            },
            deltaY: function() {
                return this.position.y - this.prev.y
            },
            deltaZ: function() {
                return this.rotation - this.preRotation
            },
            destroy: function() {
                this.sprite.parent && this.sprite.parent instanceof i.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
            }
        }, Object.defineProperty(i.Physics.Arcade.Body.prototype, "left", {
            get: function() {
                return this.position.x
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "right", {
            get: function() {
                return this.position.x + this.width
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "top", {
            get: function() {
                return this.position.y
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "bottom", {
            get: function() {
                return this.position.y + this.height
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "x", {
            get: function() {
                return this.position.x
            },
            set: function(t) {
                this.position.x = t
            }
        }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "y", {
            get: function() {
                return this.position.y
            },
            set: function(t) {
                this.position.y = t
            }
        }), i.Physics.Arcade.Body.render = function(t, e, i, n) {
            void 0 === n && (n = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI), n ? t.fill() : t.stroke()) : n ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
        }, i.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
            t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
        }, i.Physics.Arcade.Body.prototype.constructor = i.Physics.Arcade.Body, i.Physics.Arcade.TilemapCollision = function() {}, i.Physics.Arcade.TilemapCollision.prototype = {
            TILE_BIAS: 16,
            collideSpriteVsTilemapLayer: function(t, e, i, n, s, r) {
                if (t.body) {
                    var o = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                    if (0 !== o.length)
                        for (var a = 0; a < o.length; a++) n ? n.call(s, t, o[a]) && this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(s, t, o[a])) : this.separateTile(a, t.body, o[a], e, r) && (this._total++, i && i.call(s, t, o[a]))
                }
            },
            collideGroupVsTilemapLayer: function(t, e, i, n, s, r) {
                if (0 !== t.length)
                    for (var o = 0; o < t.children.length; o++) t.children[o].exists && this.collideSpriteVsTilemapLayer(t.children[o], e, i, n, s, r)
            },
            separateTile: function(t, e, i, n, s) {
                if (!e.enable) return !1;
                var r = n.fixedToCamera ? 0 : n.position.x,
                    o = n.fixedToCamera ? 0 : n.position.y;
                if (!i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return !1;
                if (s) return !0;
                if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1;
                if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1;
                if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1;
                var a = 0,
                    h = 0,
                    l = 0,
                    c = 1;
                if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (c = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - r - i.right), Math.abs(e.right - r - i.left)), c = Math.min(Math.abs(e.position.y - o - i.bottom), Math.abs(e.bottom - o - i.top))), l < c) {
                    if ((i.faceLeft || i.faceRight) && 0 !== (a = this.tileCheckX(e, i, n)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return !0;
                    (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, n))
                } else {
                    if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, n)) && !i.intersects(e.position.x - r, e.position.y - o, e.right - r, e.bottom - o)) return !0;
                    (i.faceLeft || i.faceRight) && (a = this.tileCheckX(e, i, n))
                }
                return 0 !== a || 0 !== h
            },
            tileCheckX: function(t, e, i) {
                var n = 0,
                    s = i.fixedToCamera ? 0 : i.position.x;
                return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - s < e.right && (n = t.x - s - e.right) < -this.TILE_BIAS && (n = 0) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - s > e.left && (n = t.right - s - e.left) > this.TILE_BIAS && (n = 0), 0 !== n && (t.customSeparateX ? t.overlapX = n : this.processTileSeparationX(t, n)), n
            },
            tileCheckY: function(t, e, i) {
                var n = 0,
                    s = i.fixedToCamera ? 0 : i.position.y;
                return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - s < e.bottom && (n = t.y - s - e.bottom) < -this.TILE_BIAS && (n = 0) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - s > e.top && (n = t.bottom - s - e.top) > this.TILE_BIAS && (n = 0), 0 !== n && (t.customSeparateY ? t.overlapY = n : this.processTileSeparationY(t, n)), n
            },
            processTileSeparationX: function(t, e) {
                e < 0 ? t.blocked.left = !0 : e > 0 && (t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
            },
            processTileSeparationY: function(t, e) {
                e < 0 ? t.blocked.up = !0 : e > 0 && (t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
            }
        }, i.Utils.mixinPrototype(i.Physics.Arcade.prototype, i.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, i.Physics.P2 = function(t, e) {
            this.game = t, void 0 === e ? e = {
                gravity: [0, 0],
                broadphase: new p2.SAPBroadphase
            } : (e.hasOwnProperty("gravity") || (e.gravity = [0, 0]), e.hasOwnProperty("broadphase") || (e.broadphase = new p2.SAPBroadphase)), this.config = e, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new i.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = {
                left: null,
                right: null,
                top: null,
                bottom: null
            }, this.onBodyAdded = new i.Signal, this.onBodyRemoved = new i.Signal, this.onSpringAdded = new i.Signal, this.onSpringRemoved = new i.Signal, this.onConstraintAdded = new i.Signal, this.onConstraintRemoved = new i.Signal, this.onContactMaterialAdded = new i.Signal, this.onContactMaterialRemoved = new i.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new i.Signal, this.onEndContact = new i.Signal, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && e.hasOwnProperty("mpxi") && e.hasOwnProperty("pxmi") && (this.mpx = e.mpx, this.mpxi = e.mpxi, this.pxm = e.pxm, this.pxmi = e.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new i.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new i.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new i.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1)
        }, i.Physics.P2.prototype = {
            removeBodyNextStep: function(t) {
                this._toRemove.push(t)
            },
            preUpdate: function() {
                for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
                this._toRemove.length = 0
            },
            enable: function(t, e, n) {
                void 0 === e && (e = !1), void 0 === n && (n = !0);
                var s = 1;
                if (Array.isArray(t))
                    for (s = t.length; s--;) t[s] instanceof i.Group ? this.enable(t[s].children, e, n) : (this.enableBody(t[s], e), n && t[s].hasOwnProperty("children") && t[s].children.length > 0 && this.enable(t[s], e, !0));
                else t instanceof i.Group ? this.enable(t.children, e, n) : (this.enableBody(t, e), n && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, e, !0))
            },
            enableBody: function(t, e) {
                t.hasOwnProperty("body") && null === t.body && (t.body = new i.Physics.P2.Body(this.game, t, t.x, t.y, 1), t.body.debug = e, void 0 !== t.anchor && t.anchor.set(.5))
            },
            setImpactEvents: function(t) {
                t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
            },
            setPostBroadphaseCallback: function(t, e) {
                this.postBroadphaseCallback = t, this.callbackContext = e, null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
            },
            postBroadphaseHandler: function(t) {
                if (this.postBroadphaseCallback && 0 !== t.pairs.length)
                    for (var e = t.pairs.length - 2; e >= 0; e -= 2) t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2)
            },
            impactHandler: function(t) {
                if (t.bodyA.parent && t.bodyB.parent) {
                    var e = t.bodyA.parent,
                        i = t.bodyB.parent;
                    e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB), i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA), e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB), i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA)
                }
            },
            beginContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA, t.contactEquations))
            },
            endContactHandler: function(t) {
                t.bodyA && t.bodyB && (this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB), t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB), t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA))
            },
            setBoundsToWorld: function(t, e, i, n, s) {
                this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, n, s)
            },
            setWorldMaterial: function(t, e, i, n, s) {
                void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = !0), void 0 === s && (s = !0), e && this.walls.left && (this.walls.left.shapes[0].material = t), i && this.walls.right && (this.walls.right.shapes[0].material = t), n && this.walls.top && (this.walls.top.shapes[0].material = t), s && this.walls.bottom && (this.walls.bottom.shapes[0].material = t)
            },
            updateBoundsCollisionGroup: function(t) {
                void 0 === t && (t = !0);
                var e = t ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
                this.walls.left && (this.walls.left.shapes[0].collisionGroup = e), this.walls.right && (this.walls.right.shapes[0].collisionGroup = e), this.walls.top && (this.walls.top.shapes[0].collisionGroup = e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e), this._boundsOwnGroup = t
            },
            setBounds: function(t, e, i, n, s, r, o, a, h) {
                void 0 === s && (s = this._boundsLeft), void 0 === r && (r = this._boundsRight), void 0 === o && (o = this._boundsTop), void 0 === a && (a = this._boundsBottom), void 0 === h && (h = this._boundsOwnGroup), this.setupWall(s, "left", t, e, 1.5707963267948966, h), this.setupWall(r, "right", t + i, e, -1.5707963267948966, h), this.setupWall(o, "top", t, e, -3.141592653589793, h), this.setupWall(a, "bottom", t, e + n, 0, h), this._boundsLeft = s, this._boundsRight = r, this._boundsTop = o, this._boundsBottom = a, this._boundsOwnGroup = h
            },
            setupWall: function(t, e, i, n, s, r) {
                t ? (this.walls[e] ? this.walls[e].position = [this.pxmi(i), this.pxmi(n)] : (this.walls[e] = new p2.Body({
                    mass: 0,
                    position: [this.pxmi(i), this.pxmi(n)],
                    angle: s
                }), this.walls[e].addShape(new p2.Plane), this.world.addBody(this.walls[e])), r && (this.walls[e].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[e] && (this.world.removeBody(this.walls[e]), this.walls[e] = null)
            },
            pause: function() {
                this.paused = !0
            },
            resume: function() {
                this.paused = !1
            },
            update: function() {
                this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
            },
            reset: function() {
                this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new i.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new i.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new i.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1)
            },
            clear: function() {
                this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
                for (var t = this.world.constraints, e = t.length - 1; e >= 0; e--) this.world.removeConstraint(t[e]);
                var i = this.world.bodies;
                for (e = i.length - 1; e >= 0; e--) this.world.removeBody(i[e]);
                var n = this.world.springs;
                for (e = n.length - 1; e >= 0; e--) this.world.removeSpring(n[e]);
                var s = this.world.contactMaterials;
                for (e = s.length - 1; e >= 0; e--) this.world.removeContactMaterial(s[e]);
                this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = {
                    left: null,
                    right: null,
                    top: null,
                    bottom: null
                }
            },
            destroy: function() {
                this.clear(), this.game = null
            },
            addBody: function(t) {
                return !t.data.world && (this.world.addBody(t.data), this.onBodyAdded.dispatch(t), !0)
            },
            removeBody: function(t) {
                return t.data.world === this.world && (this.world.removeBody(t.data), this.onBodyRemoved.dispatch(t)), t
            },
            addSpring: function(t) {
                return t instanceof i.Physics.P2.Spring || t instanceof i.Physics.P2.RotationalSpring ? this.world.addSpring(t.data) : this.world.addSpring(t), this.onSpringAdded.dispatch(t), t
            },
            removeSpring: function(t) {
                return t instanceof i.Physics.P2.Spring || t instanceof i.Physics.P2.RotationalSpring ? this.world.removeSpring(t.data) : this.world.removeSpring(t), this.onSpringRemoved.dispatch(t), t
            },
            createDistanceConstraint: function(t, e, n, s, r, o) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new i.Physics.P2.DistanceConstraint(this, t, e, n, s, r, o))
            },
            createGearConstraint: function(t, e, n, s) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new i.Physics.P2.GearConstraint(this, t, e, n, s))
            },
            createRevoluteConstraint: function(t, e, n, s, r, o) {
                if (t = this.getBody(t), n = this.getBody(n), t && n) return this.addConstraint(new i.Physics.P2.RevoluteConstraint(this, t, e, n, s, r, o))
            },
            createLockConstraint: function(t, e, n, s, r) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new i.Physics.P2.LockConstraint(this, t, e, n, s, r))
            },
            createPrismaticConstraint: function(t, e, n, s, r, o, a) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new i.Physics.P2.PrismaticConstraint(this, t, e, n, s, r, o, a))
            },
            addConstraint: function(t) {
                return this.world.addConstraint(t), this.onConstraintAdded.dispatch(t), t
            },
            removeConstraint: function(t) {
                return this.world.removeConstraint(t), this.onConstraintRemoved.dispatch(t), t
            },
            addContactMaterial: function(t) {
                return this.world.addContactMaterial(t), this.onContactMaterialAdded.dispatch(t), t
            },
            removeContactMaterial: function(t) {
                return this.world.removeContactMaterial(t), this.onContactMaterialRemoved.dispatch(t), t
            },
            getContactMaterial: function(t, e) {
                return this.world.getContactMaterial(t, e)
            },
            setMaterial: function(t, e) {
                for (var i = e.length; i--;) e[i].setMaterial(t)
            },
            createMaterial: function(t, e) {
                t = t || "";
                var n = new i.Physics.P2.Material(t);
                return this.materials.push(n), void 0 !== e && e.setMaterial(n), n
            },
            createContactMaterial: function(t, e, n) {
                void 0 === t && (t = this.createMaterial()), void 0 === e && (e = this.createMaterial());
                var s = new i.Physics.P2.ContactMaterial(t, e, n);
                return this.addContactMaterial(s)
            },
            getBodies: function() {
                for (var t = [], e = this.world.bodies.length; e--;) t.push(this.world.bodies[e].parent);
                return t
            },
            getBody: function(t) {
                return t instanceof p2.Body ? t : t instanceof i.Physics.P2.Body ? t.data : t.body && t.body.type === i.Physics.P2JS ? t.body.data : null
            },
            getSprings: function() {
                for (var t = [], e = this.world.springs.length; e--;) t.push(this.world.springs[e].parent);
                return t
            },
            getConstraints: function() {
                for (var t = [], e = this.world.constraints.length; e--;) t.push(this.world.constraints[e]);
                return t
            },
            hitTest: function(t, e, n, s) {
                void 0 === e && (e = this.world.bodies), void 0 === n && (n = 5), void 0 === s && (s = !1);
                for (var r = [this.pxmi(t.x), this.pxmi(t.y)], o = [], a = e.length; a--;) e[a] instanceof i.Physics.P2.Body && (!s || e[a].data.type !== p2.Body.STATIC) ? o.push(e[a].data) : e[a] instanceof p2.Body && e[a].parent && (!s || e[a].type !== p2.Body.STATIC) ? o.push(e[a]) : e[a] instanceof i.Sprite && e[a].hasOwnProperty("body") && (!s || e[a].body.data.type !== p2.Body.STATIC) && o.push(e[a].body.data);
                return this.world.hitTest(r, o, n)
            },
            toJSON: function() {
                return this.world.toJSON()
            },
            createCollisionGroup: function(t) {
                var e = Math.pow(2, this._collisionGroupID);
                this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | e), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | e), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | e), this._collisionGroupID++;
                var n = new i.Physics.P2.CollisionGroup(e);
                return this.collisionGroups.push(n), t && this.setCollisionGroup(t, n), n
            },
            setCollisionGroup: function(t, e) {
                if (t instanceof i.Group)
                    for (var n = 0; n < t.total; n++) t.children[n].body && t.children[n].body.type === i.Physics.P2JS && t.children[n].body.setCollisionGroup(e);
                else t.body.setCollisionGroup(e)
            },
            createSpring: function(t, e, n, s, r, o, a, h, l) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new i.Physics.P2.Spring(this, t, e, n, s, r, o, a, h, l))
            },
            createRotationalSpring: function(t, e, n, s, r) {
                if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new i.Physics.P2.RotationalSpring(this, t, e, n, s, r))
            },
            createBody: function(t, e, n, s, r, o) {
                void 0 === s && (s = !1);
                var a = new i.Physics.P2.Body(this.game, null, t, e, n);
                if (o && !a.addPolygon(r, o)) return !1;
                return s && this.world.addBody(a.data), a
            },
            createParticle: function(t, e, n, s, r, o) {
                void 0 === s && (s = !1);
                var a = new i.Physics.P2.Body(this.game, null, t, e, n);
                if (o && !a.addPolygon(r, o)) return !1;
                return s && this.world.addBody(a.data), a
            },
            convertCollisionObjects: function(t, e, i) {
                void 0 === i && (i = !0);
                for (var n = [], s = 0, r = t.collision[e].length; s < r; s++) {
                    var o = t.collision[e][s],
                        a = this.createBody(o.x, o.y, 0, i, {}, o.polyline);
                    a && n.push(a)
                }
                return n
            },
            clearTilemapLayerBodies: function(t, e) {
                e = t.getLayer(e);
                for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
                t.layers[e].bodies.length = 0
            },
            convertTilemap: function(t, e, i, n) {
                e = t.getLayer(e), void 0 === i && (i = !0), void 0 === n && (n = !0), this.clearTilemapLayerBodies(t, e);
                for (var s = 0, r = 0, o = 0, a = 0, h = t.layers[e].height; a < h; a++) {
                    s = 0;
                    for (var l = 0, c = t.layers[e].width; l < c; l++) {
                        var u = t.layers[e].data[a][l];
                        if (u && u.index > -1 && u.collides)
                            if (n) {
                                var d = t.getTileRight(e, l, a);
                                if (0 === s && (r = u.x * u.width, o = u.y * u.height, s = u.width), d && d.collides) s += u.width;
                                else(p = this.createBody(r, o, 0, !1)).addRectangle(s, u.height, s / 2, u.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p), s = 0
                            } else {
                                var p;
                                (p = this.createBody(u.x * u.width, u.y * u.height, 0, !1)).addRectangle(u.width, u.height, u.width / 2, u.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p)
                            }
                    }
                }
                return t.layers[e].bodies
            },
            mpx: function(t) {
                return 20 * t
            },
            pxm: function(t) {
                return .05 * t
            },
            mpxi: function(t) {
                return -20 * t
            },
            pxmi: function(t) {
                return -.05 * t
            }
        }, Object.defineProperty(i.Physics.P2.prototype, "friction", {
            get: function() {
                return this.world.defaultContactMaterial.friction
            },
            set: function(t) {
                this.world.defaultContactMaterial.friction = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "restitution", {
            get: function() {
                return this.world.defaultContactMaterial.restitution
            },
            set: function(t) {
                this.world.defaultContactMaterial.restitution = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "contactMaterial", {
            get: function() {
                return this.world.defaultContactMaterial
            },
            set: function(t) {
                this.world.defaultContactMaterial = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "applySpringForces", {
            get: function() {
                return this.world.applySpringForces
            },
            set: function(t) {
                this.world.applySpringForces = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "applyDamping", {
            get: function() {
                return this.world.applyDamping
            },
            set: function(t) {
                this.world.applyDamping = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "applyGravity", {
            get: function() {
                return this.world.applyGravity
            },
            set: function(t) {
                this.world.applyGravity = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "solveConstraints", {
            get: function() {
                return this.world.solveConstraints
            },
            set: function(t) {
                this.world.solveConstraints = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "time", {
            get: function() {
                return this.world.time
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "emitImpactEvent", {
            get: function() {
                return this.world.emitImpactEvent
            },
            set: function(t) {
                this.world.emitImpactEvent = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "sleepMode", {
            get: function() {
                return this.world.sleepMode
            },
            set: function(t) {
                this.world.sleepMode = t
            }
        }), Object.defineProperty(i.Physics.P2.prototype, "total", {
            get: function() {
                return this.world.bodies.length
            }
        }), i.Physics.P2.FixtureList = function(t) {
            Array.isArray(t) || (t = [t]), this.rawList = t, this.init(), this.parse(this.rawList)
        }, i.Physics.P2.FixtureList.prototype = {
            init: function() {
                this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = []
            },
            setCategory: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.collisionGroup = t
                })
            },
            setMask: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.collisionMask = t
                })
            },
            setSensor: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.sensor = t
                })
            },
            setMaterial: function(t, e) {
                this.getFixtures(e).forEach(function(e) {
                    e.material = t
                })
            },
            getFixtures: function(t) {
                var e = [];
                if (t) {
                    t instanceof Array || (t = [t]);
                    var i = this;
                    return t.forEach(function(t) {
                        i.namedFixtures[t] && e.push(i.namedFixtures[t])
                    }), this.flatten(e)
                }
                return this.allFixtures
            },
            getFixtureByKey: function(t) {
                return this.namedFixtures[t]
            },
            getGroup: function(t) {
                return this.groupedFixtures[t]
            },
            parse: function() {
                var t, e, i, n;
                for (t in n = [], i = this.rawList) e = i[t], isNaN(t - 0) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [], this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)), n.push(this.allFixtures = this.flatten(this.groupedFixtures))
            },
            flatten: function(t) {
                var e, i;
                return e = [], i = arguments.callee, t.forEach(function(t) {
                    return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t])
                }), e
            }
        }, i.Physics.P2.PointProxy = function(t, e) {
            this.world = t, this.destination = e
        }, i.Physics.P2.PointProxy.prototype.constructor = i.Physics.P2.PointProxy, Object.defineProperty(i.Physics.P2.PointProxy.prototype, "x", {
            get: function() {
                return this.world.mpx(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxm(t)
            }
        }), Object.defineProperty(i.Physics.P2.PointProxy.prototype, "y", {
            get: function() {
                return this.world.mpx(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxm(t)
            }
        }), Object.defineProperty(i.Physics.P2.PointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = t
            }
        }), Object.defineProperty(i.Physics.P2.PointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = t
            }
        }), i.Physics.P2.InversePointProxy = function(t, e) {
            this.world = t, this.destination = e
        }, i.Physics.P2.InversePointProxy.prototype.constructor = i.Physics.P2.InversePointProxy, Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.destination[0])
            },
            set: function(t) {
                this.destination[0] = this.world.pxmi(t)
            }
        }), Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.destination[1])
            },
            set: function(t) {
                this.destination[1] = this.world.pxmi(t)
            }
        }), Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "mx", {
            get: function() {
                return this.destination[0]
            },
            set: function(t) {
                this.destination[0] = -t
            }
        }), Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "my", {
            get: function() {
                return this.destination[1]
            },
            set: function(t) {
                this.destination[1] = -t
            }
        }), i.Physics.P2.Body = function(t, e, n, s, r) {
            e = e || null, n = n || 0, s = s || 0, void 0 === r && (r = 1), this.game = t, this.world = t.physics.p2, this.sprite = e, this.type = i.Physics.P2JS, this.offset = new i.Point, this.data = new p2.Body({
                position: [this.world.pxmi(n), this.world.pxmi(s)],
                mass: r
            }), this.data.parent = this, this.velocity = new i.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new i.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new i.Point, this.onBeginContact = new i.Signal, this.onEndContact = new i.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, e && (this.setRectangleFromSprite(e), e.exists && this.game.physics.p2.addBody(this))
        }, i.Physics.P2.Body.prototype = {
            createBodyCallback: function(t, e, i) {
                var n = -1;
                t.id ? n = t.id : t.body && (n = t.body.id), n > -1 && (null === e ? (delete this._bodyCallbacks[n], delete this._bodyCallbackContext[n]) : (this._bodyCallbacks[n] = e, this._bodyCallbackContext[n] = i))
            },
            createGroupCallback: function(t, e, i) {
                null === e ? (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]) : (this._groupCallbacks[t.mask] = e, this._groupCallbackContext[t.mask] = i)
            },
            getCollisionMask: function() {
                var t = 0;
                this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask);
                for (var e = 0; e < this.collidesWith.length; e++) t |= this.collidesWith[e].mask;
                return t
            },
            updateCollisionMask: function(t) {
                var e = this.getCollisionMask();
                if (void 0 === t)
                    for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].collisionMask = e;
                else t.collisionMask = e
            },
            setCollisionGroup: function(t, e) {
                var i = this.getCollisionMask();
                if (void 0 === e)
                    for (var n = this.data.shapes.length - 1; n >= 0; n--) this.data.shapes[n].collisionGroup = t.mask, this.data.shapes[n].collisionMask = i;
                else e.collisionGroup = t.mask, e.collisionMask = i
            },
            clearCollision: function(t, e, i) {
                if (void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i)
                    for (var n = this.data.shapes.length - 1; n >= 0; n--) t && (this.data.shapes[n].collisionGroup = null), e && (this.data.shapes[n].collisionMask = null);
                else t && (i.collisionGroup = null), e && (i.collisionMask = null);
                t && (this.collidesWith.length = 0)
            },
            removeCollisionGroup: function(t, e, i) {
                var n;
                if (void 0 === e && (e = !0), Array.isArray(t))
                    for (var s = 0; s < t.length; s++)(n = this.collidesWith.indexOf(t[s])) > -1 && (this.collidesWith.splice(n, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                else(n = this.collidesWith.indexOf(t)) > -1 && (this.collidesWith.splice(n, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                var r = this.getCollisionMask();
                if (void 0 === i)
                    for (s = this.data.shapes.length - 1; s >= 0; s--) this.data.shapes[s].collisionMask = r;
                else i.collisionMask = r
            },
            collides: function(t, e, i, n) {
                if (Array.isArray(t))
                    for (var s = 0; s < t.length; s++) - 1 === this.collidesWith.indexOf(t[s]) && (this.collidesWith.push(t[s]), e && this.createGroupCallback(t[s], e, i));
                else -1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t), e && this.createGroupCallback(t, e, i));
                var r = this.getCollisionMask();
                if (void 0 === n)
                    for (s = this.data.shapes.length - 1; s >= 0; s--) this.data.shapes[s].collisionMask = r;
                else n.collisionMask = r
            },
            adjustCenterOfMass: function() {
                this.data.adjustCenterOfMass(), this.shapeChanged()
            },
            getVelocityAtPoint: function(t, e) {
                return this.data.getVelocityAtPoint(t, e)
            },
            applyDamping: function(t) {
                this.data.applyDamping(t)
            },
            applyImpulse: function(t, e, i) {
                this.data.applyImpulse(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyImpulseLocal: function(t, e, i) {
                this.data.applyImpulseLocal(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            applyForce: function(t, e, i) {
                this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)])
            },
            setZeroForce: function() {
                this.data.setZeroForce()
            },
            setZeroRotation: function() {
                this.data.angularVelocity = 0
            },
            setZeroVelocity: function() {
                this.data.velocity[0] = 0, this.data.velocity[1] = 0
            },
            setZeroDamping: function() {
                this.data.damping = 0, this.data.angularDamping = 0
            },
            toLocalFrame: function(t, e) {
                return this.data.toLocalFrame(t, e)
            },
            toWorldFrame: function(t, e) {
                return this.data.toWorldFrame(t, e)
            },
            rotateLeft: function(t) {
                this.data.angularVelocity = this.world.pxm(-t)
            },
            rotateRight: function(t) {
                this.data.angularVelocity = this.world.pxm(t)
            },
            moveForward: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = e * Math.cos(i), this.data.velocity[1] = e * Math.sin(i)
            },
            moveBackward: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = -e * Math.cos(i), this.data.velocity[1] = -e * Math.sin(i)
            },
            thrust: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
            },
            thrustLeft: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
            },
            thrustRight: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
            },
            reverse: function(t) {
                var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
            },
            moveLeft: function(t) {
                this.data.velocity[0] = this.world.pxmi(-t)
            },
            moveRight: function(t) {
                this.data.velocity[0] = this.world.pxmi(t)
            },
            moveUp: function(t) {
                this.data.velocity[1] = this.world.pxmi(-t)
            },
            moveDown: function(t) {
                this.data.velocity[1] = this.world.pxmi(t)
            },
            preUpdate: function() {
                this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
            },
            postUpdate: function() {
                this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1
            },
            reset: function(t, e, i, n) {
                void 0 === i && (i = !1), void 0 === n && (n = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), i && this.setZeroDamping(), n && (this.mass = 1), this.x = t, this.y = e
            },
            addToWorld: function() {
                if (this.game.physics.p2._toRemove)
                    for (var t = 0; t < this.game.physics.p2._toRemove.length; t++) this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
                this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
            },
            removeFromWorld: function() {
                this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
            },
            destroy: function() {
                this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null)
            },
            clearShapes: function() {
                for (var t = this.data.shapes.length; t--;) this.data.removeShape(this.data.shapes[t]);
                this.shapeChanged()
            },
            addShape: function(t, e, i, n) {
                return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], n), this.shapeChanged(), t
            },
            addCircle: function(t, e, i, n) {
                var s = new p2.Circle({
                    radius: this.world.pxm(t)
                });
                return this.addShape(s, e, i, n)
            },
            addRectangle: function(t, e, i, n, s) {
                var r = new p2.Box({
                    width: this.world.pxm(t),
                    height: this.world.pxm(e)
                });
                return this.addShape(r, i, n, s)
            },
            addPlane: function(t, e, i) {
                var n = new p2.Plane;
                return this.addShape(n, t, e, i)
            },
            addParticle: function(t, e, i) {
                var n = new p2.Particle;
                return this.addShape(n, t, e, i)
            },
            addLine: function(t, e, i, n) {
                var s = new p2.Line({
                    length: this.world.pxm(t)
                });
                return this.addShape(s, e, i, n)
            },
            addCapsule: function(t, e, i, n, s) {
                var r = new p2.Capsule({
                    length: this.world.pxm(t),
                    radius: this.world.pxm(e)
                });
                return this.addShape(r, i, n, s)
            },
            addPolygon: function(t, e) {
                t = t || {}, Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1));
                var i = [];
                if (1 === e.length && Array.isArray(e[0])) i = e[0].slice(0);
                else if (Array.isArray(e[0])) i = e.slice();
                else if ("number" == typeof e[0])
                    for (var n = 0, s = e.length; n < s; n += 2) i.push([e[n], e[n + 1]]);
                var r = i.length - 1;
                i[r][0] === i[0][0] && i[r][1] === i[0][1] && i.pop();
                for (var o = 0; o < i.length; o++) i[o][0] = this.world.pxmi(i[o][0]), i[o][1] = this.world.pxmi(i[o][1]);
                var a = this.data.fromPolygon(i, t);
                return this.shapeChanged(), a
            },
            removeShape: function(t) {
                var e = this.data.removeShape(t);
                return this.shapeChanged(), e
            },
            setCircle: function(t, e, i, n) {
                return this.clearShapes(), this.addCircle(t, e, i, n)
            },
            setRectangle: function(t, e, i, n, s) {
                return void 0 === t && (t = 16), void 0 === e && (e = 16), this.clearShapes(), this.addRectangle(t, e, i, n, s)
            },
            setRectangleFromSprite: function(t) {
                return void 0 === t && (t = this.sprite), this.clearShapes(), this.addRectangle(t.width, t.height, 0, 0, t.rotation)
            },
            setMaterial: function(t, e) {
                if (void 0 === e)
                    for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].material = t;
                else e.material = t
            },
            shapeChanged: function() {
                this.debugBody && this.debugBody.draw()
            },
            addPhaserPolygon: function(t, e) {
                for (var i = this.game.cache.getPhysicsData(t, e), n = [], s = 0; s < i.length; s++) {
                    var r = i[s],
                        o = this.addFixture(r);
                    n[r.filter.group] = n[r.filter.group] || [], n[r.filter.group] = n[r.filter.group].concat(o), r.fixtureKey && (n[r.fixtureKey] = o)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), n
            },
            addFixture: function(t) {
                var e = [];
                if (t.circle) {
                    (l = new p2.Circle({
                        radius: this.world.pxm(t.circle.radius)
                    })).collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor;
                    var i = p2.vec2.create();
                    i[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2), i[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2), this.data.addShape(l, i), e.push(l)
                } else
                    for (var n = t.polygons, s = p2.vec2.create(), r = 0; r < n.length; r++) {
                        for (var o = n[r], a = [], h = 0; h < o.length; h += 2) a.push([this.world.pxmi(o[h]), this.world.pxmi(o[h + 1])]);
                        for (var l = new p2.Convex({
                                vertices: a
                            }), c = 0; c !== l.vertices.length; c++) {
                            var u = l.vertices[c];
                            p2.vec2.sub(u, u, l.centerOfMass)
                        }
                        p2.vec2.scale(s, l.centerOfMass, 1), s[0] -= this.world.pxmi(this.sprite.width / 2), s[1] -= this.world.pxmi(this.sprite.height / 2), l.updateTriangles(), l.updateCenterOfMass(), l.updateBoundingRadius(), l.collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor, this.data.addShape(l, s), e.push(l)
                    }
                return e
            },
            loadPolygon: function(t, e) {
                if (null === t) var i = e;
                else i = this.game.cache.getPhysicsData(t, e);
                for (var n = p2.vec2.create(), s = 0; s < i.length; s++) {
                    for (var r = [], o = 0; o < i[s].shape.length; o += 2) r.push([this.world.pxmi(i[s].shape[o]), this.world.pxmi(i[s].shape[o + 1])]);
                    for (var a = new p2.Convex({
                            vertices: r
                        }), h = 0; h !== a.vertices.length; h++) {
                        var l = a.vertices[h];
                        p2.vec2.sub(l, l, a.centerOfMass)
                    }
                    p2.vec2.scale(n, a.centerOfMass, 1), n[0] -= this.world.pxmi(this.sprite.width / 2), n[1] -= this.world.pxmi(this.sprite.height / 2), a.updateTriangles(), a.updateCenterOfMass(), a.updateBoundingRadius(), this.data.addShape(a, n)
                }
                return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0
            }
        }, i.Physics.P2.Body.prototype.constructor = i.Physics.P2.Body, i.Physics.P2.Body.DYNAMIC = 1, i.Physics.P2.Body.STATIC = 2, i.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(i.Physics.P2.Body.prototype, "static", {
            get: function() {
                return this.data.type === i.Physics.P2.Body.STATIC
            },
            set: function(t) {
                t && this.data.type !== i.Physics.P2.Body.STATIC ? (this.data.type = i.Physics.P2.Body.STATIC, this.mass = 0) : t || this.data.type !== i.Physics.P2.Body.STATIC || (this.data.type = i.Physics.P2.Body.DYNAMIC, this.mass = 1)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "dynamic", {
            get: function() {
                return this.data.type === i.Physics.P2.Body.DYNAMIC
            },
            set: function(t) {
                t && this.data.type !== i.Physics.P2.Body.DYNAMIC ? (this.data.type = i.Physics.P2.Body.DYNAMIC, this.mass = 1) : t || this.data.type !== i.Physics.P2.Body.DYNAMIC || (this.data.type = i.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "kinematic", {
            get: function() {
                return this.data.type === i.Physics.P2.Body.KINEMATIC
            },
            set: function(t) {
                t && this.data.type !== i.Physics.P2.Body.KINEMATIC ? (this.data.type = i.Physics.P2.Body.KINEMATIC, this.mass = 4) : t || this.data.type !== i.Physics.P2.Body.KINEMATIC || (this.data.type = i.Physics.P2.Body.STATIC, this.mass = 0)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "allowSleep", {
            get: function() {
                return this.data.allowSleep
            },
            set: function(t) {
                t !== this.data.allowSleep && (this.data.allowSleep = t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "angle", {
            get: function() {
                return i.Math.wrapAngle(i.Math.radToDeg(this.data.angle))
            },
            set: function(t) {
                this.data.angle = i.Math.degToRad(i.Math.wrapAngle(t))
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "angularDamping", {
            get: function() {
                return this.data.angularDamping
            },
            set: function(t) {
                this.data.angularDamping = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "angularForce", {
            get: function() {
                return this.data.angularForce
            },
            set: function(t) {
                this.data.angularForce = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "angularVelocity", {
            get: function() {
                return this.data.angularVelocity
            },
            set: function(t) {
                this.data.angularVelocity = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "damping", {
            get: function() {
                return this.data.damping
            },
            set: function(t) {
                this.data.damping = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "fixedRotation", {
            get: function() {
                return this.data.fixedRotation
            },
            set: function(t) {
                t !== this.data.fixedRotation && (this.data.fixedRotation = t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "inertia", {
            get: function() {
                return this.data.inertia
            },
            set: function(t) {
                this.data.inertia = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "mass", {
            get: function() {
                return this.data.mass
            },
            set: function(t) {
                t !== this.data.mass && (this.data.mass = t, this.data.updateMassProperties())
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "motionState", {
            get: function() {
                return this.data.type
            },
            set: function(t) {
                t !== this.data.type && (this.data.type = t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "rotation", {
            get: function() {
                return this.data.angle
            },
            set: function(t) {
                this.data.angle = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "sleepSpeedLimit", {
            get: function() {
                return this.data.sleepSpeedLimit
            },
            set: function(t) {
                this.data.sleepSpeedLimit = t
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "x", {
            get: function() {
                return this.world.mpxi(this.data.position[0])
            },
            set: function(t) {
                this.data.position[0] = this.world.pxmi(t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "y", {
            get: function() {
                return this.world.mpxi(this.data.position[1])
            },
            set: function(t) {
                this.data.position[1] = this.world.pxmi(t)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "id", {
            get: function() {
                return this.data.id
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "debug", {
            get: function() {
                return null !== this.debugBody
            },
            set: function(t) {
                t && !this.debugBody ? this.debugBody = new i.Physics.P2.BodyDebug(this.game, this.data) : !t && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
            }
        }), Object.defineProperty(i.Physics.P2.Body.prototype, "collideWorldBounds", {
            get: function() {
                return this._collideWorldBounds
            },
            set: function(t) {
                t && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
            }
        }), i.Physics.P2.BodyDebug = function(t, e, n) {
            i.Group.call(this, t);
            var s = {
                pixelsPerLengthUnit: t.physics.p2.mpx(1),
                debugPolygons: !1,
                lineWidth: 1,
                alpha: .5
            };
            this.settings = i.Utils.extend(s, n), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = e, this.canvas = new i.Graphics(t), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform()
        }, i.Physics.P2.BodyDebug.prototype = Object.create(i.Group.prototype), i.Physics.P2.BodyDebug.prototype.constructor = i.Physics.P2.BodyDebug, i.Utils.extend(i.Physics.P2.BodyDebug.prototype, {
            updateSpriteTransform: function() {
                this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle
            },
            draw: function() {
                var t, e, i, n, s, r, o, a, h, l, c, u, d, p;
                if (o = this.body, (h = this.canvas).clear(), i = parseInt(this.randomPastelHex(), 16), 16711680, r = this.lineWidth, o instanceof p2.Body && o.shapes.length) {
                    var f = o.shapes.length;
                    for (n = 0; n !== f;) {
                        if (a = (e = o.shapes[n]).position || 0, t = e.angle || 0, e instanceof p2.Circle) this.drawCircle(h, a[0] * this.ppu, a[1] * this.ppu, t, e.radius * this.ppu, i, r);
                        else if (e instanceof p2.Capsule) this.drawCapsule(h, a[0] * this.ppu, a[1] * this.ppu, t, e.length * this.ppu, e.radius * this.ppu, 16711680, i, r);
                        else if (e instanceof p2.Plane) this.drawPlane(h, a[0] * this.ppu, -a[1] * this.ppu, i, 16711680, 5 * r, 10 * r, 10 * r, 100 * this.ppu, t);
                        else if (e instanceof p2.Line) this.drawLine(h, e.length * this.ppu, 16711680, r);
                        else if (e instanceof p2.Box) this.drawRectangle(h, a[0] * this.ppu, a[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, 16711680, i, r);
                        else if (e instanceof p2.Convex) {
                            for (c = [], u = p2.vec2.create(), s = d = 0, p = e.vertices.length; 0 <= p ? d < p : d > p; s = 0 <= p ? ++d : --d) l = e.vertices[s], p2.vec2.rotate(u, l, t), c.push([(u[0] + a[0]) * this.ppu, -(u[1] + a[1]) * this.ppu]);
                            this.drawConvex(h, c, e.triangles, 16711680, i, r, this.settings.debugPolygons, [a[0] * this.ppu, -a[1] * this.ppu])
                        }
                        n++
                    }
                }
            },
            drawRectangle: function(t, e, i, n, s, r, o, a, h) {
                void 0 === h && (h = 1), void 0 === o && (o = 0), t.lineStyle(h, o, 1), t.beginFill(a), t.drawRect(e - s / 2, i - r / 2, s, r)
            },
            drawCircle: function(t, e, i, n, s, r, o) {
                void 0 === o && (o = 1), void 0 === r && (r = 16777215), t.lineStyle(o, 0, 1), t.beginFill(r, 1), t.drawCircle(e, i, 2 * -s), t.endFill(), t.moveTo(e, i), t.lineTo(e + s * Math.cos(-n), i + s * Math.sin(-n))
            },
            drawLine: function(t, e, i, n) {
                void 0 === n && (n = 1), void 0 === i && (i = 0), t.lineStyle(5 * n, i, 1), t.moveTo(-e / 2, 0), t.lineTo(e / 2, 0)
            },
            drawConvex: function(t, e, i, n, s, r, o, a) {
                var h, l, c, u, d, p, f, g, m, y, v;
                if (void 0 === r && (r = 1), void 0 === n && (n = 0), o) {
                    for (h = [16711680, 65280, 255], l = 0; l !== e.length + 1;) u = e[l % e.length], d = e[(l + 1) % e.length], f = u[0], y = u[1], g = d[0], v = d[1], t.lineStyle(r, h[l % h.length], 1), t.moveTo(f, -y), t.lineTo(g, -v), t.drawCircle(f, -y, 2 * r), l++;
                    return t.lineStyle(r, 0, 1), t.drawCircle(a[0], a[1], 2 * r)
                }
                for (t.lineStyle(r, n, 1), t.beginFill(s), l = 0; l !== e.length;) p = (c = e[l])[0], m = c[1], 0 === l ? t.moveTo(p, -m) : t.lineTo(p, -m), l++;
                if (t.endFill(), e.length > 2) return t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]), t.lineTo(e[0][0], -e[0][1])
            },
            drawPath: function(t, e, i, n, s) {
                var r, o, a, h, l, c, u, d, p, f, g;
                for (void 0 === s && (s = 1), void 0 === i && (i = 0), t.lineStyle(s, i, 1), "number" == typeof n && t.beginFill(n), o = null, a = null, r = 0; r < e.length;) f = (p = e[r])[0], g = p[1], f === o && g === a || (0 === r ? t.moveTo(f, g) : (h = o, l = a, c = f, u = g, d = e[(r + 1) % e.length][0], 0 !== (c - h) * (e[(r + 1) % e.length][1] - l) - (d - h) * (u - l) && t.lineTo(f, g)), o = f, a = g), r++;
                "number" == typeof n && t.endFill(), e.length > 2 && "number" == typeof n && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]), t.lineTo(e[0][0], e[0][1]))
            },
            drawPlane: function(t, e, i, n, s, r, o, a, h, l) {
                var c, u;
                void 0 === r && (r = 1), void 0 === n && (n = 16777215), t.lineStyle(r, s, 11), t.beginFill(n), t.moveTo(e, -i), c = e + Math.cos(l) * this.game.width, u = i + Math.sin(l) * this.game.height, t.lineTo(c, -u), t.moveTo(e, -i), c = e + Math.cos(l) * -this.game.width, u = i + Math.sin(l) * -this.game.height, t.lineTo(c, -u)
            },
            drawCapsule: function(t, e, i, n, s, r, o, a, h) {
                void 0 === h && (h = 1), void 0 === o && (o = 0), t.lineStyle(h, o, 1);
                var l = Math.cos(n),
                    c = Math.sin(n);
                t.beginFill(a, 1), t.drawCircle(-s / 2 * l + e, -s / 2 * c + i, 2 * -r), t.drawCircle(s / 2 * l + e, s / 2 * c + i, 2 * -r), t.endFill(), t.lineStyle(h, o, 0), t.beginFill(a, 1), t.moveTo(-s / 2 * l + r * c + e, -s / 2 * c + r * l + i), t.lineTo(s / 2 * l + r * c + e, s / 2 * c + r * l + i), t.lineTo(s / 2 * l - r * c + e, s / 2 * c - r * l + i), t.lineTo(-s / 2 * l - r * c + e, -s / 2 * c - r * l + i), t.endFill(), t.lineStyle(h, o, 1), t.moveTo(-s / 2 * l + r * c + e, -s / 2 * c + r * l + i), t.lineTo(s / 2 * l + r * c + e, s / 2 * c + r * l + i), t.moveTo(-s / 2 * l - r * c + e, -s / 2 * c - r * l + i), t.lineTo(s / 2 * l - r * c + e, s / 2 * c - r * l + i)
            },
            randomPastelHex: function() {
                var t, e, i, n;
                return i = [255, 255, 255], n = Math.floor(256 * Math.random()), e = Math.floor(256 * Math.random()), t = Math.floor(256 * Math.random()), n = Math.floor((n + 3 * i[0]) / 4), e = Math.floor((e + 3 * i[1]) / 4), t = Math.floor((t + 3 * i[2]) / 4), this.rgbToHex(n, e, t)
            },
            rgbToHex: function(t, e, i) {
                return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i)
            },
            componentToHex: function(t) {
                var e;
                return 2 === (e = t.toString(16)).length ? e : e + "0"
            }
        }), i.Physics.P2.Spring = function(t, e, i, n, s, r, o, a, h, l) {
            this.game = t.game, this.world = t, void 0 === n && (n = 1), void 0 === s && (s = 100), void 0 === r && (r = 1);
            var c = {
                restLength: n = t.pxm(n),
                stiffness: s,
                damping: r
            };
            void 0 !== o && null !== o && (c.worldAnchorA = [t.pxm(o[0]), t.pxm(o[1])]), void 0 !== a && null !== a && (c.worldAnchorB = [t.pxm(a[0]), t.pxm(a[1])]), void 0 !== h && null !== h && (c.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]), void 0 !== l && null !== l && (c.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]), this.data = new p2.LinearSpring(e, i, c), this.data.parent = this
        }, i.Physics.P2.Spring.prototype.constructor = i.Physics.P2.Spring, i.Physics.P2.RotationalSpring = function(t, e, i, n, s, r) {
            this.game = t.game, this.world = t, void 0 === n && (n = null), void 0 === s && (s = 100), void 0 === r && (r = 1), n && (n = t.pxm(n));
            var o = {
                restAngle: n,
                stiffness: s,
                damping: r
            };
            this.data = new p2.RotationalSpring(e, i, o), this.data.parent = this
        }, i.Physics.P2.Spring.prototype.constructor = i.Physics.P2.Spring, i.Physics.P2.Material = function(t) {
            this.name = t, p2.Material.call(this)
        }, i.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), i.Physics.P2.Material.prototype.constructor = i.Physics.P2.Material, i.Physics.P2.ContactMaterial = function(t, e, i) {
            p2.ContactMaterial.call(this, t, e, i)
        }, i.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), i.Physics.P2.ContactMaterial.prototype.constructor = i.Physics.P2.ContactMaterial, i.Physics.P2.CollisionGroup = function(t) {
            this.mask = t
        }, i.Physics.P2.DistanceConstraint = function(t, e, i, n, s, r, o) {
            void 0 === n && (n = 100), void 0 === s && (s = [0, 0]), void 0 === r && (r = [0, 0]), void 0 === o && (o = Number.MAX_VALUE), this.game = t.game, this.world = t;
            var a = {
                distance: n = t.pxm(n),
                localAnchorA: s = [t.pxmi(s[0]), t.pxmi(s[1])],
                localAnchorB: r = [t.pxmi(r[0]), t.pxmi(r[1])],
                maxForce: o
            };
            p2.DistanceConstraint.call(this, e, i, a)
        }, i.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), i.Physics.P2.DistanceConstraint.prototype.constructor = i.Physics.P2.DistanceConstraint, i.Physics.P2.GearConstraint = function(t, e, i, n, s) {
            void 0 === n && (n = 0), void 0 === s && (s = 1), this.game = t.game, this.world = t;
            var r = {
                angle: n,
                ratio: s
            };
            p2.GearConstraint.call(this, e, i, r)
        }, i.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), i.Physics.P2.GearConstraint.prototype.constructor = i.Physics.P2.GearConstraint, i.Physics.P2.LockConstraint = function(t, e, i, n, s, r) {
            void 0 === n && (n = [0, 0]), void 0 === s && (s = 0), void 0 === r && (r = Number.MAX_VALUE), this.game = t.game, this.world = t;
            var o = {
                localOffsetB: n = [t.pxm(n[0]), t.pxm(n[1])],
                localAngleB: s,
                maxForce: r
            };
            p2.LockConstraint.call(this, e, i, o)
        }, i.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), i.Physics.P2.LockConstraint.prototype.constructor = i.Physics.P2.LockConstraint, i.Physics.P2.PrismaticConstraint = function(t, e, i, n, s, r, o, a) {
            void 0 === n && (n = !0), void 0 === s && (s = [0, 0]), void 0 === r && (r = [0, 0]), void 0 === o && (o = [0, 0]), void 0 === a && (a = Number.MAX_VALUE), this.game = t.game, this.world = t;
            var h = {
                localAnchorA: s = [t.pxmi(s[0]), t.pxmi(s[1])],
                localAnchorB: r = [t.pxmi(r[0]), t.pxmi(r[1])],
                localAxisA: o,
                maxForce: a,
                disableRotationalLock: !n
            };
            p2.PrismaticConstraint.call(this, e, i, h)
        }, i.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), i.Physics.P2.PrismaticConstraint.prototype.constructor = i.Physics.P2.PrismaticConstraint, i.Physics.P2.RevoluteConstraint = function(t, e, i, n, s, r, o) {
            void 0 === r && (r = Number.MAX_VALUE), void 0 === o && (o = null), this.game = t.game, this.world = t, i = [t.pxmi(i[0]), t.pxmi(i[1])], s = [t.pxmi(s[0]), t.pxmi(s[1])], o && (o = [t.pxmi(o[0]), t.pxmi(o[1])]);
            var a = {
                worldPivot: o,
                localPivotA: i,
                localPivotB: s,
                maxForce: r
            };
            p2.RevoluteConstraint.call(this, e, n, a)
        }, i.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), i.Physics.P2.RevoluteConstraint.prototype.constructor = i.Physics.P2.RevoluteConstraint, i.ImageCollection = function(t, e, i, n, s, r, o) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | n, this.imageMargin = 0 | s, this.imageSpacing = 0 | r, this.properties = o || {}, this.images = [], this.total = 0
        }, i.ImageCollection.prototype = {
            containsImageIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            addImage: function(t, e) {
                this.images.push({
                    gid: t,
                    image: e
                }), this.total++
            }
        }, i.ImageCollection.prototype.constructor = i.ImageCollection, i.Tile = function(t, e, i, n, s, r) {
            this.layer = t, this.index = e, this.x = i, this.y = n, this.rotation = 0, this.flipped = !1, this.worldX = i * s, this.worldY = n * r, this.width = s, this.height = r, this.centerX = Math.abs(s / 2), this.centerY = Math.abs(r / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this
        }, i.Tile.prototype = {
            containsPoint: function(t, e) {
                return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
            },
            intersects: function(t, e, i, n) {
                return !(i <= this.worldX) && (!(n <= this.worldY) && (!(t >= this.worldX + this.width) && !(e >= this.worldY + this.height)))
            },
            setCollisionCallback: function(t, e) {
                this.collisionCallback = t, this.collisionCallbackContext = e
            },
            destroy: function() {
                this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
            },
            setCollision: function(t, e, i, n) {
                this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = n, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = n
            },
            resetCollision: function() {
                this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
            },
            isInteresting: function(t, e) {
                return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
            },
            copy: function(t) {
                this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext
            }
        }, i.Tile.prototype.constructor = i.Tile, Object.defineProperty(i.Tile.prototype, "collides", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
            }
        }), Object.defineProperty(i.Tile.prototype, "canCollide", {
            get: function() {
                return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
            }
        }), Object.defineProperty(i.Tile.prototype, "left", {
            get: function() {
                return this.worldX
            }
        }), Object.defineProperty(i.Tile.prototype, "right", {
            get: function() {
                return this.worldX + this.width
            }
        }), Object.defineProperty(i.Tile.prototype, "top", {
            get: function() {
                return this.worldY
            }
        }), Object.defineProperty(i.Tile.prototype, "bottom", {
            get: function() {
                return this.worldY + this.height
            }
        }), i.Tilemap = function(t, e, n, s, r, o) {
            this.game = t, this.key = e;
            var a = i.TilemapParser.parse(this.game, e, n, s, r, o);
            null !== a && (this.width = a.width, this.height = a.height, this.tileWidth = a.tileWidth, this.tileHeight = a.tileHeight, this.orientation = a.orientation, this.format = a.format, this.version = a.version, this.properties = a.properties, this.widthInPixels = a.widthInPixels, this.heightInPixels = a.heightInPixels, this.layers = a.layers, this.tilesets = a.tilesets, this.imagecollections = a.imagecollections, this.tiles = a.tiles, this.objects = a.objects, this.collideIndexes = [], this.collision = a.collision, this.images = a.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
        }, i.Tilemap.CSV = 0, i.Tilemap.TILED_JSON = 1, i.Tilemap.NORTH = 0, i.Tilemap.EAST = 1, i.Tilemap.SOUTH = 2, i.Tilemap.WEST = 3, i.Tilemap.prototype = {
            create: function(t, e, i, n, s, r) {
                return void 0 === r && (r = this.game.world), this.width = e, this.height = i, this.setTileSize(n, s), this.layers.length = 0, this.createBlankLayer(t, e, i, n, s, r)
            },
            setTileSize: function(t, e) {
                this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e
            },
            addTilesetImage: function(t, e, n, s, r, o, a) {
                if (void 0 === t) return null;
                void 0 === n && (n = this.tileWidth), void 0 === s && (s = this.tileHeight), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), 0 === n && (n = 32), 0 === s && (s = 32);
                var h = null;
                if (void 0 !== e && null !== e || (e = t), e instanceof i.BitmapData) h = e.canvas;
                else {
                    if (!this.game.cache.checkImageKey(e)) return null;
                    h = this.game.cache.getImage(e)
                }
                var l = this.getTilesetIndex(t);
                if (null === l && this.format === i.Tilemap.TILED_JSON) return null;
                if (this.tilesets[l]) return this.tilesets[l].setImage(h), this.tilesets[l];
                var c = new i.Tileset(t, a, n, s, r, o, {});
                c.setImage(h), this.tilesets.push(c);
                for (var u = this.tilesets.length - 1, d = r, p = r, f = 0, g = 0, m = 0, y = a; y < a + c.total && (this.tiles[y] = [d, p, u], d += n + o, ++f !== c.total) && (++g !== c.columns || (d = r, p += s + o, g = 0, ++m !== c.rows)); y++);
                return c
            },
            createFromObjects: function(t, e, n, s, r, o, a, h, l) {
                if (void 0 === r && (r = !0), void 0 === o && (o = !1), void 0 === a && (a = this.game.world), void 0 === h && (h = i.Sprite), void 0 === l && (l = !0), this.objects[t])
                    for (var c = 0; c < this.objects[t].length; c++) {
                        var u = !1,
                            d = this.objects[t][c];
                        if (void 0 !== d.gid && "number" == typeof e && d.gid === e ? u = !0 : void 0 !== d.id && "number" == typeof e && d.id === e ? u = !0 : void 0 !== d.name && "string" == typeof e && d.name === e && (u = !0), u) {
                            var p = new h(this.game, parseFloat(d.x, 10), parseFloat(d.y, 10), n, s);
                            for (var f in p.name = d.name, p.visible = d.visible, p.autoCull = o, p.exists = r, d.width && (p.width = d.width), d.height && (p.height = d.height), d.rotation && (p.angle = d.rotation), l && (p.y -= p.height), a.add(p), d.properties) a.set(p, f, d.properties[f], !1, !1, 0, !0)
                        }
                    }
            },
            createFromTiles: function(t, e, n, s, r, o) {
                "number" == typeof t && (t = [t]), void 0 === e || null === e ? e = [] : "number" == typeof e && (e = [e]), s = this.getLayer(s), void 0 === r && (r = this.game.world), void 0 === o && (o = {}), void 0 === o.customClass && (o.customClass = i.Sprite), void 0 === o.adjustY && (o.adjustY = !0);
                var a = this.layers[s].width,
                    h = this.layers[s].height;
                if (this.copy(0, 0, a, h, s), this._results.length < 2) return 0;
                for (var l, c = 0, u = 1, d = this._results.length; u < d; u++)
                    if (-1 !== t.indexOf(this._results[u].index)) {
                        for (var p in l = new o.customClass(this.game, this._results[u].worldX, this._results[u].worldY, n), o) l[p] = o[p];
                        r.add(l), c++
                    }
                if (1 === e.length)
                    for (u = 0; u < t.length; u++) this.replace(t[u], e[0], 0, 0, a, h, s);
                else if (e.length > 1)
                    for (u = 0; u < t.length; u++) this.replace(t[u], e[u], 0, 0, a, h, s);
                return c
            },
            createLayer: function(t, e, n, s) {
                void 0 === e && (e = this.game.width), void 0 === n && (n = this.game.height), void 0 === s && (s = this.game.world);
                var r = t;
                if ("string" == typeof t && (r = this.getLayerIndex(t)), !(null === r || r > this.layers.length)) {
                    void 0 === e || e <= 0 ? e = Math.min(this.game.width, this.layers[r].widthInPixels) : e > this.game.width && (e = this.game.width), void 0 === n || n <= 0 ? n = Math.min(this.game.height, this.layers[r].heightInPixels) : n > this.game.height && (n = this.game.height), this.enableDebug;
                    var o = s.add(new i.TilemapLayer(this.game, this, r, e, n));
                    return this.enableDebug, o
                }
            },
            createBlankLayer: function(t, e, n, s, r, o) {
                if (void 0 === o && (o = this.game.world), null === this.getLayerIndex(t)) {
                    for (var a, h = {
                            name: t,
                            x: 0,
                            y: 0,
                            width: e,
                            height: n,
                            widthInPixels: e * s,
                            heightInPixels: n * r,
                            alpha: 1,
                            visible: !0,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: [],
                            data: null
                        }, l = [], c = 0; c < n; c++) {
                        a = [];
                        for (var u = 0; u < e; u++) a.push(new i.Tile(h, -1, u, c, s, r));
                        l.push(a)
                    }
                    h.data = l, this.layers.push(h), this.currentLayer = this.layers.length - 1;
                    var d = h.widthInPixels,
                        p = h.heightInPixels;
                    return d > this.game.width && (d = this.game.width), p > this.game.height && (p = this.game.height), (l = new i.TilemapLayer(this.game, this, this.layers.length - 1, d, p)).name = t, o.add(l)
                }
            },
            getIndex: function(t, e) {
                for (var i = 0; i < t.length; i++)
                    if (t[i].name === e) return i;
                return null
            },
            getLayerIndex: function(t) {
                return this.getIndex(this.layers, t)
            },
            getTilesetIndex: function(t) {
                return this.getIndex(this.tilesets, t)
            },
            getImageIndex: function(t) {
                return this.getIndex(this.images, t)
            },
            setTileIndexCallback: function(t, e, i, n) {
                if (n = this.getLayer(n), "number" == typeof t) this.layers[n].callbacks[t] = {
                    callback: e,
                    callbackContext: i
                };
                else
                    for (var s = 0, r = t.length; s < r; s++) this.layers[n].callbacks[t[s]] = {
                        callback: e,
                        callbackContext: i
                    }
            },
            setTileLocationCallback: function(t, e, i, n, s, r, o) {
                if (o = this.getLayer(o), this.copy(t, e, i, n, o), !(this._results.length < 2))
                    for (var a = 1; a < this._results.length; a++) this._results[a].setCollisionCallback(s, r)
            },
            setCollision: function(t, e, i, n) {
                if (void 0 === e && (e = !0), void 0 === n && (n = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
                if (Array.isArray(t)) {
                    for (var s = 0; s < t.length; s++) this.setCollisionByIndex(t[s], e, i, !1);
                    n && this.calculateFaces(i)
                }
            },
            setCollisionBetween: function(t, e, i, n, s) {
                if (void 0 === i && (i = !0), void 0 === s && (s = !0), n = this.getLayer(n), !(t > e)) {
                    for (var r = t; r <= e; r++) this.setCollisionByIndex(r, i, n, !1);
                    s && this.calculateFaces(n)
                }
            },
            setCollisionByExclusion: function(t, e, i, n) {
                void 0 === e && (e = !0), void 0 === n && (n = !0), i = this.getLayer(i);
                for (var s = 0, r = this.tiles.length; s < r; s++) - 1 === t.indexOf(s) && this.setCollisionByIndex(s, e, i, !1);
                n && this.calculateFaces(i)
            },
            setCollisionByIndex: function(t, e, i, n) {
                if (void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === n && (n = !0), e) this.collideIndexes.push(t);
                else {
                    var s = this.collideIndexes.indexOf(t);
                    s > -1 && this.collideIndexes.splice(s, 1)
                }
                for (var r = 0; r < this.layers[i].height; r++)
                    for (var o = 0; o < this.layers[i].width; o++) {
                        var a = this.layers[i].data[r][o];
                        a && a.index === t && (e ? a.setCollision(!0, !0, !0, !0) : a.resetCollision(), a.faceTop = e, a.faceBottom = e, a.faceLeft = e, a.faceRight = e)
                    }
                return n && this.calculateFaces(i), i
            },
            getLayer: function(t) {
                return void 0 === t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof i.TilemapLayer && (t = t.index), t
            },
            setPreventRecalculate: function(t) {
                if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) {
                    for (var e in this.preventingRecalculate = !1, this.needToRecalculate) this.calculateFaces(e);
                    this.needToRecalculate = !1
                }
            },
            calculateFaces: function(t) {
                if (this.preventingRecalculate) this.needToRecalculate[t] = !0;
                else
                    for (var e = null, i = null, n = null, s = null, r = 0, o = this.layers[t].height; r < o; r++)
                        for (var a = 0, h = this.layers[t].width; a < h; a++) {
                            var l = this.layers[t].data[r][a];
                            l && (e = this.getTileAbove(t, a, r), i = this.getTileBelow(t, a, r), n = this.getTileLeft(t, a, r), s = this.getTileRight(t, a, r), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), n && n.collides && (l.faceLeft = !1), s && s.collides && (l.faceRight = !1))
                        }
            },
            getTileAbove: function(t, e, i) {
                return i > 0 ? this.layers[t].data[i - 1][e] : null
            },
            getTileBelow: function(t, e, i) {
                return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
            },
            getTileLeft: function(t, e, i) {
                return e > 0 ? this.layers[t].data[i][e - 1] : null
            },
            getTileRight: function(t, e, i) {
                return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
            },
            setLayer: function(t) {
                t = this.getLayer(t), this.layers[t] && (this.currentLayer = t)
            },
            hasTile: function(t, e, i) {
                return i = this.getLayer(i), void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && this.layers[i].data[e][t].index > -1
            },
            removeTile: function(t, e, n) {
                if (n = this.getLayer(n), t >= 0 && t < this.layers[n].width && e >= 0 && e < this.layers[n].height && this.hasTile(t, e, n)) {
                    var s = this.layers[n].data[e][t];
                    return this.layers[n].data[e][t] = new i.Tile(this.layers[n], -1, t, e, this.tileWidth, this.tileHeight), this.layers[n].dirty = !0, this.calculateFaces(n), s
                }
            },
            removeTileWorldXY: function(t, e, i, n, s) {
                return s = this.getLayer(s), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, n) / n, this.removeTile(t, e, s)
            },
            putTile: function(t, e, n, s) {
                return null === t ? this.removeTile(e, n, s) : (s = this.getLayer(s), e >= 0 && e < this.layers[s].width && n >= 0 && n < this.layers[s].height ? (t instanceof i.Tile ? (r = t.index, this.hasTile(e, n, s) ? this.layers[s].data[n][e].copy(t) : this.layers[s].data[n][e] = new i.Tile(s, r, e, n, t.width, t.height)) : (r = t, this.hasTile(e, n, s) ? this.layers[s].data[n][e].index = r : this.layers[s].data[n][e] = new i.Tile(this.layers[s], r, e, n, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(r) > -1 ? this.layers[s].data[n][e].setCollision(!0, !0, !0, !0) : this.layers[s].data[n][e].resetCollision(), this.layers[s].dirty = !0, this.calculateFaces(s), this.layers[s].data[n][e]) : null);
                var r
            },
            putTileWorldXY: function(t, e, i, n, s, r) {
                return r = this.getLayer(r), e = this.game.math.snapToFloor(e, n) / n, i = this.game.math.snapToFloor(i, s) / s, this.putTile(t, e, i, r)
            },
            searchTileIndex: function(t, e, i, n) {
                void 0 === e && (e = 0), void 0 === i && (i = !1), n = this.getLayer(n);
                var s = 0;
                if (i) {
                    for (var r = this.layers[n].height - 1; r >= 0; r--)
                        for (var o = this.layers[n].width - 1; o >= 0; o--)
                            if (this.layers[n].data[r][o].index === t) {
                                if (s === e) return this.layers[n].data[r][o];
                                s++
                            }
                } else
                    for (r = 0; r < this.layers[n].height; r++)
                        for (o = 0; o < this.layers[n].width; o++)
                            if (this.layers[n].data[r][o].index === t) {
                                if (s === e) return this.layers[n].data[r][o];
                                s++
                            } return null
            },
            getTile: function(t, e, i, n) {
                return void 0 === n && (n = !1), i = this.getLayer(i), t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? n ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null
            },
            getTileWorldXY: function(t, e, i, n, s, r) {
                return void 0 === i && (i = this.tileWidth), void 0 === n && (n = this.tileHeight), s = this.getLayer(s), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, n) / n, this.getTile(t, e, s, r)
            },
            copy: function(t, e, i, n, s) {
                if (s = this.getLayer(s), this.layers[s]) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.layers[s].width), void 0 === n && (n = this.layers[s].height), t < 0 && (t = 0), e < 0 && (e = 0), i > this.layers[s].width && (i = this.layers[s].width), n > this.layers[s].height && (n = this.layers[s].height), this._results.length = 0, this._results.push({
                        x: t,
                        y: e,
                        width: i,
                        height: n,
                        layer: s
                    });
                    for (var r = e; r < e + n; r++)
                        for (var o = t; o < t + i; o++) this._results.push(this.layers[s].data[r][o]);
                    return this._results
                }
                this._results.length = 0
            },
            paste: function(t, e, i, n) {
                if (void 0 === t && (t = 0), void 0 === e && (e = 0), n = this.getLayer(n), i && !(i.length < 2)) {
                    for (var s = t - i[1].x, r = e - i[1].y, o = 1; o < i.length; o++) this.layers[n].data[r + i[o].y][s + i[o].x].copy(i[o]);
                    this.layers[n].dirty = !0, this.calculateFaces(n)
                }
            },
            swap: function(t, e, i, n, s, r, o) {
                o = this.getLayer(o), this.copy(i, n, s, r, o), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, n, this._results, o))
            },
            swapHandler: function(t) {
                t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
            },
            forEach: function(t, e, i, n, s, r, o) {
                o = this.getLayer(o), this.copy(i, n, s, r, o), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, n, this._results, o))
            },
            replace: function(t, e, i, n, s, r, o) {
                if (o = this.getLayer(o), this.copy(i, n, s, r, o), !(this._results.length < 2)) {
                    for (var a = 1; a < this._results.length; a++) this._results[a].index === t && (this._results[a].index = e);
                    this.paste(i, n, this._results, o)
                }
            },
            random: function(t, e, i, n, s) {
                if (s = this.getLayer(s), this.copy(t, e, i, n, s), !(this._results.length < 2)) {
                    for (var r = [], o = 1; o < this._results.length; o++)
                        if (this._results[o].index) {
                            var a = this._results[o].index; - 1 === r.indexOf(a) && r.push(a)
                        }
                    for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(r);
                    this.paste(t, e, this._results, s)
                }
            },
            shuffle: function(t, e, n, s, r) {
                if (r = this.getLayer(r), this.copy(t, e, n, s, r), !(this._results.length < 2)) {
                    for (var o = [], a = 1; a < this._results.length; a++) this._results[a].index && o.push(this._results[a].index);
                    i.ArrayUtils.shuffle(o);
                    for (var h = 1; h < this._results.length; h++) this._results[h].index = o[h - 1];
                    this.paste(t, e, this._results, r)
                }
            },
            fill: function(t, e, i, n, s, r) {
                if (r = this.getLayer(r), this.copy(e, i, n, s, r), !(this._results.length < 2)) {
                    for (var o = 1; o < this._results.length; o++) this._results[o].index = t;
                    this.paste(e, i, this._results, r)
                }
            },
            removeAllLayers: function() {
                this.layers.length = 0, this.currentLayer = 0
            },
            dump: function() {
                for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                    for (var n = 0; n < this.layers[this.currentLayer].width; n++) t += "%c  ", this.layers[this.currentLayer].data[i][n] > 1 ? this.debugMap[this.layers[this.currentLayer].data[i][n]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][n]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                    t += "\n"
                }
                e[0] = t
            },
            destroy: function() {
                this.removeAllLayers(), this.data = [], this.game = null
            }
        }, i.Tilemap.prototype.constructor = i.Tilemap, Object.defineProperty(i.Tilemap.prototype, "layer", {
            get: function() {
                return this.layers[this.currentLayer]
            },
            set: function(t) {
                t !== this.currentLayer && this.setLayer(t)
            }
        }), i.TilemapLayer = function(t, e, n, s, r) {
            s |= 0, r |= 0, i.Sprite.call(this, t, 0, 0), this.map = e, this.index = n, this.layer = e.layers[n], this.canvas = PIXI.CanvasPool.create(this, s, r), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = i.TILEMAPLAYER, this.physicsType = i.TILEMAPLAYER, this.renderSettings = {
                enableScrollDelta: !1,
                overdrawRatio: .2,
                copyCanvas: null
            }, this.debug = !1, this.exists = !0, this.debugSettings = {
                missingImageFill: "rgb(255,255,255)",
                debuggedTileOverfill: "rgba(0,255,0,0.4)",
                forceFullRedraw: !0,
                debugAlpha: .5,
                facingEdgeStroke: "rgba(0,255,0,1)",
                collidingTileOverfill: "rgba(0,255,0,0.2)"
            }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
                scrollX: 0,
                scrollY: 0,
                renderWidth: 0,
                renderHeight: 0,
                tileWidth: e.tileWidth,
                tileHeight: e.tileHeight,
                cw: e.tileWidth,
                ch: e.tileHeight,
                tilesets: []
            }, this._scrollX = 0, this._scrollY = 0, this._results = [], t.device.canvasBitBltShift || (this.renderSettings.copyCanvas = i.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0
        }, i.TilemapLayer.prototype = Object.create(i.Sprite.prototype), i.TilemapLayer.prototype.constructor = i.TilemapLayer, i.TilemapLayer.prototype.preUpdateCore = i.Component.Core.preUpdate, i.TilemapLayer.sharedCopyCanvas = null, i.TilemapLayer.ensureSharedCopyCanvas = function() {
            return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas
        }, i.TilemapLayer.prototype.preUpdate = function() {
            return this.preUpdateCore()
        }, i.TilemapLayer.prototype.postUpdate = function() {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y
        }, i.TilemapLayer.prototype._renderCanvas = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, t)
        }, i.TilemapLayer.prototype._renderWebGL = function(t) {
            this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, t)
        }, i.TilemapLayer.prototype.destroy = function() {
            PIXI.CanvasPool.remove(this), i.Component.Destroy.prototype.destroy.call(this)
        }, i.TilemapLayer.prototype.resize = function(t, e) {
            this.canvas.width = t, this.canvas.height = e, this.texture.frame.resize(t, e), this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.texture.baseTexture.width = t, this.texture.baseTexture.height = e, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0
        }, i.TilemapLayer.prototype.resizeWorld = function() {
            this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
        }, i.TilemapLayer.prototype._fixX = function(t) {
            return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX)
        }, i.TilemapLayer.prototype._unfixX = function(t) {
            return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX)
        }, i.TilemapLayer.prototype._fixY = function(t) {
            return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY)
        }, i.TilemapLayer.prototype._unfixY = function(t) {
            return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY)
        }, i.TilemapLayer.prototype.getTileX = function(t) {
            return Math.floor(this._fixX(t) / this._mc.tileWidth)
        }, i.TilemapLayer.prototype.getTileY = function(t) {
            return Math.floor(this._fixY(t) / this._mc.tileHeight)
        }, i.TilemapLayer.prototype.getTileXY = function(t, e, i) {
            return i.x = this.getTileX(t), i.y = this.getTileY(e), i
        }, i.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, n) {
            e || (e = this.rayStepRate), void 0 === i && (i = !1), void 0 === n && (n = !1);
            var s = this.getTiles(t.x, t.y, t.width, t.height, i, n);
            if (0 === s.length) return [];
            for (var r = t.coordinatesOnLine(e), o = [], a = 0; a < s.length; a++)
                for (var h = 0; h < r.length; h++) {
                    var l = s[a],
                        c = r[h];
                    if (l.containsPoint(c[0], c[1])) {
                        o.push(l);
                        break
                    }
                }
            return o
        }, i.TilemapLayer.prototype.getTiles = function(t, e, i, n, s, r) {
            void 0 === s && (s = !1), void 0 === r && (r = !1);
            var o = !(s || r);
            t = this._fixX(t), e = this._fixY(e);
            for (var a = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - a, c = Math.ceil((e + n) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop();
            for (var u = h; u < h + c; u++)
                for (var d = a; d < a + l; d++) {
                    var p = this.layer.data[u];
                    p && p[d] && (o || p[d].isInteresting(s, r)) && this._results.push(p[d])
                }
            return this._results.slice()
        }, i.TilemapLayer.prototype.resolveTileset = function(t) {
            var e = this._mc.tilesets;
            if (t < 2e3)
                for (; e.length < t;) e.push(void 0);
            var i = this.map.tiles[t] && this.map.tiles[t][2];
            if (null !== i) {
                var n = this.map.tilesets[i];
                if (n && n.containsTileIndex(t)) return e[t] = n
            }
            return e[t] = null
        }, i.TilemapLayer.prototype.resetTilesetCache = function() {
            for (var t = this._mc.tilesets; t.length;) t.pop()
        }, i.TilemapLayer.prototype.setScale = function(t, e) {
            t = t || 1, e = e || t;
            for (var i = 0; i < this.layer.data.length; i++)
                for (var n = this.layer.data[i], s = 0; s < n.length; s++) {
                    var r = n[s];
                    r.width = this.map.tileWidth * t, r.height = this.map.tileHeight * e, r.worldX = r.x * r.width, r.worldY = r.y * r.height
                }
            this.scale.setTo(t, e)
        }, i.TilemapLayer.prototype.shiftCanvas = function(t, e, i) {
            var n = t.canvas,
                s = n.width - Math.abs(e),
                r = n.height - Math.abs(i),
                o = 0,
                a = 0,
                h = e,
                l = i;
            e < 0 && (o = -e, h = 0), i < 0 && (a = -i, l = 0);
            var c = this.renderSettings.copyCanvas;
            if (c) {
                (c.width < s || c.height < r) && (c.width = s, c.height = r);
                var u = c.getContext("2d");
                u.clearRect(0, 0, s, r), u.drawImage(n, o, a, s, r, 0, 0, s, r), t.clearRect(h, l, s, r), t.drawImage(c, 0, 0, s, r, h, l, s, r)
            } else t.save(), t.globalCompositeOperation = "copy", t.drawImage(n, o, a, s, r, h, l, s, r), t.restore()
        }, i.TilemapLayer.prototype.renderRegion = function(t, e, i, n, s, r) {
            var o = this.context,
                a = this.layer.width,
                h = this.layer.height,
                l = this._mc.tileWidth,
                c = this._mc.tileHeight,
                u = this._mc.tilesets,
                d = NaN;
            this._wrap || (i <= s && (i = Math.max(0, i), s = Math.min(a - 1, s)), n <= r && (n = Math.max(0, n), r = Math.min(h - 1, r)));
            var p, f, g, m, y, v, b = i * l - t,
                x = (i + (1 << 20) * a) % a;
            for (m = (n + (1 << 20) * h) % h, v = r - n, f = n * c - e; v >= 0; m++, v--, f += c) {
                m >= h && (m -= h);
                var w = this.layer.data[m];
                for (g = x, y = s - i, p = b; y >= 0; g++, y--, p += l) {
                    g >= a && (g -= a);
                    var _ = w[g];
                    if (_ && !(_.index < 0)) {
                        var P = _.index,
                            T = u[P];
                        void 0 === T && (T = this.resolveTileset(P)), _.alpha === d || this.debug || (o.globalAlpha = _.alpha, d = _.alpha), T ? _.rotation || _.flipped ? (o.save(), o.translate(p + _.centerX, f + _.centerY), o.rotate(_.rotation), _.flipped && o.scale(-1, 1), T.draw(o, -_.centerX, -_.centerY, P), o.restore()) : T.draw(o, p, f, P) : this.debugSettings.missingImageFill && (o.fillStyle = this.debugSettings.missingImageFill, o.fillRect(p, f, l, c)), _.debug && this.debugSettings.debuggedTileOverfill && (o.fillStyle = this.debugSettings.debuggedTileOverfill, o.fillRect(p, f, l, c))
                    }
                }
            }
        }, i.TilemapLayer.prototype.renderDeltaScroll = function(t, e) {
            var i = this._mc.scrollX,
                n = this._mc.scrollY,
                s = this.canvas.width,
                r = this.canvas.height,
                o = this._mc.tileWidth,
                a = this._mc.tileHeight,
                h = 0,
                l = -o,
                c = 0,
                u = -a;
            if (t < 0 ? (h = s + t, l = s - 1) : t > 0 && (l = t), e < 0 ? (c = r + e, u = r - 1) : e > 0 && (u = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / o), l = Math.floor((l + i) / o), c = Math.floor((c + n) / a), u = Math.floor((u + n) / a), h <= l) {
                this.context.clearRect(h * o - i, 0, (l - h + 1) * o, r);
                var d = Math.floor((0 + n) / a),
                    p = Math.floor((r - 1 + n) / a);
                this.renderRegion(i, n, h, d, l, p)
            }
            if (c <= u) {
                this.context.clearRect(0, c * a - n, s, (u - c + 1) * a);
                var f = Math.floor((0 + i) / o),
                    g = Math.floor((s - 1 + i) / o);
                this.renderRegion(i, n, f, c, g, u)
            }
        }, i.TilemapLayer.prototype.renderFull = function() {
            var t = this._mc.scrollX,
                e = this._mc.scrollY,
                i = this.canvas.width,
                n = this.canvas.height,
                s = this._mc.tileWidth,
                r = this._mc.tileHeight,
                o = Math.floor(t / s),
                a = Math.floor((i - 1 + t) / s),
                h = Math.floor(e / r),
                l = Math.floor((n - 1 + e) / r);
            this.context.clearRect(0, 0, i, n), this.renderRegion(t, e, o, h, a, l)
        }, i.TilemapLayer.prototype.render = function() {
            var t = !1;
            if (this.visible) {
                (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, t = !0);
                var e = this.canvas.width,
                    i = this.canvas.height,
                    n = 0 | this._scrollX,
                    s = 0 | this._scrollY,
                    r = this._mc,
                    o = r.scrollX - n,
                    a = r.scrollY - s;
                if (t || 0 !== o || 0 !== a || r.renderWidth !== e || r.renderHeight !== i) return this.context.save(), r.scrollX = n, r.scrollY = s, r.renderWidth === e && r.renderHeight === i || (r.renderWidth = e, r.renderHeight = i), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)), !t && this.renderSettings.enableScrollDelta && Math.abs(o) + Math.abs(a) < Math.min(e, i) ? this.renderDeltaScroll(o, a) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
            }
        }, i.TilemapLayer.prototype.renderDebug = function() {
            var t, e, i, n, s, r, o = this._mc.scrollX,
                a = this._mc.scrollY,
                h = this.context,
                l = this.canvas.width,
                c = this.canvas.height,
                u = this.layer.width,
                d = this.layer.height,
                p = this._mc.tileWidth,
                f = this._mc.tileHeight,
                g = Math.floor(o / p),
                m = Math.floor((l - 1 + o) / p),
                y = Math.floor(a / f),
                v = Math.floor((c - 1 + a) / f),
                b = g * p - o,
                x = y * f - a,
                w = (g + (1 << 20) * u) % u,
                _ = (y + (1 << 20) * d) % d;
            for (h.strokeStyle = this.debugSettings.facingEdgeStroke, n = _, r = v - y, e = x; r >= 0; n++, r--, e += f) {
                n >= d && (n -= d);
                var P = this.layer.data[n];
                for (i = w, s = m - g, t = b; s >= 0; i++, s--, t += p) {
                    i >= u && (i -= u);
                    var T = P[i];
                    !T || T.index < 0 || !T.collides || (this.debugSettings.collidingTileOverfill && (h.fillStyle = this.debugSettings.collidingTileOverfill, h.fillRect(t, e, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (h.beginPath(), T.faceTop && (h.moveTo(t, e), h.lineTo(t + this._mc.cw, e)), T.faceBottom && (h.moveTo(t, e + this._mc.ch), h.lineTo(t + this._mc.cw, e + this._mc.ch)), T.faceLeft && (h.moveTo(t, e), h.lineTo(t, e + this._mc.ch)), T.faceRight && (h.moveTo(t + this._mc.cw, e), h.lineTo(t + this._mc.cw, e + this._mc.ch)), h.closePath(), h.stroke()))
                }
            }
        }, Object.defineProperty(i.TilemapLayer.prototype, "wrap", {
            get: function() {
                return this._wrap
            },
            set: function(t) {
                this._wrap = t, this.dirty = !0
            }
        }), Object.defineProperty(i.TilemapLayer.prototype, "scrollX", {
            get: function() {
                return this._scrollX
            },
            set: function(t) {
                this._scrollX = t
            }
        }), Object.defineProperty(i.TilemapLayer.prototype, "scrollY", {
            get: function() {
                return this._scrollY
            },
            set: function(t) {
                this._scrollY = t
            }
        }), Object.defineProperty(i.TilemapLayer.prototype, "collisionWidth", {
            get: function() {
                return this._mc.cw
            },
            set: function(t) {
                this._mc.cw = 0 | t, this.dirty = !0
            }
        }), Object.defineProperty(i.TilemapLayer.prototype, "collisionHeight", {
            get: function() {
                return this._mc.ch
            },
            set: function(t) {
                this._mc.ch = 0 | t, this.dirty = !0
            }
        }), i.TilemapParser = {
            INSERT_NULL: !1,
            parse: function(t, e, n, s, r, o) {
                if (void 0 === n && (n = 32), void 0 === s && (s = 32), void 0 === r && (r = 10), void 0 === o && (o = 10), void 0 === e) return this.getEmptyData();
                if (null === e) return this.getEmptyData(n, s, r, o);
                var a = t.cache.getTilemapData(e);
                if (a) {
                    if (a.format === i.Tilemap.CSV) return this.parseCSV(e, a.data, n, s);
                    if (!a.format || a.format === i.Tilemap.TILED_JSON) return this.parseTiledJSON(a.data)
                }
            },
            parseCSV: function(t, e, n, s) {
                for (var r = this.getEmptyData(), o = [], a = (e = e.trim()).split("\n"), h = a.length, l = 0, c = 0; c < a.length; c++) {
                    o[c] = [];
                    for (var u = a[c].split(","), d = 0; d < u.length; d++) o[c][d] = new i.Tile(r.layers[0], parseInt(u[d], 10), d, c, n, s);
                    0 === l && (l = u.length)
                }
                return r.format = i.Tilemap.CSV, r.name = t, r.width = l, r.height = h, r.tileWidth = n, r.tileHeight = s, r.widthInPixels = l * n, r.heightInPixels = h * s, r.layers[0].width = l, r.layers[0].height = h, r.layers[0].widthInPixels = r.widthInPixels, r.layers[0].heightInPixels = r.heightInPixels, r.layers[0].data = o, r
            },
            getEmptyData: function(t, e, i, n) {
                return {
                    width: void 0 !== i && null !== i ? i : 0,
                    height: void 0 !== n && null !== n ? n : 0,
                    tileWidth: void 0 !== t && null !== t ? t : 0,
                    tileHeight: void 0 !== e && null !== e ? e : 0,
                    orientation: "orthogonal",
                    version: "1",
                    properties: {},
                    widthInPixels: 0,
                    heightInPixels: 0,
                    layers: [{
                        name: "layer",
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        widthInPixels: 0,
                        heightInPixels: 0,
                        alpha: 1,
                        visible: !0,
                        properties: {},
                        indexes: [],
                        callbacks: [],
                        bodies: [],
                        data: []
                    }],
                    images: [],
                    objects: {},
                    collision: {},
                    tilesets: [],
                    tiles: []
                }
            },
            parseTiledJSON: function(t) {
                if ("orthogonal" !== t.orientation) return null;
                for (var e = {
                        width: t.width,
                        height: t.height,
                        tileWidth: t.tilewidth,
                        tileHeight: t.tileheight,
                        orientation: t.orientation,
                        format: i.Tilemap.TILED_JSON,
                        version: t.version,
                        properties: t.properties,
                        widthInPixels: t.width * t.tilewidth,
                        heightInPixels: t.height * t.tileheight
                    }, n = [], s = 0; s < t.layers.length; s++)
                    if ("tilelayer" === t.layers[s].type) {
                        var r = t.layers[s];
                        if (!r.compression && r.encoding && "base64" === r.encoding) {
                            for (var o = window.atob(r.data), a = o.length, h = new Array(a), l = 0; l < a; l += 4) h[l / 4] = (o.charCodeAt(l) | o.charCodeAt(l + 1) << 8 | o.charCodeAt(l + 2) << 16 | o.charCodeAt(l + 3) << 24) >>> 0;
                            r.data = h, delete r.encoding
                        } else if (r.compression) continue;
                        var c = {
                            name: r.name,
                            x: r.x,
                            y: r.y,
                            width: r.width,
                            height: r.height,
                            widthInPixels: r.width * t.tilewidth,
                            heightInPixels: r.height * t.tileheight,
                            alpha: r.opacity,
                            visible: r.visible,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: []
                        };
                        r.properties && (c.properties = r.properties);
                        var u, d, p, f = 0,
                            g = [],
                            m = [],
                            y = 0;
                        for (a = r.data.length; y < a; y++) {
                            if (u = 0, d = !1, p = 0, (A = r.data[y]) > 536870912) switch (A > 2147483648 && (A -= 2147483648, p += 4), A > 1073741824 && (A -= 1073741824, p += 2), A > 536870912 && (A -= 536870912, p += 1), p) {
                                case 5:
                                    u = Math.PI / 2;
                                    break;
                                case 6:
                                    u = Math.PI;
                                    break;
                                case 3:
                                    u = 3 * Math.PI / 2;
                                    break;
                                case 4:
                                    u = 0, d = !0;
                                    break;
                                case 7:
                                    u = Math.PI / 2, d = !0;
                                    break;
                                case 2:
                                    u = Math.PI, d = !0;
                                    break;
                                case 1:
                                    u = 3 * Math.PI / 2, d = !0
                            }
                            if (A > 0)(E = new i.Tile(c, A, f, m.length, t.tilewidth, t.tileheight)).rotation = u, E.flipped = d, 0 !== p && (E.flippedVal = p), g.push(E);
                            else i.TilemapParser.INSERT_NULL ? g.push(null) : g.push(new i.Tile(c, -1, f, m.length, t.tilewidth, t.tileheight));
                            ++f === r.width && (m.push(g), f = 0, g = [])
                        }
                        c.data = m, n.push(c)
                    }
                e.layers = n;
                var v = [];
                for (s = 0; s < t.layers.length; s++)
                    if ("imagelayer" === t.layers[s].type) {
                        var b = t.layers[s],
                            x = {
                                name: b.name,
                                image: b.image,
                                x: b.x,
                                y: b.y,
                                alpha: b.opacity,
                                visible: b.visible,
                                properties: {}
                            };
                        b.properties && (x.properties = b.properties), v.push(x)
                    }
                e.images = v;
                var w = [],
                    _ = [],
                    P = null;
                for (s = 0; s < t.tilesets.length; s++) {
                    if ((D = t.tilesets[s]).image) {
                        var T = new i.Tileset(D.name, D.firstgid, D.tilewidth, D.tileheight, D.margin, D.spacing, D.properties);
                        D.tileproperties && (T.tileProperties = D.tileproperties), T.updateTileData(D.imagewidth, D.imageheight), w.push(T)
                    } else {
                        var S = new i.ImageCollection(D.name, D.firstgid, D.tilewidth, D.tileheight, D.margin, D.spacing, D.properties);
                        for (var C in D.tiles) {
                            x = D.tiles[C].image;
                            var A = D.firstgid + parseInt(C, 10);
                            S.addImage(A, x)
                        }
                        _.push(S)
                    }
                    P && (P.lastgid = D.firstgid - 1), P = D
                }
                e.tilesets = w, e.imagecollections = _;
                var E, M, I = {},
                    O = {};

                function k(t, e) {
                    var i = {};
                    for (var n in e) {
                        var s = e[n];
                        void 0 !== t[s] && (i[s] = t[s])
                    }
                    return i
                }
                for (s = 0; s < t.layers.length; s++)
                    if ("objectgroup" === t.layers[s].type) {
                        var R = t.layers[s];
                        I[R.name] = [], O[R.name] = [];
                        var L = 0;
                        for (a = R.objects.length; L < a; L++)
                            if (R.objects[L].gid) {
                                var B = {
                                    gid: R.objects[L].gid,
                                    name: R.objects[L].name,
                                    type: R.objects[L].hasOwnProperty("type") ? R.objects[L].type : "",
                                    x: R.objects[L].x,
                                    y: R.objects[L].y,
                                    visible: R.objects[L].visible,
                                    properties: R.objects[L].properties
                                };
                                R.objects[L].rotation && (B.rotation = R.objects[L].rotation), I[R.name].push(B)
                            } else if (R.objects[L].polyline) {
                            B = {
                                name: R.objects[L].name,
                                type: R.objects[L].type,
                                x: R.objects[L].x,
                                y: R.objects[L].y,
                                width: R.objects[L].width,
                                height: R.objects[L].height,
                                visible: R.objects[L].visible,
                                properties: R.objects[L].properties
                            };
                            R.objects[L].rotation && (B.rotation = R.objects[L].rotation), B.polyline = [];
                            for (var F = 0; F < R.objects[L].polyline.length; F++) B.polyline.push([R.objects[L].polyline[F].x, R.objects[L].polyline[F].y]);
                            O[R.name].push(B), I[R.name].push(B)
                        } else if (R.objects[L].polygon) {
                            (B = k(R.objects[L], ["name", "type", "x", "y", "visible", "rotation", "properties"])).polygon = [];
                            for (F = 0; F < R.objects[L].polygon.length; F++) B.polygon.push([R.objects[L].polygon[F].x, R.objects[L].polygon[F].y]);
                            I[R.name].push(B)
                        } else if (R.objects[L].ellipse) {
                            B = k(R.objects[L], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            I[R.name].push(B)
                        } else {
                            (B = k(R.objects[L], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"])).rectangle = !0, I[R.name].push(B)
                        }
                    }
                e.objects = I, e.collision = O, e.tiles = [];
                for (s = 0; s < e.tilesets.length; s++) {
                    f = (D = e.tilesets[s]).tileMargin;
                    var D, U = D.tileMargin,
                        G = 0,
                        N = 0,
                        X = 0;
                    for (y = D.firstgid; y < D.firstgid + D.total && (e.tiles[y] = [f, U, s], f += D.tileWidth + D.tileSpacing, ++G !== D.total) && (++N !== D.columns || (f = D.tileMargin, U += D.tileHeight + D.tileSpacing, N = 0, ++X !== D.rows)); y++);
                }
                for (s = 0; s < e.layers.length; s++) {
                    c = e.layers[s], D = null;
                    for (l = 0; l < c.data.length; l++) {
                        g = c.data[l];
                        for (var j = 0; j < g.length; j++) null === (E = g[j]) || E.index < 0 || (M = e.tiles[E.index][2], (D = e.tilesets[M]).tileProperties && D.tileProperties[E.index - D.firstgid] && (E.properties = i.Utils.mixin(D.tileProperties[E.index - D.firstgid], E.properties)))
                    }
                }
                return e
            }
        }, i.Tileset = function(t, e, i, n, s, r, o) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.tileWidth = 0 | i, this.tileHeight = 0 | n, this.tileMargin = 0 | s, this.tileSpacing = 0 | r, this.properties = o || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
        }, i.Tileset.prototype = {
            draw: function(t, e, i, n) {
                var s = n - this.firstgid << 1;
                s >= 0 && s + 1 < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[s], this.drawCoords[s + 1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
            },
            containsTileIndex: function(t) {
                return t >= this.firstgid && t < this.firstgid + this.total
            },
            setImage: function(t) {
                this.image = t, this.updateTileData(t.width, t.height)
            },
            setSpacing: function(t, e) {
                this.tileMargin = 0 | t, this.tileSpacing = 0 | e, this.image && this.updateTileData(this.image.width, this.image.height)
            },
            updateTileData: function(t, e) {
                var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                    n = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                i = Math.floor(i), n = Math.floor(n), this.rows && this.rows !== i || this.columns && this.columns, this.rows = i, this.columns = n, this.total = i * n, this.drawCoords.length = 0;
                for (var s = this.tileMargin, r = this.tileMargin, o = 0; o < this.rows; o++) {
                    for (var a = 0; a < this.columns; a++) this.drawCoords.push(s), this.drawCoords.push(r), s += this.tileWidth + this.tileSpacing;
                    s = this.tileMargin, r += this.tileHeight + this.tileSpacing
                }
            }
        }, i.Tileset.prototype.constructor = i.Tileset, i.Particle = function(t, e, n, s, r) {
            i.Sprite.call(this, t, e, n, s, r), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
        }, i.Particle.prototype = Object.create(i.Sprite.prototype), i.Particle.prototype.constructor = i.Particle, i.Particle.prototype.update = function() {
            this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
        }, i.Particle.prototype.onEmit = function() {}, i.Particle.prototype.setAlphaData = function(t) {
            this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
        }, i.Particle.prototype.setScaleData = function(t) {
            this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
        }, i.Particle.prototype.reset = function(t, e, n) {
            return i.Component.Reset.prototype.reset.call(this, t, e, n), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
        }, i.Particles = function(t) {
            this.game = t, this.emitters = {}, this.ID = 0
        }, i.Particles.prototype = {
            add: function(t) {
                return this.emitters[t.name] = t, t
            },
            remove: function(t) {
                delete this.emitters[t.name]
            },
            update: function() {
                for (var t in this.emitters) this.emitters[t].exists && this.emitters[t].update()
            }
        }, i.Particles.prototype.constructor = i.Particles, i.Particles.Arcade = {}, i.Particles.Arcade.Emitter = function(t, e, n, s) {
            this.maxParticles = s || 50, i.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = i.EMITTER, this.physicsType = i.GROUP, this.area = new i.Rectangle(e, n, 1, 1), this.minParticleSpeed = new i.Point(-100, -100), this.maxParticleSpeed = new i.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = i.Particle, this.particleDrag = new i.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new i.Point, this.on = !1, this.particleAnchor = new i.Point(.5, .5), this.blendMode = i.blendModes.NORMAL, this.emitX = e, this.emitY = n, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new i.Point(1, 1), this._maxParticleScale = new i.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
        }, i.Particles.Arcade.Emitter.prototype = Object.create(i.Group.prototype), i.Particles.Arcade.Emitter.prototype.constructor = i.Particles.Arcade.Emitter, i.Particles.Arcade.Emitter.prototype.update = function() {
            if (this.on && this.game.time.time >= this._timer)
                if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                    if (this._flowQuantity > 0) {
                        for (var t = 0; t < this._flowQuantity; t++)
                            if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                                this.on = !1;
                                break
                            }
                    } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
            else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
            for (t = this.children.length; t--;) this.children[t].exists && this.children[t].update()
        }, i.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, n, s) {
            var r;
            void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === n && (n = !1), void 0 === s && (s = !1);
            var o = 0,
                a = t,
                h = e;
            for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); o < i;) Array.isArray(t) && (a = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), r = new this.particleClass(this.game, 0, 0, a, h), this.game.physics.arcade.enable(r, !1), n ? (r.body.checkCollision.any = !0, r.body.checkCollision.none = !1) : r.body.checkCollision.none = !0, r.body.collideWorldBounds = s, r.body.skipQuadTree = !0, r.exists = !1, r.visible = !1, r.anchor.copyFrom(this.particleAnchor), this.add(r), o++;
            return this
        }, i.Particles.Arcade.Emitter.prototype.kill = function() {
            return this.on = !1, this.alive = !1, this.exists = !1, this
        }, i.Particles.Arcade.Emitter.prototype.revive = function() {
            return this.alive = !0, this.exists = !0, this
        }, i.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
            return this._flowTotal = 0, this.start(!0, t, 0, e, !1), this
        }, i.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, n, s) {
            return void 0 !== i && 0 !== i || (i = 1), void 0 === n && (n = -1), void 0 === s && (s = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = n, s ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this
        }, i.Particles.Arcade.Emitter.prototype.start = function(t, e, i, n, s) {
            if (void 0 === t && (t = !0), void 0 === e && (e = 0), void 0 !== i && null !== i || (i = 250), void 0 === n && (n = 0), void 0 === s && (s = !1), n > this.maxParticles && (n = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || s)
                for (var r = 0; r < n; r++) this.emitParticle();
            else this.on = !0, this._quantity = n, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion;
            return this
        }, i.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, n) {
            void 0 === t && (t = null), void 0 === e && (e = null);
            var s = this.getFirstExists(!1);
            if (null === s) return !1;
            var r = this.game.rnd;
            void 0 !== i && void 0 !== n ? s.loadTexture(i, n) : void 0 !== i && s.loadTexture(i);
            var o = this.emitX,
                a = this.emitY;
            null !== t ? o = t : this.width > 1 && (o = r.between(this.left, this.right)), null !== e ? a = e : this.height > 1 && (a = r.between(this.top, this.bottom)), s.reset(o, a), s.angle = 0, s.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(s) : this.particleSendToBack && this.sendToBack(s), this.autoScale ? s.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? s.scale.set(r.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || s.scale.set(r.realInRange(this._minParticleScale.x, this._maxParticleScale.x), r.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === n && (Array.isArray(this._frames) ? s.frame = this.game.rnd.pick(this._frames) : s.frame = this._frames), this.autoAlpha ? s.setAlphaData(this.alphaData) : s.alpha = r.realInRange(this.minParticleAlpha, this.maxParticleAlpha), s.blendMode = this.blendMode;
            var h = s.body;
            return h.updateBounds(), h.bounce.copyFrom(this.bounce), h.drag.copyFrom(this.particleDrag), h.velocity.x = r.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), h.velocity.y = r.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), h.angularVelocity = r.between(this.minRotation, this.maxRotation), h.gravity.y = this.gravity, h.angularDrag = this.angularDrag, s.onEmit(), !0
        }, i.Particles.Arcade.Emitter.prototype.destroy = function() {
            this.game.particles.remove(this), i.Group.prototype.destroy.call(this, !0, !1)
        }, i.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
            return this.area.width = t, this.area.height = e, this
        }, i.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this
        }, i.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
            return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this
        }, i.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
            return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this
        }, i.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, n, s, r) {
            if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === n && (n = 0), void 0 === s && (s = i.Easing.Linear.None), void 0 === r && (r = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, n > 0 && t !== e) {
                var o = {
                        v: t
                    },
                    a = this.game.make.tween(o).to({
                        v: e
                    }, n, s);
                a.yoyo(r), this.alphaData = a.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
            }
            return this
        }, i.Particles.Arcade.Emitter.prototype.setScale = function(t, e, n, s, r, o, a) {
            if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === s && (s = 1), void 0 === r && (r = 0), void 0 === o && (o = i.Easing.Linear.None), void 0 === a && (a = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, n), this._maxParticleScale.set(e, s), this.autoScale = !1, r > 0 && (t !== e || n !== s)) {
                var h = {
                        x: t,
                        y: n
                    },
                    l = this.game.make.tween(h).to({
                        x: e,
                        y: s
                    }, r, o);
                l.yoyo(a), this.scaleData = l.generateData(60), this.scaleData.reverse(), this.autoScale = !0
            }
            return this
        }, i.Particles.Arcade.Emitter.prototype.at = function(t) {
            return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this
        }, Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "width", {
            get: function() {
                return this.area.width
            },
            set: function(t) {
                this.area.width = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "height", {
            get: function() {
                return this.area.height
            },
            set: function(t) {
                this.area.height = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "x", {
            get: function() {
                return this.emitX
            },
            set: function(t) {
                this.emitX = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "y", {
            get: function() {
                return this.emitY
            },
            set: function(t) {
                this.emitY = t
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "left", {
            get: function() {
                return Math.floor(this.x - this.area.width / 2)
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "right", {
            get: function() {
                return Math.floor(this.x + this.area.width / 2)
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "top", {
            get: function() {
                return Math.floor(this.y - this.area.height / 2)
            }
        }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "bottom", {
            get: function() {
                return Math.floor(this.y + this.area.height / 2)
            }
        }), i.Weapon = function(t, e) {
            i.Plugin.call(this, t, e), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new i.Rectangle(0, 0, 1, 1), this.fireAngle = i.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new i.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = i.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = i.Weapon.KILL_WORLD_BOUNDS, this._data = {
                customBody: !1,
                width: 0,
                height: 0,
                offsetX: 0,
                offsetY: 0
            }, this.bounds = new i.Rectangle, this.bulletBounds = t.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new i.Signal, this.onKill = new i.Signal, this.onFireLimit = new i.Signal, this.trackedSprite = null, this.trackedPointer = null, this.trackRotation = !1, this.trackOffset = new i.Point, this._nextFire = 0, this._rotatedPoint = new i.Point
        }, i.Weapon.prototype = Object.create(i.Plugin.prototype), i.Weapon.prototype.constructor = i.Weapon, i.Weapon.KILL_NEVER = 0, i.Weapon.KILL_LIFESPAN = 1, i.Weapon.KILL_DISTANCE = 2, i.Weapon.KILL_WEAPON_BOUNDS = 3, i.Weapon.KILL_CAMERA_BOUNDS = 4, i.Weapon.KILL_WORLD_BOUNDS = 5, i.Weapon.KILL_STATIC_BOUNDS = 6, i.Weapon.prototype.createBullets = function(t, e, n, s) {
            return void 0 === t && (t = 1), void 0 === s && (s = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(i.Physics.ARCADE, s), this.bullets.classType = this._bulletClass), 0 !== t && (-1 === t && (this.autoExpandBulletsGroup = !0, t = 1), this.bullets.createMultiple(t, e, n), this.bullets.setAll("data.bulletManager", this), this.bulletKey = e, this.bulletFrame = n), this
        }, i.Weapon.prototype.forEach = function(t, e) {
            return this.bullets.forEachExists(t, e, arguments), this
        }, i.Weapon.prototype.pauseAll = function() {
            return this.bullets.setAll("body.enable", !1), this
        }, i.Weapon.prototype.resumeAll = function() {
            return this.bullets.setAll("body.enable", !0), this
        }, i.Weapon.prototype.killAll = function() {
            return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this
        }, i.Weapon.prototype.resetShots = function(t) {
            return this.shots = 0, void 0 !== t && (this.fireLimit = t), this
        }, i.Weapon.prototype.destroy = function() {
            this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1
        }, i.Weapon.prototype.update = function() {
            this._bulletKillType === i.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire()
        }, i.Weapon.prototype.trackSprite = function(t, e, i, n) {
            return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = !1), this.trackedPointer = null, this.trackedSprite = t, this.trackRotation = n, this.trackOffset.set(e, i), this
        }, i.Weapon.prototype.trackPointer = function(t, e, i) {
            return void 0 === t && (t = this.game.input.activePointer), void 0 === e && (e = 0), void 0 === i && (i = 0), this.trackedPointer = t, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(e, i), this
        }, i.Weapon.prototype.fire = function(t, e, n) {
            if (this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return !1;
            var s = this.bulletSpeed;
            0 !== this.bulletSpeedVariance && (s += i.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), t ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(t.x, t.y) : (this.fireFrom.x = t.x, this.fireFrom.y = t.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (s += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y));
            var r = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x,
                o = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y,
                a = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
            void 0 !== e && void 0 !== n && (a = this.game.math.radToDeg(Math.atan2(n - o, e - r))), 0 !== this.bulletAngleVariance && (a += i.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
            var h = 0,
                l = 0;
            0 === a || 180 === a ? h = Math.cos(this.game.math.degToRad(a)) * s : 90 === a || 270 === a ? l = Math.sin(this.game.math.degToRad(a)) * s : (h = Math.cos(this.game.math.degToRad(a)) * s, l = Math.sin(this.game.math.degToRad(a)) * s);
            var c = null;
            if (this.autoExpandBulletsGroup ? (c = this.bullets.getFirstExists(!1, !0, r, o, this.bulletKey, this.bulletFrame)).data.bulletManager = this : c = this.bullets.getFirstExists(!1), c) {
                if (c.reset(r, o), c.data.fromX = r, c.data.fromY = o, c.data.killType = this.bulletKillType, c.data.killDistance = this.bulletKillDistance, c.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === i.Weapon.KILL_LIFESPAN && (c.lifespan = this.bulletLifespan), c.angle = a + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                    if (null === c.animations.getAnimation(this.bulletAnimation)) {
                        var u = this.anims[this.bulletAnimation];
                        c.animations.add(u.name, u.frames, u.frameRate, u.loop, u.useNumericIndex)
                    }
                    c.animations.play(this.bulletAnimation)
                } else this.bulletFrameCycle ? (c.frame = this.bulletFrames[this.bulletFrameIndex], this.bulletFrameIndex++, this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (c.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
                if (c.data.bodyDirty && (this._data.customBody && c.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), c.body.collideWorldBounds = this.bulletCollideWorldBounds, c.data.bodyDirty = !1), c.body.velocity.set(h, l), c.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y), 0 !== this.bulletSpeedVariance) {
                    var d = this.fireRate;
                    (d += i.Math.between(-this.fireRateVariance, this.fireRateVariance)) < 0 && (d = 0), this._nextFire = this.game.time.now + d
                } else this._nextFire = this.game.time.now + this.fireRate;
                this.shots++, this.onFire.dispatch(c, this, s), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
            }
            return c
        }, i.Weapon.prototype.fireAtPointer = function(t) {
            return void 0 === t && (t = this.game.input.activePointer), this.fire(null, t.worldX, t.worldY)
        }, i.Weapon.prototype.fireAtSprite = function(t) {
            return this.fire(null, t.world.x, t.world.y)
        }, i.Weapon.prototype.fireAtXY = function(t, e) {
            return this.fire(null, t, e)
        }, i.Weapon.prototype.setBulletBodyOffset = function(t, e, i, n) {
            return void 0 === i && (i = 0), void 0 === n && (n = 0), this._data.customBody = !0, this._data.width = t, this._data.height = e, this._data.offsetX = i, this._data.offsetY = n, this.bullets.callAll("body.setSize", "body", t, e, i, n), this.bullets.setAll("data.bodyDirty", !1), this
        }, i.Weapon.prototype.setBulletFrames = function(t, e, n, s) {
            return void 0 === n && (n = !0), void 0 === s && (s = !1), this.bulletFrames = i.ArrayUtils.numberArray(t, e), this.bulletFrameIndex = 0, this.bulletFrameCycle = n, this.bulletFrameRandom = s, this
        }, i.Weapon.prototype.addBulletAnimation = function(t, e, i, n, s) {
            return this.anims[t] = {
                name: t,
                frames: e,
                frameRate: i,
                loop: n,
                useNumericIndex: s
            }, this.bullets.callAll("animations.add", "animations", t, e, i, n, s), this.bulletAnimation = t, this
        }, i.Weapon.prototype.debug = function(t, e, i) {
            void 0 === t && (t = 16), void 0 === e && (e = 32), void 0 === i && (i = !1), this.game.debug.text("Weapon Plugin", t, e), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24), i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
        }, Object.defineProperty(i.Weapon.prototype, "bulletClass", {
            get: function() {
                return this._bulletClass
            },
            set: function(t) {
                this._bulletClass = t, this.bullets.classType = this._bulletClass
            }
        }), Object.defineProperty(i.Weapon.prototype, "bulletKillType", {
            get: function() {
                return this._bulletKillType
            },
            set: function(t) {
                switch (t) {
                    case i.Weapon.KILL_STATIC_BOUNDS:
                    case i.Weapon.KILL_WEAPON_BOUNDS:
                        this.bulletBounds = this.bounds;
                        break;
                    case i.Weapon.KILL_CAMERA_BOUNDS:
                        this.bulletBounds = this.game.camera.view;
                        break;
                    case i.Weapon.KILL_WORLD_BOUNDS:
                        this.bulletBounds = this.game.world.bounds
                }
                this._bulletKillType = t
            }
        }), Object.defineProperty(i.Weapon.prototype, "bulletCollideWorldBounds", {
            get: function() {
                return this._bulletCollideWorldBounds
            },
            set: function(t) {
                this._bulletCollideWorldBounds = t, this.bullets.setAll("body.collideWorldBounds", t), this.bullets.setAll("data.bodyDirty", !1)
            }
        }), Object.defineProperty(i.Weapon.prototype, "x", {
            get: function() {
                return this.fireFrom.x
            },
            set: function(t) {
                this.fireFrom.x = t
            }
        }), Object.defineProperty(i.Weapon.prototype, "y", {
            get: function() {
                return this.fireFrom.y
            },
            set: function(t) {
                this.fireFrom.y = t
            }
        }), i.Bullet = function(t, e, n, s, r) {
            i.Sprite.call(this, t, e, n, s, r), this.anchor.set(.5), this.data = {
                bulletManager: null,
                fromX: 0,
                fromY: 0,
                bodyDirty: !0,
                rotateToVelocity: !1,
                killType: 0,
                killDistance: 0
            }
        }, i.Bullet.prototype = Object.create(i.Sprite.prototype), i.Bullet.prototype.constructor = i.Bullet, i.Bullet.prototype.kill = function() {
            return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this
        }, i.Bullet.prototype.update = function() {
            this.exists && (this.data.killType > i.Weapon.KILL_LIFESPAN && (this.data.killType === i.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
        }, i.Video = function(t, e, n) {
            if (void 0 === e && (e = null), void 0 === n && (n = null), this.game = t, this.key = e, this.width = 0, this.height = 0, this.type = i.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new i.Signal, this.onChangeSource = new i.Signal, this.onComplete = new i.Signal, this.onAccess = new i.Signal, this.onError = new i.Signal, this.onTimeout = new i.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, e && this.game.cache.checkVideoKey(e)) {
                var s = this.game.cache.getVideo(e);
                s.isBlob ? this.createVideoFromBlob(s.data) : this.video = s.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
            } else n && this.createVideoFromURL(n, !1);
            this.video && !n ? (this.baseTexture = new PIXI.BaseTexture(this.video), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(i.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new i.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== e && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, i.BitmapData && (this.snapshot = new i.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : s && (s.locked = !1)
        }, i.Video.prototype = {
            connectToMediaStream: function(t, e) {
                return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
            },
            startMediaStream: function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                try {
                    navigator.getUserMedia({
                        audio: t,
                        video: !0
                    }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                } catch (t) {
                    this.getUserMediaError(t)
                }
                return this
            },
            getUserMediaTimeout: function() {
                clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
            },
            getUserMediaError: function(t) {
                clearTimeout(this._timeOutID), this.onError.dispatch(this, t)
            },
            getUserMediaSuccess: function(t) {
                clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
                var e = this;
                this.video.onloadeddata = function() {
                    var t = 10;
                    ! function i() {
                        if (t > 0)
                            if (e.video.videoWidth > 0) {
                                var n = e.video.videoWidth,
                                    s = e.video.videoHeight;
                                isNaN(e.video.videoHeight) && (s = n / (4 / 3)), e.video.play(), e.isStreaming = !0, e.baseTexture.source = e.video, e.updateTexture(null, n, s), e.onAccess.dispatch(e)
                            } else window.setTimeout(i, 500);
                        t--
                    }()
                }
            },
            createVideoFromBlob: function(t) {
                var e = this;
                return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(t) {
                    e.updateTexture(t)
                }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this
            },
            createVideoFromURL: function(t, e) {
                return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this
            },
            updateTexture: function(t, e, i) {
                var n = !1;
                void 0 !== e && null !== e || (e = this.video.videoWidth, n = !0), void 0 !== i && null !== i || (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), n && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
            },
            complete: function() {
                this.onComplete.dispatch(this)
            },
            play: function(t, e) {
                return void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this
            },
            playHandler: function() {
                this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
            },
            stop: function() {
                return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) {
                    t.stop()
                }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
            },
            add: function(t) {
                if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this);
                return this
            },
            addToWorld: function(t, e, i, n, s, r) {
                s = s || 1, r = r || 1;
                var o = this.game.add.image(t, e, this);
                return o.anchor.set(i, n), o.scale.set(s, r), o
            },
            render: function() {
                !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
            },
            setMute: function() {
                this._muted || (this._muted = !0, this.video.muted = !0)
            },
            unsetMute: function() {
                this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
            },
            setPause: function() {
                this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
            },
            setResume: function() {
                !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
            },
            changeSource: function(t, e) {
                return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), this._autoplay = e, e || (this.paused = !0), this
            },
            checkVideoProgress: function() {
                4 === this.video.readyState ? this.updateTexture() : (this.retry--, this.retry > 0 && (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)))
            },
            setTouchLock: function() {
                this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0
            },
            unlock: function() {
                if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) {
                    var t = this.game.cache.getVideo(this.key);
                    t && !t.isBlob && (t.locked = !1)
                }
                return !0
            },
            grab: function(t, e, i) {
                if (void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null !== this.snapshot) return t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot
            },
            removeVideoElement: function() {
                if (this.video) {
                    for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                    this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                }
            },
            destroy: function() {
                this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
            }
        }, Object.defineProperty(i.Video.prototype, "currentTime", {
            get: function() {
                return this.video ? this.video.currentTime : 0
            },
            set: function(t) {
                this.video.currentTime = t
            }
        }), Object.defineProperty(i.Video.prototype, "duration", {
            get: function() {
                return this.video ? this.video.duration : 0
            }
        }), Object.defineProperty(i.Video.prototype, "progress", {
            get: function() {
                return this.video ? this.video.currentTime / this.video.duration : 0
            }
        }), Object.defineProperty(i.Video.prototype, "mute", {
            get: function() {
                return this._muted
            },
            set: function(t) {
                if (t = t || null) {
                    if (this._muted) return;
                    this._codeMuted = !0, this.setMute()
                } else {
                    if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute()
                }
            }
        }), Object.defineProperty(i.Video.prototype, "paused", {
            get: function() {
                return this._paused
            },
            set: function(t) {
                if (t = t || null, !this.touchLocked)
                    if (t) {
                        if (this._paused) return;
                        this._codePaused = !0, this.setPause()
                    } else {
                        if (!this._paused) return;
                        this._codePaused = !1, this.setResume()
                    }
            }
        }), Object.defineProperty(i.Video.prototype, "volume", {
            get: function() {
                return this.video ? this.video.volume : 1
            },
            set: function(t) {
                t < 0 ? t = 0 : t > 1 && (t = 1), this.video && (this.video.volume = t)
            }
        }), Object.defineProperty(i.Video.prototype, "playbackRate", {
            get: function() {
                return this.video ? this.video.playbackRate : 1
            },
            set: function(t) {
                this.video && (this.video.playbackRate = t)
            }
        }), Object.defineProperty(i.Video.prototype, "loop", {
            get: function() {
                return !!this.video && this.video.loop
            },
            set: function(t) {
                t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
            }
        }), Object.defineProperty(i.Video.prototype, "playing", {
            get: function() {
                return !(this.video.paused && this.video.ended)
            }
        }), i.Video.prototype.constructor = i.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = i.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = i.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = i.POLYGON, PIXI.Graphics.RECT = i.RECTANGLE, PIXI.Graphics.CIRC = i.CIRCLE, PIXI.Graphics.ELIP = i.ELLIPSE, PIXI.Graphics.RREC = i.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = i), exports.Phaser = i) : "undefined" != typeof define && define.amd ? define("Phaser", e.Phaser = i) : e.Phaser = i, i
    }.call(this),
    function(t) {
        var e = {};

        function i(n) {
            if (e[n]) return e[n].exports;
            var s = e[n] = {
                exports: {},
                id: n,
                loaded: !1
            };
            return t[n].call(s.exports, s, s.exports, i), s.loaded = !0, s.exports
        }
        i.m = t, i.c = e, i.p = "./dist/", i(0)
    }([function(t, e, i) {
        i(128), t.exports = i(124)
    }, function(t, e, i) {
        var n = i(3),
            s = i(23),
            r = i(12),
            o = i(14),
            a = i(26),
            h = function(t, e, i) {
                var l, c, u, d, p = t & h.F,
                    f = t & h.G,
                    g = t & h.S,
                    m = t & h.P,
                    y = t & h.B,
                    v = f ? n : g ? n[e] || (n[e] = {}) : (n[e] || {}).prototype,
                    b = f ? s : s[e] || (s[e] = {}),
                    x = b.prototype || (b.prototype = {});
                for (l in f && (i = e), i) u = ((c = !p && v && void 0 !== v[l]) ? v : i)[l], d = y && c ? a(u, n) : m && "function" == typeof u ? a(Function.call, u) : u, v && o(v, l, u, t & h.U), b[l] != u && r(b, l, d), m && x[l] != u && (x[l] = u)
            };
        n.core = s, h.F = 1, h.G = 2, h.S = 4, h.P = 8, h.B = 16, h.W = 32, h.U = 64, h.R = 128, t.exports = h
    }, function(t, e, i) {
        var n = i(5);
        t.exports = function(t) {
            if (!n(t)) throw TypeError(t + " is not an object!");
            return t
        }
    }, function(t, e) {
        var i = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = i)
    }, function(t, e) {
        t.exports = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
    }, function(t, e) {
        t.exports = function(t) {
            return "object" == typeof t ? null !== t : "function" == typeof t
        }
    }, function(t, e, i) {
        var n = i(61)("wks"),
            s = i(41),
            r = i(3).Symbol,
            o = "function" == typeof r;
        (t.exports = function(t) {
            return n[t] || (n[t] = o && r[t] || (o ? r : s)("Symbol." + t))
        }).store = n
    }, function(t, e, i) {
        t.exports = !i(4)(function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7
                }
            }).a
        })
    }, function(t, e, i) {
        var n = i(2),
            s = i(102),
            r = i(25),
            o = Object.defineProperty;
        e.f = i(7) ? Object.defineProperty : function(t, e, i) {
            if (n(t), e = r(e, !0), n(i), s) try {
                return o(t, e, i)
            } catch (t) {}
            if ("get" in i || "set" in i) throw TypeError("Accessors not supported!");
            return "value" in i && (t[e] = i.value), t
        }
    }, function(t, e, i) {
        var n = i(32),
            s = Math.min;
        t.exports = function(t) {
            return t > 0 ? s(n(t), 9007199254740991) : 0
        }
    }, function(t, e, i) {
        var n = i(20);
        t.exports = function(t) {
            return Object(n(t))
        }
    }, function(t, e) {
        var i = {}.hasOwnProperty;
        t.exports = function(t, e) {
            return i.call(t, e)
        }
    }, function(t, e, i) {
        var n = i(8),
            s = i(31);
        t.exports = i(7) ? function(t, e, i) {
            return n.f(t, e, s(1, i))
        } : function(t, e, i) {
            return t[e] = i, t
        }
    }, function(t, e) {
        t.exports = function(t) {
            if ("function" != typeof t) throw TypeError(t + " is not a function!");
            return t
        }
    }, function(t, e, i) {
        var n = i(3),
            s = i(12),
            r = i(11),
            o = i(41)("src"),
            a = Function.toString,
            h = ("" + a).split("toString");
        i(23).inspectSource = function(t) {
            return a.call(t)
        }, (t.exports = function(t, e, i, a) {
            var l = "function" == typeof i;
            l && (r(i, "name") || s(i, "name", e)), t[e] !== i && (l && (r(i, o) || s(i, o, t[e] ? "" + t[e] : h.join(String(e)))), t === n ? t[e] = i : a ? t[e] ? t[e] = i : s(t, e, i) : (delete t[e], s(t, e, i)))
        })(Function.prototype, "toString", function() {
            return "function" == typeof this && this[o] || a.call(this)
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(4),
            r = i(20),
            o = /"/g,
            a = function(t, e, i, n) {
                var s = String(r(t)),
                    a = "<" + e;
                return "" !== i && (a += " " + i + '="' + String(n).replace(o, "&quot;") + '"'), a + ">" + s + "</" + e + ">"
            };
        t.exports = function(t, e) {
            var i = {};
            i[t] = e(a), n(n.P + n.F * s(function() {
                var e = "" [t]('"');
                return e !== e.toLowerCase() || e.split('"').length > 3
            }), "String", i)
        }
    }, function(t, e, i) {
        var n = i(47),
            s = i(20);
        t.exports = function(t) {
            return n(s(t))
        }
    }, function(t, e, i) {
        var n = i(48),
            s = i(31),
            r = i(16),
            o = i(25),
            a = i(11),
            h = i(102),
            l = Object.getOwnPropertyDescriptor;
        e.f = i(7) ? l : function(t, e) {
            if (t = r(t), e = o(e, !0), h) try {
                return l(t, e)
            } catch (t) {}
            if (a(t, e)) return s(!n.f.call(t, e), t[e])
        }
    }, function(t, e, i) {
        var n = i(11),
            s = i(10),
            r = i(79)("IE_PROTO"),
            o = Object.prototype;
        t.exports = Object.getPrototypeOf || function(t) {
            return t = s(t), n(t, r) ? t[r] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? o : null
        }
    }, function(t, e) {
        var i = {}.toString;
        t.exports = function(t) {
            return i.call(t).slice(8, -1)
        }
    }, function(t, e) {
        t.exports = function(t) {
            if (void 0 == t) throw TypeError("Can't call method on  " + t);
            return t
        }
    }, function(t, e, i) {
        var n = i(4);
        t.exports = function(t, e) {
            return !!t && n(function() {
                e ? t.call(null, function() {}, 1) : t.call(null)
            })
        }
    }, function(t, e, i) {
        var n = i(26),
            s = i(47),
            r = i(10),
            o = i(9),
            a = i(132);
        t.exports = function(t, e) {
            var i = 1 == t,
                h = 2 == t,
                l = 3 == t,
                c = 4 == t,
                u = 6 == t,
                d = 5 == t || u,
                p = e || a;
            return function(e, a, f) {
                for (var g, m, y = r(e), v = s(y), b = n(a, f, 3), x = o(v.length), w = 0, _ = i ? p(e, x) : h ? p(e, 0) : void 0; x > w; w++)
                    if ((d || w in v) && (m = b(g = v[w], w, y), t))
                        if (i) _[w] = m;
                        else if (m) switch (t) {
                    case 3:
                        return !0;
                    case 5:
                        return g;
                    case 6:
                        return w;
                    case 2:
                        _.push(g)
                } else if (c) return !1;
                return u ? -1 : l || c ? c : _
            }
        }
    }, function(t, e) {
        var i = t.exports = {
            version: "2.4.0"
        };
        "number" == typeof __e && (__e = i)
    }, function(t, e, i) {
        var n = i(1),
            s = i(23),
            r = i(4);
        t.exports = function(t, e) {
            var i = (s.Object || {})[t] || Object[t],
                o = {};
            o[t] = e(i), n(n.S + n.F * r(function() {
                i(1)
            }), "Object", o)
        }
    }, function(t, e, i) {
        var n = i(5);
        t.exports = function(t, e) {
            if (!n(t)) return t;
            var i, s;
            if (e && "function" == typeof(i = t.toString) && !n(s = i.call(t))) return s;
            if ("function" == typeof(i = t.valueOf) && !n(s = i.call(t))) return s;
            if (!e && "function" == typeof(i = t.toString) && !n(s = i.call(t))) return s;
            throw TypeError("Can't convert object to primitive value")
        }
    }, function(t, e, i) {
        var n = i(13);
        t.exports = function(t, e, i) {
            if (n(t), void 0 === e) return t;
            switch (i) {
                case 1:
                    return function(i) {
                        return t.call(e, i)
                    };
                case 2:
                    return function(i, n) {
                        return t.call(e, i, n)
                    };
                case 3:
                    return function(i, n, s) {
                        return t.call(e, i, n, s)
                    }
            }
            return function() {
                return t.apply(e, arguments)
            }
        }
    }, function(t, e, i) {
        var n = i(117),
            s = i(1),
            r = i(61)("metadata"),
            o = r.store || (r.store = new(i(120))),
            a = function(t, e, i) {
                var s = o.get(t);
                if (!s) {
                    if (!i) return;
                    o.set(t, s = new n)
                }
                var r = s.get(e);
                if (!r) {
                    if (!i) return;
                    s.set(e, r = new n)
                }
                return r
            };
        t.exports = {
            store: o,
            map: a,
            has: function(t, e, i) {
                var n = a(e, i, !1);
                return void 0 !== n && n.has(t)
            },
            get: function(t, e, i) {
                var n = a(e, i, !1);
                return void 0 === n ? void 0 : n.get(t)
            },
            set: function(t, e, i, n) {
                a(i, n, !0).set(t, e)
            },
            keys: function(t, e) {
                var i = a(t, e, !1),
                    n = [];
                return i && i.forEach(function(t, e) {
                    n.push(e)
                }), n
            },
            key: function(t) {
                return void 0 === t || "symbol" == typeof t ? t : String(t)
            },
            exp: function(t) {
                s(s.S, "Reflect", t)
            }
        }
    }, function(t, e, i) {
        "use strict";
        if (i(7)) {
            var n = i(34),
                s = i(3),
                r = i(4),
                o = i(1),
                a = i(62),
                h = i(86),
                l = i(26),
                c = i(29),
                u = i(31),
                d = i(12),
                p = i(38),
                f = (i(73), i(32)),
                g = i(9),
                m = i(40),
                y = i(25),
                v = i(11),
                b = i(114),
                x = i(43),
                w = i(5),
                _ = i(10),
                P = i(71),
                T = i(35),
                S = i(18),
                C = i(36).f,
                A = (i(139), i(88)),
                E = i(41),
                M = i(6),
                I = i(22),
                O = i(51),
                k = i(80),
                R = i(89),
                L = i(33),
                B = i(57),
                F = i(39),
                D = i(64),
                U = i(95),
                G = i(8),
                N = i(17),
                X = G.f,
                j = N.f,
                W = s.RangeError,
                V = s.TypeError,
                Y = s.Uint8Array,
                H = Array.prototype,
                q = h.ArrayBuffer,
                z = h.DataView,
                K = I(0),
                J = I(2),
                Q = I(3),
                Z = I(4),
                $ = I(5),
                tt = I(6),
                et = O(!0),
                it = O(!1),
                nt = R.values,
                st = R.keys,
                rt = R.entries,
                ot = H.lastIndexOf,
                at = H.reduce,
                ht = H.reduceRight,
                lt = H.join,
                ct = H.sort,
                ut = H.slice,
                dt = H.toString,
                pt = H.toLocaleString,
                ft = M("iterator"),
                gt = M("toStringTag"),
                mt = E("typed_constructor"),
                yt = E("def_constructor"),
                vt = a.CONSTR,
                bt = a.TYPED,
                xt = a.VIEW,
                wt = I(1, function(t, e) {
                    return At(k(t, t[yt]), e)
                }),
                _t = r(function() {
                    return 1 === new Y(new Uint16Array([1]).buffer)[0]
                }),
                Pt = !!Y && !!Y.prototype.set && r(function() {
                    new Y(1).set({})
                }),
                Tt = function(t, e) {
                    if (void 0 === t) throw V("Wrong length!");
                    var i = +t,
                        n = g(t);
                    if (e && !b(i, n)) throw W("Wrong length!");
                    return n
                },
                St = function(t, e) {
                    var i = f(t);
                    if (i < 0 || i % e) throw W("Wrong offset!");
                    return i
                },
                Ct = function(t) {
                    if (w(t) && bt in t) return t;
                    throw V(t + " is not a typed array!")
                },
                At = function(t, e) {
                    if (!(w(t) && mt in t)) throw V("It is not a typed array constructor!");
                    return new t(e)
                },
                Et = function(t, e) {
                    return Mt(k(t, t[yt]), e)
                },
                Mt = function(t, e) {
                    for (var i = 0, n = e.length, s = At(t, n); n > i;) s[i] = e[i++];
                    return s
                },
                It = function(t, e, i) {
                    X(t, e, {
                        get: function() {
                            return this._d[i]
                        }
                    })
                },
                Ot = function(t) {
                    var e, i, n, s, r, o, a = _(t),
                        h = arguments.length,
                        c = h > 1 ? arguments[1] : void 0,
                        u = void 0 !== c,
                        d = A(a);
                    if (void 0 != d && !P(d)) {
                        for (o = d.call(a), n = [], e = 0; !(r = o.next()).done; e++) n.push(r.value);
                        a = n
                    }
                    for (u && h > 2 && (c = l(c, arguments[2], 2)), e = 0, i = g(a.length), s = At(this, i); i > e; e++) s[e] = u ? c(a[e], e) : a[e];
                    return s
                },
                kt = function() {
                    for (var t = 0, e = arguments.length, i = At(this, e); e > t;) i[t] = arguments[t++];
                    return i
                },
                Rt = !!Y && r(function() {
                    pt.call(new Y(1))
                }),
                Lt = function() {
                    return pt.apply(Rt ? ut.call(Ct(this)) : Ct(this), arguments)
                },
                Bt = {
                    copyWithin: function(t, e) {
                        return U.call(Ct(this), t, e, arguments.length > 2 ? arguments[2] : void 0)
                    },
                    every: function(t) {
                        return Z(Ct(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    fill: function(t) {
                        return D.apply(Ct(this), arguments)
                    },
                    filter: function(t) {
                        return Et(this, J(Ct(this), t, arguments.length > 1 ? arguments[1] : void 0))
                    },
                    find: function(t) {
                        return $(Ct(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    findIndex: function(t) {
                        return tt(Ct(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    forEach: function(t) {
                        K(Ct(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    indexOf: function(t) {
                        return it(Ct(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    includes: function(t) {
                        return et(Ct(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    join: function(t) {
                        return lt.apply(Ct(this), arguments)
                    },
                    lastIndexOf: function(t) {
                        return ot.apply(Ct(this), arguments)
                    },
                    map: function(t) {
                        return wt(Ct(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    reduce: function(t) {
                        return at.apply(Ct(this), arguments)
                    },
                    reduceRight: function(t) {
                        return ht.apply(Ct(this), arguments)
                    },
                    reverse: function() {
                        for (var t, e = Ct(this).length, i = Math.floor(e / 2), n = 0; n < i;) t = this[n], this[n++] = this[--e], this[e] = t;
                        return this
                    },
                    some: function(t) {
                        return Q(Ct(this), t, arguments.length > 1 ? arguments[1] : void 0)
                    },
                    sort: function(t) {
                        return ct.call(Ct(this), t)
                    },
                    subarray: function(t, e) {
                        var i = Ct(this),
                            n = i.length,
                            s = m(t, n);
                        return new(k(i, i[yt]))(i.buffer, i.byteOffset + s * i.BYTES_PER_ELEMENT, g((void 0 === e ? n : m(e, n)) - s))
                    }
                },
                Ft = function(t, e) {
                    return Et(this, ut.call(Ct(this), t, e))
                },
                Dt = function(t) {
                    Ct(this);
                    var e = St(arguments[1], 1),
                        i = this.length,
                        n = _(t),
                        s = g(n.length),
                        r = 0;
                    if (s + e > i) throw W("Wrong length!");
                    for (; r < s;) this[e + r] = n[r++]
                },
                Ut = {
                    entries: function() {
                        return rt.call(Ct(this))
                    },
                    keys: function() {
                        return st.call(Ct(this))
                    },
                    values: function() {
                        return nt.call(Ct(this))
                    }
                },
                Gt = function(t, e) {
                    return w(t) && t[bt] && "symbol" != typeof e && e in t && String(+e) == String(e)
                },
                Nt = function(t, e) {
                    return Gt(t, e = y(e, !0)) ? u(2, t[e]) : j(t, e)
                },
                Xt = function(t, e, i) {
                    return !(Gt(t, e = y(e, !0)) && w(i) && v(i, "value")) || v(i, "get") || v(i, "set") || i.configurable || v(i, "writable") && !i.writable || v(i, "enumerable") && !i.enumerable ? X(t, e, i) : (t[e] = i.value, t)
                };
            vt || (N.f = Nt, G.f = Xt), o(o.S + o.F * !vt, "Object", {
                getOwnPropertyDescriptor: Nt,
                defineProperty: Xt
            }), r(function() {
                dt.call({})
            }) && (dt = pt = function() {
                return lt.call(this)
            });
            var jt = p({}, Bt);
            p(jt, Ut), d(jt, ft, Ut.values), p(jt, {
                slice: Ft,
                set: Dt,
                constructor: function() {},
                toString: dt,
                toLocaleString: Lt
            }), It(jt, "buffer", "b"), It(jt, "byteOffset", "o"), It(jt, "byteLength", "l"), It(jt, "length", "e"), X(jt, gt, {
                get: function() {
                    return this[bt]
                }
            }), t.exports = function(t, e, i, h) {
                var l = t + ((h = !!h) ? "Clamped" : "") + "Array",
                    u = "Uint8Array" != l,
                    p = "get" + t,
                    f = "set" + t,
                    m = s[l],
                    y = m || {},
                    v = m && S(m),
                    b = !m || !a.ABV,
                    _ = {},
                    P = m && m.prototype,
                    A = function(t, i) {
                        X(t, i, {
                            get: function() {
                                return function(t, i) {
                                    var n = t._d;
                                    return n.v[p](i * e + n.o, _t)
                                }(this, i)
                            },
                            set: function(t) {
                                return function(t, i, n) {
                                    var s = t._d;
                                    h && (n = (n = Math.round(n)) < 0 ? 0 : n > 255 ? 255 : 255 & n), s.v[f](i * e + s.o, n, _t)
                                }(this, i, t)
                            },
                            enumerable: !0
                        })
                    };
                b ? (m = i(function(t, i, n, s) {
                    c(t, m, l, "_d");
                    var r, o, a, h, u = 0,
                        p = 0;
                    if (w(i)) {
                        if (!(i instanceof q || "ArrayBuffer" == (h = x(i)) || "SharedArrayBuffer" == h)) return bt in i ? Mt(m, i) : Ot.call(m, i);
                        r = i, p = St(n, e);
                        var f = i.byteLength;
                        if (void 0 === s) {
                            if (f % e) throw W("Wrong length!");
                            if ((o = f - p) < 0) throw W("Wrong length!")
                        } else if ((o = g(s) * e) + p > f) throw W("Wrong length!");
                        a = o / e
                    } else a = Tt(i, !0), r = new q(o = a * e);
                    for (d(t, "_d", {
                            b: r,
                            o: p,
                            l: o,
                            e: a,
                            v: new z(r)
                        }); u < a;) A(t, u++)
                }), P = m.prototype = T(jt), d(P, "constructor", m)) : B(function(t) {
                    new m(null), new m(t)
                }, !0) || (m = i(function(t, i, n, s) {
                    var r;
                    return c(t, m, l), w(i) ? i instanceof q || "ArrayBuffer" == (r = x(i)) || "SharedArrayBuffer" == r ? void 0 !== s ? new y(i, St(n, e), s) : void 0 !== n ? new y(i, St(n, e)) : new y(i) : bt in i ? Mt(m, i) : Ot.call(m, i) : new y(Tt(i, u))
                }), K(v !== Function.prototype ? C(y).concat(C(v)) : C(y), function(t) {
                    t in m || d(m, t, y[t])
                }), m.prototype = P, n || (P.constructor = m));
                var E = P[ft],
                    M = !!E && ("values" == E.name || void 0 == E.name),
                    I = Ut.values;
                d(m, mt, !0), d(P, bt, l), d(P, xt, !0), d(P, yt, m), (h ? new m(1)[gt] == l : gt in P) || X(P, gt, {
                    get: function() {
                        return l
                    }
                }), _[l] = m, o(o.G + o.W + o.F * (m != y), _), o(o.S, l, {
                    BYTES_PER_ELEMENT: e,
                    from: Ot,
                    of: kt
                }), "BYTES_PER_ELEMENT" in P || d(P, "BYTES_PER_ELEMENT", e), o(o.P, l, Bt), F(l), o(o.P + o.F * Pt, l, {
                    set: Dt
                }), o(o.P + o.F * !M, l, Ut), o(o.P + o.F * (P.toString != dt), l, {
                    toString: dt
                }), o(o.P + o.F * r(function() {
                    new m(1).slice()
                }), l, {
                    slice: Ft
                }), o(o.P + o.F * (r(function() {
                    return [1, 2].toLocaleString() != new m([1, 2]).toLocaleString()
                }) || !r(function() {
                    P.toLocaleString.call([1, 2])
                })), l, {
                    toLocaleString: Lt
                }), L[l] = M ? E : I, n || M || d(P, ft, I)
            }
        } else t.exports = function() {}
    }, function(t, e) {
        t.exports = function(t, e, i, n) {
            if (!(t instanceof e) || void 0 !== n && n in t) throw TypeError(i + ": incorrect invocation!");
            return t
        }
    }, function(t, e, i) {
        var n = i(41)("meta"),
            s = i(5),
            r = i(11),
            o = i(8).f,
            a = 0,
            h = Object.isExtensible || function() {
                return !0
            },
            l = !i(4)(function() {
                return h(Object.preventExtensions({}))
            }),
            c = function(t) {
                o(t, n, {
                    value: {
                        i: "O" + ++a,
                        w: {}
                    }
                })
            },
            u = t.exports = {
                KEY: n,
                NEED: !1,
                fastKey: function(t, e) {
                    if (!s(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                    if (!r(t, n)) {
                        if (!h(t)) return "F";
                        if (!e) return "E";
                        c(t)
                    }
                    return t[n].i
                },
                getWeak: function(t, e) {
                    if (!r(t, n)) {
                        if (!h(t)) return !0;
                        if (!e) return !1;
                        c(t)
                    }
                    return t[n].w
                },
                onFreeze: function(t) {
                    return l && u.NEED && h(t) && !r(t, n) && c(t), t
                }
            }
    }, function(t, e) {
        t.exports = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
    }, function(t, e) {
        var i = Math.ceil,
            n = Math.floor;
        t.exports = function(t) {
            return isNaN(t = +t) ? 0 : (t > 0 ? n : i)(t)
        }
    }, function(t, e) {
        t.exports = {}
    }, function(t, e) {
        t.exports = !1
    }, function(t, e, i) {
        var n = i(2),
            s = i(107),
            r = i(67),
            o = i(79)("IE_PROTO"),
            a = function() {},
            h = function() {
                var t, e = i(66)("iframe"),
                    n = r.length;
                for (e.style.display = "none", i(69).appendChild(e), e.src = "javascript:", (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), h = t.F; n--;) delete h.prototype[r[n]];
                return h()
            };
        t.exports = Object.create || function(t, e) {
            var i;
            return null !== t ? (a.prototype = n(t), i = new a, a.prototype = null, i[o] = t) : i = h(), void 0 === e ? i : s(i, e)
        }
    }, function(t, e, i) {
        var n = i(109),
            s = i(67).concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(t) {
            return n(t, s)
        }
    }, function(t, e, i) {
        var n = i(109),
            s = i(67);
        t.exports = Object.keys || function(t) {
            return n(t, s)
        }
    }, function(t, e, i) {
        var n = i(14);
        t.exports = function(t, e, i) {
            for (var s in e) n(t, s, e[s], i);
            return t
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(3),
            s = i(8),
            r = i(7),
            o = i(6)("species");
        t.exports = function(t) {
            var e = n[t];
            r && e && !e[o] && s.f(e, o, {
                configurable: !0,
                get: function() {
                    return this
                }
            })
        }
    }, function(t, e, i) {
        var n = i(32),
            s = Math.max,
            r = Math.min;
        t.exports = function(t, e) {
            return (t = n(t)) < 0 ? s(t + e, 0) : r(t, e)
        }
    }, function(t, e) {
        var i = 0,
            n = Math.random();
        t.exports = function(t) {
            return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++i + n).toString(36))
        }
    }, function(t, e, i) {
        var n = i(6)("unscopables"),
            s = Array.prototype;
        void 0 == s[n] && i(12)(s, n, {}), t.exports = function(t) {
            s[n][t] = !0
        }
    }, function(t, e, i) {
        var n = i(19),
            s = i(6)("toStringTag"),
            r = "Arguments" == n(function() {
                return arguments
            }());
        t.exports = function(t) {
            var e, i, o;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(i = function(t, e) {
                try {
                    return t[e]
                } catch (t) {}
            }(e = Object(t), s)) ? i : r ? n(e) : "Object" == (o = n(e)) && "function" == typeof e.callee ? "Arguments" : o
        }
    }, function(t, e, i) {
        var n = i(26),
            s = i(103),
            r = i(71),
            o = i(2),
            a = i(9),
            h = i(88),
            l = {},
            c = {};
        (e = t.exports = function(t, e, i, u, d) {
            var p, f, g, m, y = d ? function() {
                    return t
                } : h(t),
                v = n(i, u, e ? 2 : 1),
                b = 0;
            if ("function" != typeof y) throw TypeError(t + " is not iterable!");
            if (r(y)) {
                for (p = a(t.length); p > b; b++)
                    if ((m = e ? v(o(f = t[b])[0], f[1]) : v(t[b])) === l || m === c) return m
            } else
                for (g = y.call(t); !(f = g.next()).done;)
                    if ((m = s(g, v, f.value, e)) === l || m === c) return m
        }).BREAK = l, e.RETURN = c
    }, function(t, e, i) {
        var n = i(8).f,
            s = i(11),
            r = i(6)("toStringTag");
        t.exports = function(t, e, i) {
            t && !s(t = i ? t : t.prototype, r) && n(t, r, {
                configurable: !0,
                value: e
            })
        }
    }, function(t, e, i) {
        var n = i(1),
            s = i(20),
            r = i(4),
            o = i(84),
            a = "[" + o + "]",
            h = RegExp("^" + a + a + "*"),
            l = RegExp(a + a + "*$"),
            c = function(t, e, i) {
                var s = {},
                    a = r(function() {
                        return !!o[t]() || "​" != "​" [t]()
                    }),
                    h = s[t] = a ? e(u) : o[t];
                i && (s[i] = h), n(n.P + n.F * a, "String", s)
            },
            u = c.trim = function(t, e) {
                return t = String(s(t)), 1 & e && (t = t.replace(h, "")), 2 & e && (t = t.replace(l, "")), t
            };
        t.exports = c
    }, function(t, e, i) {
        var n = i(19);
        t.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t) {
            return "String" == n(t) ? t.split("") : Object(t)
        }
    }, function(t, e) {
        e.f = {}.propertyIsEnumerable
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.parseBounds = function(t) {
            t.x = t.x ? t.x : 0, t.y = t.y ? t.y : 0, t.width <= 0 || t.height;
            return t
        }, e.getWidthOrHeight = function(t, e) {
            return t["nominal" + o(e)] || t[e]
        }, e.capitalizeFirstLetter = o, e.findChild = a, e.detectDrag = h, e.dispatchClicks = function(t, e, i) {
            if ("onInputUp" == i) {
                for (var n = 0; n < e.length; ++n) e[n].onInputUpCallBack && (e[n].onInputUpCallBack(), e[n].onInputUpCallBack = void 0);
                if (h(t)) return
            }
            var s = a(e, function(e) {
                var i = e.worldPosition,
                    n = e.anchor,
                    s = e.pivot,
                    r = e.width,
                    o = e.height,
                    a = e.scale,
                    h = i.x - (n ? n.x * r : 0) - s.x * a.x,
                    l = i.y - (n ? n.y * o : 0) - s.y * a.y;
                return e.inputEnabled && new Phaser.Rectangle(h, l, e.width, e.height).contains(t.x, t.y)
            });
            s && s.events && s.events[i] && s.events[i].dispatch && s.events[i].dispatch(s, t, !0);
            return s
        };
        var n, s = i(90),
            r = (n = s) && n.__esModule ? n : {
                default: n
            };

        function o(t) {
            return t.charAt(0).toUpperCase() + t.slice(1)
        }

        function a(t, e) {
            var i = arguments.length <= 2 || void 0 === arguments[2] ? null : arguments[2];
            if (!t) return !1;
            for (var n = 0; n < t.length; n++) {
                var s = t[n];
                if (s && 0 != s.visible) {
                    if (e.call(i, s)) return s;
                    var r = a(s.children, e, i);
                    if (r) return r
                }
            }
            return !1
        }

        function h(t) {
            var e = Math.abs(t.positionDown.x - t.positionUp.x),
                i = Math.abs(t.positionDown.y - t.positionUp.y);
            t.timeUp, t.timeDown;
            return e > r.default.AUTO_DETECT_THRESHOLD || i > r.default.AUTO_DETECT_THRESHOLD
        }
    }, function(t, e) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var i = {
            nearestMultiple: function(t, e) {
                return Math.round(t / e) * e
            },
            scaleBetween: function(t, e, i) {
                return t + (e - t) * i
            },
            percentageBetween2: function(t, e, i) {
                return (t - e) / (i - e)
            }
        };
        e.default = i
    }, function(t, e, i) {
        var n = i(16),
            s = i(9),
            r = i(40);
        t.exports = function(t) {
            return function(e, i, o) {
                var a, h = n(e),
                    l = s(h.length),
                    c = r(o, l);
                if (t && i != i) {
                    for (; l > c;)
                        if ((a = h[c++]) != a) return !0
                } else
                    for (; l > c; c++)
                        if ((t || c in h) && h[c] === i) return t || c || 0;
                return !t && -1
            }
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(3),
            s = i(1),
            r = i(14),
            o = i(38),
            a = i(30),
            h = i(44),
            l = i(29),
            c = i(5),
            u = i(4),
            d = i(57),
            p = i(45),
            f = i(70);
        t.exports = function(t, e, i, g, m, y) {
            var v = n[t],
                b = v,
                x = m ? "set" : "add",
                w = b && b.prototype,
                _ = {},
                P = function(t) {
                    var e = w[t];
                    r(w, t, "delete" == t ? function(t) {
                        return !(y && !c(t)) && e.call(this, 0 === t ? 0 : t)
                    } : "has" == t ? function(t) {
                        return !(y && !c(t)) && e.call(this, 0 === t ? 0 : t)
                    } : "get" == t ? function(t) {
                        return y && !c(t) ? void 0 : e.call(this, 0 === t ? 0 : t)
                    } : "add" == t ? function(t) {
                        return e.call(this, 0 === t ? 0 : t), this
                    } : function(t, i) {
                        return e.call(this, 0 === t ? 0 : t, i), this
                    })
                };
            if ("function" == typeof b && (y || w.forEach && !u(function() {
                    (new b).entries().next()
                }))) {
                var T = new b,
                    S = T[x](y ? {} : -0, 1) != T,
                    C = u(function() {
                        T.has(1)
                    }),
                    A = d(function(t) {
                        new b(t)
                    }),
                    E = !y && u(function() {
                        for (var t = new b, e = 5; e--;) t[x](e, e);
                        return !t.has(-0)
                    });
                A || ((b = e(function(e, i) {
                    l(e, b, t);
                    var n = f(new v, e, b);
                    return void 0 != i && h(i, m, n[x], n), n
                })).prototype = w, w.constructor = b), (C || E) && (P("delete"), P("has"), m && P("get")), (E || S) && P(x), y && w.clear && delete w.clear
            } else b = g.getConstructor(e, t, m, x), o(b.prototype, i), a.NEED = !0;
            return p(b, t), _[t] = b, s(s.G + s.W + s.F * (b != v), _), y || g.setStrong(b, t, m), b
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(12),
            s = i(14),
            r = i(4),
            o = i(20),
            a = i(6);
        t.exports = function(t, e, i) {
            var h = a(t),
                l = i(o, h, "" [t]),
                c = l[0],
                u = l[1];
            r(function() {
                var e = {};
                return e[h] = function() {
                    return 7
                }, 7 != "" [t](e)
            }) && (s(String.prototype, t, c), n(RegExp.prototype, h, 2 == e ? function(t, e) {
                return u.call(t, this, e)
            } : function(t) {
                return u.call(t, this)
            }))
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(2);
        t.exports = function() {
            var t = n(this),
                e = "";
            return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.unicode && (e += "u"), t.sticky && (e += "y"), e
        }
    }, function(t, e) {
        t.exports = function(t, e, i) {
            var n = void 0 === i;
            switch (e.length) {
                case 0:
                    return n ? t() : t.call(i);
                case 1:
                    return n ? t(e[0]) : t.call(i, e[0]);
                case 2:
                    return n ? t(e[0], e[1]) : t.call(i, e[0], e[1]);
                case 3:
                    return n ? t(e[0], e[1], e[2]) : t.call(i, e[0], e[1], e[2]);
                case 4:
                    return n ? t(e[0], e[1], e[2], e[3]) : t.call(i, e[0], e[1], e[2], e[3])
            }
            return t.apply(i, e)
        }
    }, function(t, e, i) {
        var n = i(5),
            s = i(19),
            r = i(6)("match");
        t.exports = function(t) {
            var e;
            return n(t) && (void 0 !== (e = t[r]) ? !!e : "RegExp" == s(t))
        }
    }, function(t, e, i) {
        var n = i(6)("iterator"),
            s = !1;
        try {
            var r = [7][n]();
            r.return = function() {
                s = !0
            }, Array.from(r, function() {
                throw 2
            })
        } catch (t) {}
        t.exports = function(t, e) {
            if (!e && !s) return !1;
            var i = !1;
            try {
                var r = [7],
                    o = r[n]();
                o.next = function() {
                    return {
                        done: i = !0
                    }
                }, r[n] = function() {
                    return o
                }, t(r)
            } catch (t) {}
            return i
        }
    }, function(t, e, i) {
        t.exports = i(34) || !i(4)(function() {
            var t = Math.random();
            __defineSetter__.call(null, t, function() {}), delete i(3)[t]
        })
    }, function(t, e) {
        e.f = Object.getOwnPropertySymbols
    }, function(t, e, i) {
        var n = i(5),
            s = i(2),
            r = function(t, e) {
                if (s(t), !n(e) && null !== e) throw TypeError(e + ": can't set as prototype!")
            };
        t.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? function(t, e, n) {
                try {
                    (n = i(26)(Function.call, i(17).f(Object.prototype, "__proto__").set, 2))(t, []), e = !(t instanceof Array)
                } catch (t) {
                    e = !0
                }
                return function(t, i) {
                    return r(t, i), e ? t.__proto__ = i : n(t, i), t
                }
            }({}, !1) : void 0),
            check: r
        }
    }, function(t, e, i) {
        var n = i(3),
            s = n["__core-js_shared__"] || (n["__core-js_shared__"] = {});
        t.exports = function(t) {
            return s[t] || (s[t] = {})
        }
    }, function(t, e, i) {
        for (var n, s = i(3), r = i(12), o = i(41), a = o("typed_array"), h = o("view"), l = !(!s.ArrayBuffer || !s.DataView), c = l, u = 0, d = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); u < 9;)(n = s[d[u++]]) ? (r(n.prototype, a, !0), r(n.prototype, h, !0)) : c = !1;
        t.exports = {
            ABV: l,
            CONSTR: c,
            TYPED: a,
            VIEW: h
        }
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var n, s = function() {
                function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }
                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(),
            r = i(50),
            o = (n = r) && n.__esModule ? n : {
                default: n
            },
            a = i(49);
        var h = new Phaser.Point,
            l = {
                from: 0,
                to: 200,
                direction: "y",
                momentum: !1,
                snapping: !1,
                bouncing: !1,
                deceleration: .5,
                overflow: 20,
                snapStep: 10,
                emitMoving: !1,
                duration: 2,
                speedLimit: 3,
                flickTimeThreshold: 100,
                offsetThreshold: 30,
                acceleration: .5,
                accelerationT: 250,
                maxAcceleration: 4,
                time: {},
                multiplier: 1,
                swipeEnabled: !1,
                swipeThreshold: 5,
                swipeTimeThreshold: 250,
                minDuration: .5,
                addListeners: !0
            },
            c = function() {
                function t(e, i) {
                    var n = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2],
                        s = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.game = e, this.clickObject = i, this.maskLimits = n, this.o = this.options = Object.assign({}, l, s), this._updateMinMax(), this.dispatchValues = {
                        step: 0,
                        total: 0,
                        percent: 0
                    }, this.addListeners(), this.clickables = [], this.isDown = !1, this.isScrolling = !1, this.scrollObject = {}, this.init(), this.tweenScroll = this.game.add.tween(this.scrollObject).to({}, 0, Phaser.Easing.Quartic.Out), this.tweenScroll.onUpdateCallback(this.handleUpdate, this), this.tweenScroll.onComplete.add(this.handleComplete, this)
                }
                return s(t, [{
                    key: "destroy",
                    value: function() {
                        this.tweenScroll.stop(), this.removeListeners(), this.clickObject.destroy(), this.clickables = null, this.options = this.o = null, this.maskLimits = null, this.enabled = !1, this.game = null, this.dispatchValues = null, this.isDown = null, this.target = null, this.destroyed = !0
                    }
                }, {
                    key: "addListeners",
                    value: function() {
                        this.events = {
                            onUpdate: new Phaser.Signal,
                            onInputUp: new Phaser.Signal,
                            onInputDown: new Phaser.Signal,
                            onInputMove: new Phaser.Signal,
                            onComplete: new Phaser.Signal,
                            onSwipe: new Phaser.Signal
                        }, this.o.addListeners && (this.clickObject.inputEnabled = !0, this.clickObject.events.onInputDown.add(this.handleDown, this), this.clickObject.events.onInputUp.add(this.handleUp, this))
                    }
                }, {
                    key: "removeListeners",
                    value: function() {
                        for (var t in this.o.addListeners && (this.clickObject.events.onInputDown.remove(this.handleDown, this), this.clickObject.events.onInputUp.remove(this.handleUp, this)), this.events) this.events.hasOwnProperty(t) && this.events[t].dispose()
                    }
                }, {
                    key: "enable",
                    value: function() {
                        this.enabled = !0
                    }
                }, {
                    key: "disable",
                    value: function() {
                        this.enabled = !1
                    }
                }, {
                    key: "init",
                    value: function() {
                        this.scrollObject[this.o.direction] = this.o.from, this.maxOffset = this.maskLimits[this.o.direction] * this.o.speedLimit, this.enable()
                    }
                }, {
                    key: "reset",
                    value: function() {
                        this.tweenScroll.pause(), this.o.multiplier = 1, this.init()
                    }
                }, {
                    key: "setFromTo",
                    value: function(t, e) {
                        this.o.from = t, this.o.to = e, this._updateMinMax()
                    }
                }, {
                    key: "isTweening",
                    value: function() {
                        return this.tweenScroll.isRunning
                    }
                }, {
                    key: "registerClickables",
                    value: function(t) {
                        this.clickables = t
                    }
                }, {
                    key: "handleDown",
                    value: function(t, e) {
                        this.enabled && (this.isDown = !0, this.target = this.requested = this.scrollObject[this.o.direction], this.o.time.down = e.timeDown, this.o.addListeners && this.game.input.addMoveCallback(this.handleMove, this), this.isTweening() && this.o.time.down - this.o.time.up < this.o.accelerationT ? this.o.multiplier += this.o.acceleration : this.o.multiplier = 1, this.tweenScroll.stop(), this.tweenScroll.pendingDelete = !1, (0, a.dispatchClicks)(e, this.clickables, "onInputDown"), this.events.onInputDown.dispatch(t, e))
                    }
                }, {
                    key: "handleMove",
                    value: function(t, e, i) {
                        this.enabled && (this.isScrolling = !0, h.set(e, i), this.diff = this.old - h[this.o.direction], this.diff = this._requestDiff(this.diff, this.target, this.min, this.max, this.o.overflow), this.target -= this.diff, this.old = h[this.o.direction], this.o.time.move = this.game.time.time, this.acc = Math.min(Math.abs(this.diff / 30), this.o.maxAcceleration), this.scrollObject[this.o.direction] = this.target, this.handleUpdate(), this.o.emitMoving && this.events.onInputMove.dispatch(t, e, i))
                    }
                }, {
                    key: "handleUp",
                    value: function(t, e) {
                        this.isDown = !1, this.o.addListeners && this.game.input.deleteMoveCallback(this.handleMove, this), this.o.time.up = e.timeUp, this.o.time.up - this.o.time.down > this.o.accelerationT && (this.o.multiplier = 1);
                        var i = {
                            duration: 1,
                            target: this.target
                        };
                        this.o.bouncing || (i.duration = .01), !this.o.infinite && this.scrollObject[this.o.direction] > this.max ? (this.target = this.max, this.tweenTo(i.duration, this.target)) : !this.o.infinite && this.scrollObject[this.o.direction] < this.min ? (this.target = this.min, this.tweenTo(i.duration, this.target)) : (this._addMomentum(i), this._addSwiping(i, e), this._addSnapping(i), this._addLimits(i), this._calculateDuration(i), this.tweenTo(i.duration, i.target)), (0, a.dispatchClicks)(e, this.clickables, "onInputUp"), this.events.onInputUp.dispatch(t, e, a.dispatchClicks)
                    }
                }, {
                    key: "_addMomentum",
                    value: function(t) {
                        if (!this.o.momentum) return t.target;
                        var e = Math.pow(this.acc, 2) * this.maskLimits[this.o.direction];
                        return e = Math.min(this.maxOffset, e), e = this.diff > 0 ? -this.o.multiplier * e : this.o.multiplier * e, this.o.time.up - this.o.time.move < this.o.flickTimeThreshold && 0 !== e && Math.abs(e) > this.o.offsetThreshold && (t.target += e), t
                    }
                }, {
                    key: "_addSwiping",
                    value: function(t, e) {
                        var i = Math.abs(this.down - this.current);
                        if (this.o.swipeEnabled && this.o.time.up - this.o.time.down < this.o.swipeTimeThreshold && i > this.o.swipeThreshold) {
                            var n = e[this.o.direction] < this.down ? "forward" : "backward";
                            "forward" == n ? t.target -= this.o.snapStep / 2 : t.target += this.o.snapStep / 2, this.events.onSwipe.dispatch(n)
                        }
                        return t
                    }
                }, {
                    key: "_addSnapping",
                    value: function(t) {
                        return this.o.snapping ? (t.target = o.default.nearestMultiple(t.target, this.o.snapStep), t) : t
                    }
                }, {
                    key: "_addLimits",
                    value: function(t) {
                        return this.o.infinite ? t : (t.target = Math.max(t.target, this.min), t.target = Math.min(t.target, this.max), t)
                    }
                }, {
                    key: "_calculateDuration",
                    value: function(t) {
                        var e = Math.abs(t.target - this.scrollObject[this.o.direction]);
                        return t.duration = this.o.duration * e / this.maxOffset, t.duration = Math.max(this.o.minDuration, t.duration), t
                    }
                }, {
                    key: "_requestDiff",
                    value: function(t, e, i, n, s) {
                        if (this.o.infinite) return t;
                        return e > n ? t *= (n + s - e) / s : e < i && (t *= -(i - s - e) / s), t
                    }
                }, {
                    key: "tweenToSnap",
                    value: function(t, e) {
                        var i = this.o.from - this.o.snapStep * e;
                        this.tweenTo(t, i)
                    }
                }, {
                    key: "tweenTo",
                    value: function(t, e) {
                        if (0 == t) return this.setTo(e);
                        var i, n, s, r = (i = {}, n = this.o.direction, s = e, n in i ? Object.defineProperty(i, n, {
                            value: s,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : i[n] = s, i);
                        this.tweenScroll.onUpdateCallback(this.handleUpdate, this), this.tweenScroll.onComplete.add(this.handleComplete, this), this.tweenScroll.updateTweenData("vEnd", r, -1), this.tweenScroll.updateTweenData("duration", 1e3 * t, -1), this.tweenScroll.updateTweenData("percent ", 0, -1), this.tweenScroll.start()
                    }
                }, {
                    key: "cancel",
                    value: function() {
                        this.isDown = !1
                    }
                }, {
                    key: "setTo",
                    value: function(t) {
                        this.scrollObject[this.o.direction] = t, this.tweenScroll.stop(), this.handleUpdate(), this.handleComplete()
                    }
                }, {
                    key: "handleUpdate",
                    value: function() {
                        if (this.enabled) {
                            this.o.infinite ? this.dispatchValues.total = Phaser.Math.wrap(this.scrollObject[this.o.direction], this.min, this.max) : this.dispatchValues.total = this.scrollObject[this.o.direction];
                            var t = this.dispatchValues.total - this.previousTotal;
                            t < -this.length / 2 ? t += this.length : t > this.length / 2 && (t -= this.length), this.dispatchValues.step = t, this.dispatchValues.percent = o.default.percentageBetween2(this.dispatchValues.total, this.o.from, this.o.to), this.events.onUpdate.dispatch(this.dispatchValues), this.previousTotal = this.dispatchValues.total
                        }
                    }
                }, {
                    key: "handleComplete",
                    value: function() {
                        this.enabled && (this.isScrolling = !1, this.o.multiplier = 1, this.events.onComplete.dispatch())
                    }
                }, {
                    key: "_updateMinMax",
                    value: function() {
                        this.min = Math.min(this.o.from, this.o.to), this.max = Math.max(this.o.from, this.o.to), this.length = Math.abs(this.max - this.min), this.previousTotal = this.o.from
                    }
                }]), t
            }();
        e.default = c
    }, function(t, e, i) {
        "use strict";
        var n = i(10),
            s = i(40),
            r = i(9);
        t.exports = function(t) {
            for (var e = n(this), i = r(e.length), o = arguments.length, a = s(o > 1 ? arguments[1] : void 0, i), h = o > 2 ? arguments[2] : void 0, l = void 0 === h ? i : s(h, i); l > a;) e[a++] = t;
            return e
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(8),
            s = i(31);
        t.exports = function(t, e, i) {
            e in t ? n.f(t, e, s(0, i)) : t[e] = i
        }
    }, function(t, e, i) {
        var n = i(5),
            s = i(3).document,
            r = n(s) && n(s.createElement);
        t.exports = function(t) {
            return r ? s.createElement(t) : {}
        }
    }, function(t, e) {
        t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
    }, function(t, e, i) {
        var n = i(6)("match");
        t.exports = function(t) {
            var e = /./;
            try {
                "/./" [t](e)
            } catch (i) {
                try {
                    return e[n] = !1, !"/./" [t](e)
                } catch (t) {}
            }
            return !0
        }
    }, function(t, e, i) {
        t.exports = i(3).document && document.documentElement
    }, function(t, e, i) {
        var n = i(5),
            s = i(60).set;
        t.exports = function(t, e, i) {
            var r, o = e.constructor;
            return o !== i && "function" == typeof o && (r = o.prototype) !== i.prototype && n(r) && s && s(t, r), t
        }
    }, function(t, e, i) {
        var n = i(33),
            s = i(6)("iterator"),
            r = Array.prototype;
        t.exports = function(t) {
            return void 0 !== t && (n.Array === t || r[s] === t)
        }
    }, function(t, e, i) {
        var n = i(19);
        t.exports = Array.isArray || function(t) {
            return "Array" == n(t)
        }
    }, function(t, e, i) {
        var n = i(5),
            s = Math.floor;
        t.exports = function(t) {
            return !n(t) && isFinite(t) && s(t) === t
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(35),
            s = i(31),
            r = i(45),
            o = {};
        i(12)(o, i(6)("iterator"), function() {
            return this
        }), t.exports = function(t, e, i) {
            t.prototype = n(o, {
                next: s(1, i)
            }), r(t, e + " Iterator")
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(34),
            s = i(1),
            r = i(14),
            o = i(12),
            a = i(11),
            h = i(33),
            l = i(74),
            c = i(45),
            u = i(18),
            d = i(6)("iterator"),
            p = !([].keys && "next" in [].keys()),
            f = function() {
                return this
            };
        t.exports = function(t, e, i, g, m, y, v) {
            l(i, e, g);
            var b, x, w, _ = function(t) {
                    if (!p && t in C) return C[t];
                    switch (t) {
                        case "keys":
                        case "values":
                            return function() {
                                return new i(this, t)
                            }
                    }
                    return function() {
                        return new i(this, t)
                    }
                },
                P = e + " Iterator",
                T = "values" == m,
                S = !1,
                C = t.prototype,
                A = C[d] || C["@@iterator"] || m && C[m],
                E = A || _(m),
                M = m ? T ? _("entries") : E : void 0,
                I = "Array" == e && C.entries || A;
            if (I && (w = u(I.call(new t))) !== Object.prototype && (c(w, P, !0), n || a(w, d) || o(w, d, f)), T && A && "values" !== A.name && (S = !0, E = function() {
                    return A.call(this)
                }), n && !v || !p && !S && C[d] || o(C, d, E), h[e] = E, h[P] = f, m)
                if (b = {
                        values: T ? E : _("values"),
                        keys: y ? E : _("keys"),
                        entries: M
                    }, v)
                    for (x in b) x in C || r(C, x, b[x]);
                else s(s.P + s.F * (p || S), e, b);
            return b
        }
    }, function(t, e) {
        var i = Math.expm1;
        t.exports = !i || i(10) > 22025.465794806718 || i(10) < 22025.465794806718 || -2e-17 != i(-2e-17) ? function(t) {
            return 0 == (t = +t) ? t : t > -1e-6 && t < 1e-6 ? t + t * t / 2 : Math.exp(t) - 1
        } : i
    }, function(t, e) {
        t.exports = Math.sign || function(t) {
            return 0 == (t = +t) || t != t ? t : t < 0 ? -1 : 1
        }
    }, function(t, e, i) {
        var n = i(3),
            s = i(85).set,
            r = n.MutationObserver || n.WebKitMutationObserver,
            o = n.process,
            a = n.Promise,
            h = "process" == i(19)(o);
        t.exports = function() {
            var t, e, i, l = function() {
                var n, s;
                for (h && (n = o.domain) && n.exit(); t;) {
                    s = t.fn, t = t.next;
                    try {
                        s()
                    } catch (n) {
                        throw t ? i() : e = void 0, n
                    }
                }
                e = void 0, n && n.enter()
            };
            if (h) i = function() {
                o.nextTick(l)
            };
            else if (r) {
                var c = !0,
                    u = document.createTextNode("");
                new r(l).observe(u, {
                    characterData: !0
                }), i = function() {
                    u.data = c = !c
                }
            } else if (a && a.resolve) {
                var d = a.resolve();
                i = function() {
                    d.then(l)
                }
            } else i = function() {
                s.call(n, l)
            };
            return function(n) {
                var s = {
                    fn: n,
                    next: void 0
                };
                e && (e.next = s), t || (t = s, i()), e = s
            }
        }
    }, function(t, e, i) {
        var n = i(61)("keys"),
            s = i(41);
        t.exports = function(t) {
            return n[t] || (n[t] = s(t))
        }
    }, function(t, e, i) {
        var n = i(2),
            s = i(13),
            r = i(6)("species");
        t.exports = function(t, e) {
            var i, o = n(t).constructor;
            return void 0 === o || void 0 == (i = n(o)[r]) ? e : s(i)
        }
    }, function(t, e, i) {
        var n = i(32),
            s = i(20);
        t.exports = function(t) {
            return function(e, i) {
                var r, o, a = String(s(e)),
                    h = n(i),
                    l = a.length;
                return h < 0 || h >= l ? t ? "" : void 0 : (r = a.charCodeAt(h)) < 55296 || r > 56319 || h + 1 === l || (o = a.charCodeAt(h + 1)) < 56320 || o > 57343 ? t ? a.charAt(h) : r : t ? a.slice(h, h + 2) : o - 56320 + (r - 55296 << 10) + 65536
            }
        }
    }, function(t, e, i) {
        var n = i(56),
            s = i(20);
        t.exports = function(t, e, i) {
            if (n(e)) throw TypeError("String#" + i + " doesn't accept regex!");
            return String(s(t))
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(32),
            s = i(20);
        t.exports = function(t) {
            var e = String(s(this)),
                i = "",
                r = n(t);
            if (r < 0 || r == 1 / 0) throw RangeError("Count can't be negative");
            for (; r > 0;
                (r >>>= 1) && (e += e)) 1 & r && (i += e);
            return i
        }
    }, function(t, e) {
        t.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
    }, function(t, e, i) {
        var n, s, r, o = i(26),
            a = i(55),
            h = i(69),
            l = i(66),
            c = i(3),
            u = c.process,
            d = c.setImmediate,
            p = c.clearImmediate,
            f = c.MessageChannel,
            g = 0,
            m = {},
            y = function() {
                var t = +this;
                if (m.hasOwnProperty(t)) {
                    var e = m[t];
                    delete m[t], e()
                }
            },
            v = function(t) {
                y.call(t.data)
            };
        d && p || (d = function(t) {
            for (var e = [], i = 1; arguments.length > i;) e.push(arguments[i++]);
            return m[++g] = function() {
                a("function" == typeof t ? t : Function(t), e)
            }, n(g), g
        }, p = function(t) {
            delete m[t]
        }, "process" == i(19)(u) ? n = function(t) {
            u.nextTick(o(y, t, 1))
        } : f ? (r = (s = new f).port2, s.port1.onmessage = v, n = o(r.postMessage, r, 1)) : c.addEventListener && "function" == typeof postMessage && !c.importScripts ? (n = function(t) {
            c.postMessage(t + "", "*")
        }, c.addEventListener("message", v, !1)) : n = "onreadystatechange" in l("script") ? function(t) {
            h.appendChild(l("script")).onreadystatechange = function() {
                h.removeChild(this), y.call(t)
            }
        } : function(t) {
            setTimeout(o(y, t, 1), 0)
        }), t.exports = {
            set: d,
            clear: p
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(3),
            s = i(7),
            r = i(34),
            o = i(62),
            a = i(12),
            h = i(38),
            l = i(4),
            c = i(29),
            u = i(32),
            d = i(9),
            p = i(36).f,
            f = i(8).f,
            g = i(64),
            m = i(45),
            y = n.ArrayBuffer,
            v = n.DataView,
            b = n.Math,
            x = (n.parseInt, n.RangeError),
            w = n.Infinity,
            _ = y,
            P = b.abs,
            T = b.pow,
            S = (b.min, b.floor),
            C = b.log,
            A = b.LN2,
            E = s ? "_b" : "buffer",
            M = s ? "_l" : "byteLength",
            I = s ? "_o" : "byteOffset",
            O = function(t, e, i) {
                var n, s, r, o = Array(i),
                    a = 8 * i - e - 1,
                    h = (1 << a) - 1,
                    l = h >> 1,
                    c = 23 === e ? T(2, -24) - T(2, -77) : 0,
                    u = 0,
                    d = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for ((t = P(t)) != t || t === w ? (s = t != t ? 1 : 0, n = h) : (n = S(C(t) / A), t * (r = T(2, -n)) < 1 && (n--, r *= 2), (t += n + l >= 1 ? c / r : c * T(2, 1 - l)) * r >= 2 && (n++, r /= 2), n + l >= h ? (s = 0, n = h) : n + l >= 1 ? (s = (t * r - 1) * T(2, e), n += l) : (s = t * T(2, l - 1) * T(2, e), n = 0)); e >= 8; o[u++] = 255 & s, s /= 256, e -= 8);
                for (n = n << e | s, a += e; a > 0; o[u++] = 255 & n, n /= 256, a -= 8);
                return o[--u] |= 128 * d, o
            },
            k = function(t, e, i) {
                var n, s = 8 * i - e - 1,
                    r = (1 << s) - 1,
                    o = r >> 1,
                    a = s - 7,
                    h = i - 1,
                    l = t[h--],
                    c = 127 & l;
                for (l >>= 7; a > 0; c = 256 * c + t[h], h--, a -= 8);
                for (n = c & (1 << -a) - 1, c >>= -a, a += e; a > 0; n = 256 * n + t[h], h--, a -= 8);
                if (0 === c) c = 1 - o;
                else {
                    if (c === r) return n ? NaN : l ? -w : w;
                    n += T(2, e), c -= o
                }
                return (l ? -1 : 1) * n * T(2, c - e)
            },
            R = function(t) {
                return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
            },
            L = function(t) {
                return [255 & t]
            },
            B = function(t) {
                return [255 & t, t >> 8 & 255]
            },
            F = function(t) {
                return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
            },
            D = function(t) {
                return O(t, 52, 8)
            },
            U = function(t) {
                return O(t, 23, 4)
            },
            G = function(t, e, i) {
                f(t.prototype, e, {
                    get: function() {
                        return this[i]
                    }
                })
            },
            N = function(t, e, i, n) {
                var s = +i,
                    r = u(s);
                if (s != r || r < 0 || r + e > t[M]) throw x("Wrong index!");
                var o = t[E]._b,
                    a = r + t[I],
                    h = o.slice(a, a + e);
                return n ? h : h.reverse()
            },
            X = function(t, e, i, n, s, r) {
                var o = +i,
                    a = u(o);
                if (o != a || a < 0 || a + e > t[M]) throw x("Wrong index!");
                for (var h = t[E]._b, l = a + t[I], c = n(+s), d = 0; d < e; d++) h[l + d] = c[r ? d : e - d - 1]
            },
            j = function(t, e) {
                c(t, y, "ArrayBuffer");
                var i = +e,
                    n = d(i);
                if (i != n) throw x("Wrong length!");
                return n
            };
        if (o.ABV) {
            if (!l(function() {
                    new y
                }) || !l(function() {
                    new y(.5)
                })) {
                for (var W, V = (y = function(t) {
                        return new _(j(this, t))
                    }).prototype = _.prototype, Y = p(_), H = 0; Y.length > H;)(W = Y[H++]) in y || a(y, W, _[W]);
                r || (V.constructor = y)
            }
            var q = new v(new y(2)),
                z = v.prototype.setInt8;
            q.setInt8(0, 2147483648), q.setInt8(1, 2147483649), !q.getInt8(0) && q.getInt8(1) || h(v.prototype, {
                setInt8: function(t, e) {
                    z.call(this, t, e << 24 >> 24)
                },
                setUint8: function(t, e) {
                    z.call(this, t, e << 24 >> 24)
                }
            }, !0)
        } else y = function(t) {
            var e = j(this, t);
            this._b = g.call(Array(e), 0), this[M] = e
        }, v = function(t, e, i) {
            c(this, v, "DataView"), c(t, y, "DataView");
            var n = t[M],
                s = u(e);
            if (s < 0 || s > n) throw x("Wrong offset!");
            if (s + (i = void 0 === i ? n - s : d(i)) > n) throw x("Wrong length!");
            this[E] = t, this[I] = s, this[M] = i
        }, s && (G(y, "byteLength", "_l"), G(v, "buffer", "_b"), G(v, "byteLength", "_l"), G(v, "byteOffset", "_o")), h(v.prototype, {
            getInt8: function(t) {
                return N(this, 1, t)[0] << 24 >> 24
            },
            getUint8: function(t) {
                return N(this, 1, t)[0]
            },
            getInt16: function(t) {
                var e = N(this, 2, t, arguments[1]);
                return (e[1] << 8 | e[0]) << 16 >> 16
            },
            getUint16: function(t) {
                var e = N(this, 2, t, arguments[1]);
                return e[1] << 8 | e[0]
            },
            getInt32: function(t) {
                return R(N(this, 4, t, arguments[1]))
            },
            getUint32: function(t) {
                return R(N(this, 4, t, arguments[1])) >>> 0
            },
            getFloat32: function(t) {
                return k(N(this, 4, t, arguments[1]), 23, 4)
            },
            getFloat64: function(t) {
                return k(N(this, 8, t, arguments[1]), 52, 8)
            },
            setInt8: function(t, e) {
                X(this, 1, t, L, e)
            },
            setUint8: function(t, e) {
                X(this, 1, t, L, e)
            },
            setInt16: function(t, e) {
                X(this, 2, t, B, e, arguments[2])
            },
            setUint16: function(t, e) {
                X(this, 2, t, B, e, arguments[2])
            },
            setInt32: function(t, e) {
                X(this, 4, t, F, e, arguments[2])
            },
            setUint32: function(t, e) {
                X(this, 4, t, F, e, arguments[2])
            },
            setFloat32: function(t, e) {
                X(this, 4, t, U, e, arguments[2])
            },
            setFloat64: function(t, e) {
                X(this, 8, t, D, e, arguments[2])
            }
        });
        m(y, "ArrayBuffer"), m(v, "DataView"), a(v.prototype, o.VIEW, !0), e.ArrayBuffer = y, e.DataView = v
    }, function(t, e, i) {
        var n = i(3),
            s = i(23),
            r = i(34),
            o = i(116),
            a = i(8).f;
        t.exports = function(t) {
            var e = s.Symbol || (s.Symbol = r ? {} : n.Symbol || {});
            "_" == t.charAt(0) || t in e || a(e, t, {
                value: o.f(t)
            })
        }
    }, function(t, e, i) {
        var n = i(43),
            s = i(6)("iterator"),
            r = i(33);
        t.exports = i(23).getIteratorMethod = function(t) {
            if (void 0 != t) return t[s] || t["@@iterator"] || r[n(t)]
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(42),
            s = i(104),
            r = i(33),
            o = i(16);
        t.exports = i(75)(Array, "Array", function(t, e) {
            this._t = o(t), this._i = 0, this._k = e
        }, function() {
            var t = this._t,
                e = this._k,
                i = this._i++;
            return !t || i >= t.length ? (this._t = void 0, s(1)) : s(0, "keys" == e ? i : "values" == e ? t[i] : [i, t[i]])
        }, "values"), r.Arguments = r.Array, n("keys"), n("values"), n("entries")
    }, function(t, e) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        e.default = {
            AUTO_DETECT_THRESHOLD: 8
        }
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var n = function() {
                function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }
                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(),
            s = function t(e, i, n) {
                null === e && (e = Function.prototype);
                var s = Object.getOwnPropertyDescriptor(e, i);
                if (void 0 === s) {
                    var r = Object.getPrototypeOf(e);
                    return null === r ? void 0 : t(r, i, n)
                }
                if ("value" in s) return s.value;
                var o = s.get;
                return void 0 !== o ? o.call(n) : void 0
            },
            r = (o(i(50)), o(i(63)));

        function o(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }
        var a = function(t) {
            function e(t, i) {
                var n = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
                return function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, e),
                    function(t, e) {
                        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !e || "object" != typeof e && "function" != typeof e ? t : e
                    }(this, Object.getPrototypeOf(e).call(this, t, i, {
                        x: i.width,
                        y: i.height
                    }, n))
            }
            return function(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }(e, r.default), n(e, [{
                key: "handleDown",
                value: function(t, i) {
                    this.old = this.down = i[this.o.direction], s(Object.getPrototypeOf(e.prototype), "handleDown", this).call(this, t, i)
                }
            }, {
                key: "handleUp",
                value: function(t, i) {
                    this.current = i[this.o.direction], s(Object.getPrototypeOf(e.prototype), "handleUp", this).call(this, t, i)
                }
            }]), e
        }();
        e.default = a
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var n = function() {
                function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }
                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(),
            s = a(i(93)),
            r = a(i(91)),
            o = i(49);

        function a(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }
        var h = {
                direction: "y",
                autocull: !0,
                momentum: !0,
                bouncing: !0,
                snapping: !1,
                overflow: 100,
                padding: 10,
                searchForClicks: !1,
                offTL: 0,
                offTLSpace: 0,
                offBR: 0,
                blockSize: 0,
                viewMask: !1
            },
            l = function(t) {
                function e(t, i, n) {
                    var s = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, e);
                    var a = function(t, e) {
                        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !e || "object" != typeof e && "function" != typeof e ? t : e
                    }(this, Object.getPrototypeOf(e).call(this, t, i, (0, o.parseBounds)(n), Object.assign({}, h, s)));
                    return a.scroller = new r.default(a.game, a._addMask(n), Object.assign({
                        from: 0,
                        to: 0
                    }, a.options)), a.scroller.events.onUpdate.add(function(t) {
                        a._setPosition(t.total)
                    }), a.events.onAdded.add(function(t) {
                        var e = Math.min(-t, 0);
                        a.scroller.setFromTo(0, e), a.options.searchForClicks && a.scroller.registerClickables(a.items)
                    }), a
                }
                return function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }(e, s.default), n(e, [{
                    key: "destroy",
                    value: function() {
                        this.scroller.destroy(), this.scroller = null,
                            function t(e, i, n) {
                                null === e && (e = Function.prototype);
                                var s = Object.getOwnPropertyDescriptor(e, i);
                                if (void 0 === s) {
                                    var r = Object.getPrototypeOf(e);
                                    return null === r ? void 0 : t(r, i, n)
                                }
                                if ("value" in s) return s.value;
                                var o = s.get;
                                return void 0 !== o ? o.call(n) : void 0
                            }(Object.getPrototypeOf(e.prototype), "destroy", this).call(this)
                    }
                }, {
                    key: "reset",
                    value: function() {
                        this._setPosition(0), this.scroller.reset()
                    }
                }]), e
            }();
        e.default = l
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var n = function() {
                function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }
                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(),
            s = i(49);
        var r = {
                direction: "y",
                autocull: !0,
                padding: 10
            },
            o = function() {
                function t(e, i, n) {
                    var s = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];
                    if (function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), this.game = e, this.parent = i, this.bounds = n, this.o = this.options = Object.assign({}, r, s), this.items = [], "y" == this.o.direction ? this.p = {
                            xy: "y",
                            wh: "height"
                        } : this.p = {
                            xy: "x",
                            wh: "width"
                        }, this.grp = this.game.add.group(i), this.grp.position.set(n.x, n.y), this.o.searchForClicks && "y" == this.o.direction && this.o.blockSize > 0) {
                        var o = MG.game.add.graphics(0, 0);
                        o.beginFill(16711680), o.drawRect(n.x, n.y - this.o.blockSize, n.width, this.o.blockSize), o.drawRect(n.x, n.y + n.height, n.width, this.o.blockSize), o.endFill(), 0 == this.o.viewMask ? o.alpha = 0 : o.alpha = .3, o.inputEnabled = !0, i.addChild(o)
                    }
                    this.events = {
                        onAdded: new Phaser.Signal
                    }, this.position = 0, 0 == this.o.viewMask && (this.grp.mask = this._addMask(n))
                }
                return n(t, [{
                    key: "add",
                    value: function(t) {
                        this.items.push(t);
                        var e = this.o.offTL;
                        if (this.grp.children.length > 0) {
                            var i = this.grp.getChildAt(this.grp.children.length - 1);
                            e = i[this.p.xy] + (0, s.getWidthOrHeight)(i, this.p.wh) + this.o.padding
                        }
                        return t[this.p.xy] = e, this.grp.addChild(t), this.length = e + t[this.p.wh] + this.o.offBR, this.events.onAdded.dispatch(this.length - this.bounds[this.p.wh]), t
                    }
                }, {
                    key: "addMultiple",
                    value: function() {
                        for (var t = arguments.length, e = Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                        e.forEach(this.add, this)
                    }
                }, {
                    key: "remove",
                    value: function(t) {
                        this.grp.removeChild(t);
                        var e = this.items.indexOf(t);
                        if (-1 != e) {
                            for (var i = e + 1; i < this.items.length; ++i) {
                                var n = this.items[i].position;
                                n.set(n.x, n.y - (t[this.p.wh] + this.o.padding))
                            }
                            return this.length -= t[this.p.wh] + this.o.padding, this.events.onAdded.dispatch(this.length - this.bounds[this.p.wh]), this.length > this.bounds.height && this.position < -(this.length - this.bounds.height) ? this.scroller.tweenTo(1, -(this.length - this.bounds.height)) : this.length <= this.bounds.height && this.scroller.tweenTo(1, 0), this.items.splice(e, 1), t
                        }
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.events.onAdded.dispose(), this.events = null, this.grp.destroy(), this.grp = null, this.game = null, this.parent = null, this.items = null
                    }
                }, {
                    key: "removeAll",
                    value: function() {
                        this.grp.removeAll(), this.items = []
                    }
                }, {
                    key: "cull",
                    value: function() {
                        for (var t = 0; t < this.items.length; t++) {
                            var e = this.items[t];
                            e.visible = !0, e[this.p.xy] + e[this.p.wh] + this.grp[this.p.xy] < this.bounds[this.p.xy] + this.o.offTL + this.o.offTLSpace ? e.visible = !1 : e[this.p.xy] + this.grp[this.p.xy] > this.bounds[this.p.xy] + this.bounds[this.p.wh] + this.o.offTL && (e.visible = !1)
                        }
                    }
                }, {
                    key: "setPosition",
                    value: function(t) {
                        this.scroller.setTo(t)
                    }
                }, {
                    key: "tweenToPosition",
                    value: function(t) {
                        var e = arguments.length <= 1 || void 0 === arguments[1] ? 1 : arguments[1];
                        this.scroller.tweenTo(e, t)
                    }
                }, {
                    key: "tweenToItem",
                    value: function(t) {
                        var e = arguments.length <= 1 || void 0 === arguments[1] ? 1 : arguments[1];
                        this.scroller.tweenTo(e, -this.items[t][this.p.xy])
                    }
                }, {
                    key: "_setPosition",
                    value: function(t) {
                        this.position = t, this.grp[this.p.xy] = this.bounds[this.p.xy] + t, this.o.autocull && this.cull()
                    }
                }, {
                    key: "_addMask",
                    value: function(t) {
                        var e = this.game.add.graphics(0, 0, this.parent);
                        return e.beginFill(16711680).drawRect(t.x, t.y, t.width, t.height), e.alpha = 0, e
                    }
                }, {
                    key: "setSize",
                    value: function(t) {
                        this.grp.mask.beginFill(16711680).drawRect(t.x, t.y, t.width, t.height), this.grp.mask = this._addMask(t), this.o.autocull && this.cull()
                    }
                }]), t
            }();
        e.default = o
    }, function(t, e, i) {
        var n = i(19);
        t.exports = function(t, e) {
            if ("number" != typeof t && "Number" != n(t)) throw TypeError(e);
            return +t
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(10),
            s = i(40),
            r = i(9);
        t.exports = [].copyWithin || function(t, e) {
            var i = n(this),
                o = r(i.length),
                a = s(t, o),
                h = s(e, o),
                l = arguments.length > 2 ? arguments[2] : void 0,
                c = Math.min((void 0 === l ? o : s(l, o)) - h, o - a),
                u = 1;
            for (h < a && a < h + c && (u = -1, h += c - 1, a += c - 1); c-- > 0;) h in i ? i[a] = i[h] : delete i[a], a += u, h += u;
            return i
        }
    }, function(t, e, i) {
        var n = i(44);
        t.exports = function(t, e) {
            var i = [];
            return n(t, !1, i.push, i, e), i
        }
    }, function(t, e, i) {
        var n = i(13),
            s = i(10),
            r = i(47),
            o = i(9);
        t.exports = function(t, e, i, a, h) {
            n(e);
            var l = s(t),
                c = r(l),
                u = o(l.length),
                d = h ? u - 1 : 0,
                p = h ? -1 : 1;
            if (i < 2)
                for (;;) {
                    if (d in c) {
                        a = c[d], d += p;
                        break
                    }
                    if (d += p, h ? d < 0 : u <= d) throw TypeError("Reduce of empty array with no initial value")
                }
            for (; h ? d >= 0 : u > d; d += p) d in c && (a = e(a, c[d], d, l));
            return a
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(13),
            s = i(5),
            r = i(55),
            o = [].slice,
            a = {};
        t.exports = Function.bind || function(t) {
            var e = n(this),
                i = o.call(arguments, 1),
                h = function() {
                    var n = i.concat(o.call(arguments));
                    return this instanceof h ? function(t, e, i) {
                        if (!(e in a)) {
                            for (var n = [], s = 0; s < e; s++) n[s] = "a[" + s + "]";
                            a[e] = Function("F,a", "return new F(" + n.join(",") + ")")
                        }
                        return a[e](t, i)
                    }(e, n.length, n) : r(e, n, t)
                };
            return s(e.prototype) && (h.prototype = e.prototype), h
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(8).f,
            s = i(35),
            r = (i(12), i(38)),
            o = i(26),
            a = i(29),
            h = i(20),
            l = i(44),
            c = i(75),
            u = i(104),
            d = i(39),
            p = i(7),
            f = i(30).fastKey,
            g = p ? "_s" : "size",
            m = function(t, e) {
                var i, n = f(e);
                if ("F" !== n) return t._i[n];
                for (i = t._f; i; i = i.n)
                    if (i.k == e) return i
            };
        t.exports = {
            getConstructor: function(t, e, i, c) {
                var u = t(function(t, n) {
                    a(t, u, e, "_i"), t._i = s(null), t._f = void 0, t._l = void 0, t[g] = 0, void 0 != n && l(n, i, t[c], t)
                });
                return r(u.prototype, {
                    clear: function() {
                        for (var t = this._i, e = this._f; e; e = e.n) e.r = !0, e.p && (e.p = e.p.n = void 0), delete t[e.i];
                        this._f = this._l = void 0, this[g] = 0
                    },
                    delete: function(t) {
                        var e = m(this, t);
                        if (e) {
                            var i = e.n,
                                n = e.p;
                            delete this._i[e.i], e.r = !0, n && (n.n = i), i && (i.p = n), this._f == e && (this._f = i), this._l == e && (this._l = n), this[g]--
                        }
                        return !!e
                    },
                    forEach: function(t) {
                        a(this, u, "forEach");
                        for (var e, i = o(t, arguments.length > 1 ? arguments[1] : void 0, 3); e = e ? e.n : this._f;)
                            for (i(e.v, e.k, this); e && e.r;) e = e.p
                    },
                    has: function(t) {
                        return !!m(this, t)
                    }
                }), p && n(u.prototype, "size", {
                    get: function() {
                        return h(this[g])
                    }
                }), u
            },
            def: function(t, e, i) {
                var n, s, r = m(t, e);
                return r ? r.v = i : (t._l = r = {
                    i: s = f(e, !0),
                    k: e,
                    v: i,
                    p: n = t._l,
                    n: void 0,
                    r: !1
                }, t._f || (t._f = r), n && (n.n = r), t[g]++, "F" !== s && (t._i[s] = r)), t
            },
            getEntry: m,
            setStrong: function(t, e, i) {
                c(t, e, function(t, e) {
                    this._t = t, this._k = e, this._l = void 0
                }, function() {
                    for (var t = this._k, e = this._l; e && e.r;) e = e.p;
                    return this._t && (this._l = e = e ? e.n : this._t._f) ? u(0, "keys" == t ? e.k : "values" == t ? e.v : [e.k, e.v]) : (this._t = void 0, u(1))
                }, i ? "entries" : "values", !i, !0), d(e)
            }
        }
    }, function(t, e, i) {
        var n = i(43),
            s = i(96);
        t.exports = function(t) {
            return function() {
                if (n(this) != t) throw TypeError(t + "#toJSON isn't generic");
                return s(this)
            }
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(38),
            s = i(30).getWeak,
            r = i(2),
            o = i(5),
            a = i(29),
            h = i(44),
            l = i(22),
            c = i(11),
            u = l(5),
            d = l(6),
            p = 0,
            f = function(t) {
                return t._l || (t._l = new g)
            },
            g = function() {
                this.a = []
            },
            m = function(t, e) {
                return u(t.a, function(t) {
                    return t[0] === e
                })
            };
        g.prototype = {
            get: function(t) {
                var e = m(this, t);
                if (e) return e[1]
            },
            has: function(t) {
                return !!m(this, t)
            },
            set: function(t, e) {
                var i = m(this, t);
                i ? i[1] = e : this.a.push([t, e])
            },
            delete: function(t) {
                var e = d(this.a, function(e) {
                    return e[0] === t
                });
                return ~e && this.a.splice(e, 1), !!~e
            }
        }, t.exports = {
            getConstructor: function(t, e, i, r) {
                var l = t(function(t, n) {
                    a(t, l, e, "_i"), t._i = p++, t._l = void 0, void 0 != n && h(n, i, t[r], t)
                });
                return n(l.prototype, {
                    delete: function(t) {
                        if (!o(t)) return !1;
                        var e = s(t);
                        return !0 === e ? f(this).delete(t) : e && c(e, this._i) && delete e[this._i]
                    },
                    has: function(t) {
                        if (!o(t)) return !1;
                        var e = s(t);
                        return !0 === e ? f(this).has(t) : e && c(e, this._i)
                    }
                }), l
            },
            def: function(t, e, i) {
                var n = s(r(e), !0);
                return !0 === n ? f(t).set(e, i) : n[t._i] = i, t
            },
            ufstore: f
        }
    }, function(t, e, i) {
        t.exports = !i(7) && !i(4)(function() {
            return 7 != Object.defineProperty(i(66)("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        })
    }, function(t, e, i) {
        var n = i(2);
        t.exports = function(t, e, i, s) {
            try {
                return s ? e(n(i)[0], i[1]) : e(i)
            } catch (e) {
                var r = t.return;
                throw void 0 !== r && n(r.call(t)), e
            }
        }
    }, function(t, e) {
        t.exports = function(t, e) {
            return {
                value: e,
                done: !!t
            }
        }
    }, function(t, e) {
        t.exports = Math.log1p || function(t) {
            return (t = +t) > -1e-8 && t < 1e-8 ? t - t * t / 2 : Math.log(1 + t)
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(37),
            s = i(59),
            r = i(48),
            o = i(10),
            a = i(47),
            h = Object.assign;
        t.exports = !h || i(4)(function() {
            var t = {},
                e = {},
                i = Symbol(),
                n = "abcdefghijklmnopqrst";
            return t[i] = 7, n.split("").forEach(function(t) {
                e[t] = t
            }), 7 != h({}, t)[i] || Object.keys(h({}, e)).join("") != n
        }) ? function(t, e) {
            for (var i = o(t), h = arguments.length, l = 1, c = s.f, u = r.f; h > l;)
                for (var d, p = a(arguments[l++]), f = c ? n(p).concat(c(p)) : n(p), g = f.length, m = 0; g > m;) u.call(p, d = f[m++]) && (i[d] = p[d]);
            return i
        } : h
    }, function(t, e, i) {
        var n = i(8),
            s = i(2),
            r = i(37);
        t.exports = i(7) ? Object.defineProperties : function(t, e) {
            s(t);
            for (var i, o = r(e), a = o.length, h = 0; a > h;) n.f(t, i = o[h++], e[i]);
            return t
        }
    }, function(t, e, i) {
        var n = i(16),
            s = i(36).f,
            r = {}.toString,
            o = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        t.exports.f = function(t) {
            return o && "[object Window]" == r.call(t) ? function(t) {
                try {
                    return s(t)
                } catch (t) {
                    return o.slice()
                }
            }(t) : s(n(t))
        }
    }, function(t, e, i) {
        var n = i(11),
            s = i(16),
            r = i(51)(!1),
            o = i(79)("IE_PROTO");
        t.exports = function(t, e) {
            var i, a = s(t),
                h = 0,
                l = [];
            for (i in a) i != o && n(a, i) && l.push(i);
            for (; e.length > h;) n(a, i = e[h++]) && (~r(l, i) || l.push(i));
            return l
        }
    }, function(t, e, i) {
        var n = i(37),
            s = i(16),
            r = i(48).f;
        t.exports = function(t) {
            return function(e) {
                for (var i, o = s(e), a = n(o), h = a.length, l = 0, c = []; h > l;) r.call(o, i = a[l++]) && c.push(t ? [i, o[i]] : o[i]);
                return c
            }
        }
    }, function(t, e, i) {
        var n = i(36),
            s = i(59),
            r = i(2),
            o = i(3).Reflect;
        t.exports = o && o.ownKeys || function(t) {
            var e = n.f(r(t)),
                i = s.f;
            return i ? e.concat(i(t)) : e
        }
    }, function(t, e, i) {
        var n = i(3).parseFloat,
            s = i(46).trim;
        t.exports = 1 / n(i(84) + "-0") != -1 / 0 ? function(t) {
            var e = s(String(t), 3),
                i = n(e);
            return 0 === i && "-" == e.charAt(0) ? -0 : i
        } : n
    }, function(t, e, i) {
        var n = i(3).parseInt,
            s = i(46).trim,
            r = i(84),
            o = /^[\-+]?0[xX]/;
        t.exports = 8 !== n(r + "08") || 22 !== n(r + "0x16") ? function(t, e) {
            var i = s(String(t), 3);
            return n(i, e >>> 0 || (o.test(i) ? 16 : 10))
        } : n
    }, function(t, e) {
        t.exports = Object.is || function(t, e) {
            return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e
        }
    }, function(t, e, i) {
        var n = i(9),
            s = i(83),
            r = i(20);
        t.exports = function(t, e, i, o) {
            var a = String(r(t)),
                h = a.length,
                l = void 0 === i ? " " : String(i),
                c = n(e);
            if (c <= h || "" == l) return a;
            var u = c - h,
                d = s.call(l, Math.ceil(u / l.length));
            return d.length > u && (d = d.slice(0, u)), o ? d + a : a + d
        }
    }, function(t, e, i) {
        e.f = i(6)
    }, function(t, e, i) {
        "use strict";
        var n = i(99);
        t.exports = i(52)("Map", function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }, {
            get: function(t) {
                var e = n.getEntry(this, t);
                return e && e.v
            },
            set: function(t, e) {
                return n.def(this, 0 === t ? 0 : t, e)
            }
        }, n, !0)
    }, function(t, e, i) {
        i(7) && "g" != /./g.flags && i(8).f(RegExp.prototype, "flags", {
            configurable: !0,
            get: i(54)
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(99);
        t.exports = i(52)("Set", function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }, {
            add: function(t) {
                return n.def(this, t = 0 === t ? 0 : t, t)
            }
        }, n)
    }, function(t, e, i) {
        "use strict";
        var n, s = i(22)(0),
            r = i(14),
            o = i(30),
            a = i(106),
            h = i(101),
            l = i(5),
            c = (i(11), o.getWeak),
            u = Object.isExtensible,
            d = h.ufstore,
            p = {},
            f = function(t) {
                return function() {
                    return t(this, arguments.length > 0 ? arguments[0] : void 0)
                }
            },
            g = {
                get: function(t) {
                    if (l(t)) {
                        var e = c(t);
                        return !0 === e ? d(this).get(t) : e ? e[this._i] : void 0
                    }
                },
                set: function(t, e) {
                    return h.def(this, t, e)
                }
            },
            m = t.exports = i(52)("WeakMap", f, g, h, !0, !0);
        7 != (new m).set((Object.freeze || Object)(p), 7).get(p) && (a((n = h.getConstructor(f)).prototype, g), o.NEED = !0, s(["delete", "has", "get", "set"], function(t) {
            var e = m.prototype,
                i = e[t];
            r(e, t, function(e, s) {
                if (l(e) && !u(e)) {
                    this._f || (this._f = new n);
                    var r = this._f[t](e, s);
                    return "set" == t ? this : r
                }
                return i.call(this, e, s)
            })
        }))
    }, function(t, e, i) {
        (function(e, n, s) {
            (function() {
                var n;
                n = function() {
                    "use strict";

                    function t(t) {
                        return "function" == typeof t
                    }
                    var n = Array.isArray ? Array.isArray : function(t) {
                            return "[object Array]" === Object.prototype.toString.call(t)
                        },
                        r = 0,
                        o = void 0,
                        a = void 0,
                        h = function(t, e) {
                            g[r] = t, g[r + 1] = e, 2 === (r += 2) && (a ? a(m) : w())
                        };
                    var l = "undefined" != typeof window ? window : void 0,
                        c = l || {},
                        u = c.MutationObserver || c.WebKitMutationObserver,
                        d = "undefined" == typeof self && void 0 !== e && "[object process]" === {}.toString.call(e),
                        p = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel;

                    function f() {
                        var t = setTimeout;
                        return function() {
                            return t(m, 1)
                        }
                    }
                    var g = new Array(1e3);

                    function m() {
                        for (var t = 0; t < r; t += 2) {
                            (0, g[t])(g[t + 1]), g[t] = void 0, g[t + 1] = void 0
                        }
                        r = 0
                    }
                    var y, v, b, x, w = void 0;

                    function _(t, e) {
                        var i = arguments,
                            n = this,
                            s = new this.constructor(S);
                        void 0 === s[T] && j(s);
                        var r, o = n._state;
                        return o ? (r = i[o - 1], h(function() {
                            return N(o, s, r, n._result)
                        })) : F(n, s, t, e), s
                    }

                    function P(t) {
                        if (t && "object" == typeof t && t.constructor === this) return t;
                        var e = new this(S);
                        return k(e, t), e
                    }
                    d ? w = function() {
                        return e.nextTick(m)
                    } : u ? (v = 0, b = new u(m), x = document.createTextNode(""), b.observe(x, {
                        characterData: !0
                    }), w = function() {
                        x.data = v = ++v % 2
                    }) : p ? ((y = new MessageChannel).port1.onmessage = m, w = function() {
                        return y.port2.postMessage(0)
                    }) : w = void 0 === l ? function() {
                        try {
                            var t = i(312);
                            return void 0 !== (o = t.runOnLoop || t.runOnContext) ? function() {
                                o(m)
                            } : f()
                        } catch (t) {
                            return f()
                        }
                    }() : f();
                    var T = Math.random().toString(36).substring(16);

                    function S() {}
                    var C = void 0,
                        A = 1,
                        E = 2,
                        M = new U;

                    function I(t) {
                        try {
                            return t.then
                        } catch (t) {
                            return M.error = t, M
                        }
                    }

                    function O(e, i, n) {
                        i.constructor === e.constructor && n === _ && i.constructor.resolve === P ? function(t, e) {
                            e._state === A ? L(t, e._result) : e._state === E ? B(t, e._result) : F(e, void 0, function(e) {
                                return k(t, e)
                            }, function(e) {
                                return B(t, e)
                            })
                        }(e, i) : n === M ? B(e, M.error) : void 0 === n ? L(e, i) : t(n) ? function(t, e, i) {
                            h(function(t) {
                                var n = !1,
                                    s = function(t, e, i, n) {
                                        try {
                                            t.call(e, i, n)
                                        } catch (t) {
                                            return t
                                        }
                                    }(i, e, function(i) {
                                        n || (n = !0, e !== i ? k(t, i) : L(t, i))
                                    }, function(e) {
                                        n || (n = !0, B(t, e))
                                    }, t._label);
                                !n && s && (n = !0, B(t, s))
                            }, t)
                        }(e, i, n) : L(e, i)
                    }

                    function k(t, e) {
                        var i;
                        t === e ? B(t, new TypeError("You cannot resolve a promise with itself")) : "function" == typeof(i = e) || "object" == typeof i && null !== i ? O(t, e, I(e)) : L(t, e)
                    }

                    function R(t) {
                        t._onerror && t._onerror(t._result), D(t)
                    }

                    function L(t, e) {
                        t._state === C && (t._result = e, t._state = A, 0 !== t._subscribers.length && h(D, t))
                    }

                    function B(t, e) {
                        t._state === C && (t._state = E, t._result = e, h(R, t))
                    }

                    function F(t, e, i, n) {
                        var s = t._subscribers,
                            r = s.length;
                        t._onerror = null, s[r] = e, s[r + A] = i, s[r + E] = n, 0 === r && t._state && h(D, t)
                    }

                    function D(t) {
                        var e = t._subscribers,
                            i = t._state;
                        if (0 !== e.length) {
                            for (var n = void 0, s = void 0, r = t._result, o = 0; o < e.length; o += 3) n = e[o], s = e[o + i], n ? N(i, n, s, r) : s(r);
                            t._subscribers.length = 0
                        }
                    }

                    function U() {
                        this.error = null
                    }
                    var G = new U;

                    function N(e, i, n, s) {
                        var r = t(n),
                            o = void 0,
                            a = void 0,
                            h = void 0,
                            l = void 0;
                        if (r) {
                            if ((o = function(t, e) {
                                    try {
                                        return t(e)
                                    } catch (t) {
                                        return G.error = t, G
                                    }
                                }(n, s)) === G ? (l = !0, a = o.error, o = null) : h = !0, i === o) return void B(i, new TypeError("A promises callback cannot return that same promise."))
                        } else o = s, h = !0;
                        i._state !== C || (r && h ? k(i, o) : l ? B(i, a) : e === A ? L(i, o) : e === E && B(i, o))
                    }
                    var X = 0;

                    function j(t) {
                        t[T] = X++, t._state = void 0, t._result = void 0, t._subscribers = []
                    }

                    function W(t, e) {
                        this._instanceConstructor = t, this.promise = new t(S), this.promise[T] || j(this.promise), n(e) ? (this._input = e, this.length = e.length, this._remaining = e.length, this._result = new Array(this.length), 0 === this.length ? L(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(), 0 === this._remaining && L(this.promise, this._result))) : B(this.promise, new Error("Array Methods must be provided an Array"))
                    }

                    function V(t) {
                        this[T] = X++, this._result = this._state = void 0, this._subscribers = [], S !== t && ("function" != typeof t && function() {
                            throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")
                        }(), this instanceof V ? function(t, e) {
                            try {
                                e(function(e) {
                                    k(t, e)
                                }, function(e) {
                                    B(t, e)
                                })
                            } catch (e) {
                                B(t, e)
                            }
                        }(this, t) : function() {
                            throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")
                        }())
                    }
                    return W.prototype._enumerate = function() {
                        for (var t = this.length, e = this._input, i = 0; this._state === C && i < t; i++) this._eachEntry(e[i], i)
                    }, W.prototype._eachEntry = function(t, e) {
                        var i = this._instanceConstructor,
                            n = i.resolve;
                        if (n === P) {
                            var s = I(t);
                            if (s === _ && t._state !== C) this._settledAt(t._state, e, t._result);
                            else if ("function" != typeof s) this._remaining--, this._result[e] = t;
                            else if (i === V) {
                                var r = new i(S);
                                O(r, t, s), this._willSettleAt(r, e)
                            } else this._willSettleAt(new i(function(e) {
                                return e(t)
                            }), e)
                        } else this._willSettleAt(n(t), e)
                    }, W.prototype._settledAt = function(t, e, i) {
                        var n = this.promise;
                        n._state === C && (this._remaining--, t === E ? B(n, i) : this._result[e] = i), 0 === this._remaining && L(n, this._result)
                    }, W.prototype._willSettleAt = function(t, e) {
                        var i = this;
                        F(t, void 0, function(t) {
                            return i._settledAt(A, e, t)
                        }, function(t) {
                            return i._settledAt(E, e, t)
                        })
                    }, V.all = function(t) {
                        return new W(this, t).promise
                    }, V.race = function(t) {
                        var e = this;
                        return n(t) ? new e(function(i, n) {
                            for (var s = t.length, r = 0; r < s; r++) e.resolve(t[r]).then(i, n)
                        }) : new e(function(t, e) {
                            return e(new TypeError("You must pass an array to race."))
                        })
                    }, V.resolve = P, V.reject = function(t) {
                        var e = new this(S);
                        return B(e, t), e
                    }, V._setScheduler = function(t) {
                        a = t
                    }, V._setAsap = function(t) {
                        h = t
                    }, V._asap = h, V.prototype = {
                        constructor: V,
                        then: _,
                        catch: function(t) {
                            return this.then(null, t)
                        }
                    }, V.polyfill = function() {
                        var t = void 0;
                        if (void 0 !== s) t = s;
                        else if ("undefined" != typeof self) t = self;
                        else try {
                            t = Function("return this")()
                        } catch (t) {
                            throw new Error("polyfill failed because global object is unavailable in this environment")
                        }
                        var e = t.Promise;
                        if (e) {
                            var i = null;
                            try {
                                i = Object.prototype.toString.call(e.resolve())
                            } catch (t) {}
                            if ("[object Promise]" === i && !e.cast) return
                        }
                        t.Promise = V
                    }, V.Promise = V, V
                }, t.exports = n(), t.exports = s.Promise
            }).call(s)
        }).call(e, i(122), i(121), function() {
            return this
        }())
    }, function(t, e) {
        var i, n, s = t.exports = {};

        function r() {
            throw new Error("setTimeout has not been defined")
        }

        function o() {
            throw new Error("clearTimeout has not been defined")
        }

        function a(t) {
            if (i === setTimeout) return setTimeout(t, 0);
            if ((i === r || !i) && setTimeout) return i = setTimeout, setTimeout(t, 0);
            try {
                return i(t, 0)
            } catch (e) {
                try {
                    return i.call(null, t, 0)
                } catch (e) {
                    return i.call(this, t, 0)
                }
            }
        }! function() {
            try {
                i = "function" == typeof setTimeout ? setTimeout : r
            } catch (t) {
                i = r
            }
            try {
                n = "function" == typeof clearTimeout ? clearTimeout : o
            } catch (t) {
                n = o
            }
        }();
        var h, l = [],
            c = !1,
            u = -1;

        function d() {
            c && h && (c = !1, h.length ? l = h.concat(l) : u = -1, l.length && p())
        }

        function p() {
            if (!c) {
                var t = a(d);
                c = !0;
                for (var e = l.length; e;) {
                    for (h = l, l = []; ++u < e;) h && h[u].run();
                    u = -1, e = l.length
                }
                h = null, c = !1,
                    function(t) {
                        if (n === clearTimeout) return clearTimeout(t);
                        if ((n === o || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t);
                        try {
                            n(t)
                        } catch (e) {
                            try {
                                return n.call(null, t)
                            } catch (e) {
                                return n.call(this, t)
                            }
                        }
                    }(t)
            }
        }

        function f(t, e) {
            this.fun = t, this.array = e
        }

        function g() {}
        s.nextTick = function(t) {
            var e = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
            l.push(new f(t, e)), 1 !== l.length || c || a(p)
        }, f.prototype.run = function() {
            this.fun.apply(null, this.array)
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {}, s.on = g, s.addListener = g, s.once = g, s.off = g, s.removeListener = g, s.removeAllListeners = g, s.emit = g, s.binding = function(t) {
            throw new Error("process.binding is not supported")
        }, s.cwd = function() {
            return "/"
        }, s.chdir = function(t) {
            throw new Error("process.chdir is not supported")
        }, s.umask = function() {
            return 0
        }
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var n, s = function() {
                function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }
                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(),
            r = i(50),
            o = (n = r) && n.__esModule ? n : {
                default: n
            };
        var a = new Phaser.Point,
            h = {
                from: 0,
                to: 200,
                direction: "y",
                snapStep: 10,
                duration: 1,
                time: {},
                swipeThreshold: 5,
                swipeTimeThreshold: 250,
                addListeners: !0
            },
            l = function() {
                function t(e, i) {
                    var n = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.game = e, this.clickObject = i, this.o = this.options = Object.assign({}, h, n), this._updateMinMax(), this.addListeners(), this.scrollObject = {}, this.scrollObject[this.o.direction] = this.o.from, this.tweenScroll = this.game.add.tween(this.scrollObject).to({}, 0, Phaser.Easing.Quartic.Out), this.tweenScroll.onUpdateCallback(this.handleUpdate, this), this.tweenScroll.onComplete.add(this.handleComplete, this)
                }
                return s(t, [{
                    key: "addListeners",
                    value: function() {
                        this.events = {
                            onUpdate: new Phaser.Signal,
                            onInputUp: new Phaser.Signal,
                            onInputDown: new Phaser.Signal,
                            onInputMove: new Phaser.Signal,
                            onComplete: new Phaser.Signal,
                            onSwipe: new Phaser.Signal
                        }, this.enable(), this.o.addListeners && (this.clickObject.inputEnabled = !0, this.clickObject.events.onInputDown.add(this.handleDown, this), this.clickObject.events.onInputUp.add(this.handleUp, this))
                    }
                }, {
                    key: "removeListeners",
                    value: function() {
                        for (var t in this.o.addListeners && (this.clickObject.events.onInputDown.remove(this.handleDown, this), this.clickObject.events.onInputUp.remove(this.handleUp, this)), this.events) this.events.hasOwnProperty(t) && this.events[t].removeAll()
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeListeners()
                    }
                }, {
                    key: "enable",
                    value: function() {
                        this.enabled = !0
                    }
                }, {
                    key: "disable",
                    value: function() {
                        this.enabled = !1
                    }
                }, {
                    key: "isTweening",
                    value: function() {
                        return this.tweenScroll.isRunning
                    }
                }, {
                    key: "handleDown",
                    value: function(t, e) {
                        this.enabled ? (this.clickBlocked = !1, this.isDown = !0, this.old = this.down = e[this.o.direction], this.target = 0, this.o.time.down = e.timeDown, this.o.addListeners && this.game.input.addMoveCallback(this.handleMove, this), this.tweenScroll.stop(), this.tweenScroll.pendingDelete = !1, this.events.onInputDown.dispatch(t, e)) : this.clickBlocked = !0
                    }
                }, {
                    key: "handleMove",
                    value: function(t, e, i) {
                        this.enabled && (a.set(e, i), this.diff = this.old - a[this.o.direction], this.target -= this.diff, this.old = a[this.o.direction], this.o.time.move = this.game.time.time, this.scrollObject[this.o.direction] = this.target, this.handleUpdate(), this.o.emitMoving && this.events.onInputMove.dispatch(t, e, i))
                    }
                }, {
                    key: "handleUp",
                    value: function(t, e) {
                        if (this.enabled && !this.clickBlocked) {
                            this.isDown = !1, this.o.addListeners && this.game.input.deleteMoveCallback(this.handleMove, this), this.o.time.up = e.timeUp;
                            var i = {
                                duration: this.o.duration,
                                target: this.target
                            };
                            this._addSwiping(i, e), this._addSnapping(i), this.tweenTo(i.duration, i.target), this.events.onInputUp.dispatch(t, e)
                        }
                    }
                }, {
                    key: "_addSwiping",
                    value: function(t, e) {
                        var i = Math.abs(this.down - this.old);
                        if (this.o.time.up - this.o.time.down < this.o.swipeTimeThreshold && i > this.o.swipeThreshold) {
                            var n = e[this.o.direction] < this.down ? "forward" : "backward";
                            "forward" == n ? t.target -= this.o.snapStep / 2 : t.target += this.o.snapStep / 2, this.events.onSwipe.dispatch(n)
                        }
                        return t
                    }
                }, {
                    key: "_addSnapping",
                    value: function(t) {
                        return t.target = o.default.nearestMultiple(t.target, this.o.snapStep), t
                    }
                }, {
                    key: "tweenTo",
                    value: function(t, e) {
                        var i = {};
                        i[this.o.direction] = e, this.tweenScroll.onUpdateCallback(this.handleUpdate, this), this.tweenScroll.onComplete.add(this.handleComplete, this), this.tweenScroll.updateTweenData("vEnd", i, -1), this.tweenScroll.updateTweenData("duration", 1e3 * t, -1), this.tweenScroll.updateTweenData("percent ", 0, -1), this.tweenScroll.start()
                    }
                }, {
                    key: "handleUpdate",
                    value: function() {
                        this.events.onUpdate.dispatch(o.default.scaleBetween(-1, 1, o.default.percentageBetween2(this.scrollObject[this.o.direction], -this.length, this.length)))
                    }
                }, {
                    key: "handleComplete",
                    value: function() {
                        this.o.multiplier = 1, this.events.onComplete.dispatch()
                    }
                }, {
                    key: "_updateMinMax",
                    value: function() {
                        this.min = Math.min(this.o.from, this.o.to), this.max = Math.max(this.o.from, this.o.to), this.length = Math.abs(this.max - this.min), this.o.snapStep = this.length
                    }
                }]), t
            }();
        e.default = l
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        }), e.ScrollerEventDispatcher = e.BasicSwiper = e.DirectionalScroller = e.WheelScroller = e.SwipeCarousel = e.ListViewCore = e.ListView = e.Scroller = void 0;
        var n = u(i(63)),
            s = u(i(92)),
            r = u(i(93)),
            o = u(i(126)),
            a = u(i(127)),
            h = u(i(91)),
            l = u(i(123)),
            c = u(i(125));

        function u(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }
        var d = {
            Scroller: n.default,
            ListView: s.default,
            ListViewCore: r.default,
            SwipeCarousel: o.default,
            WheelScroller: a.default,
            DirectionalScroller: h.default,
            BasicSwiper: l.default,
            ScrollerEventDispatcher: c.default
        };
        e.Scroller = n.default, e.ListView = s.default, e.ListViewCore = r.default, e.SwipeCarousel = o.default, e.WheelScroller = a.default, e.DirectionalScroller = h.default, e.BasicSwiper = l.default, e.ScrollerEventDispatcher = c.default, window.PhaserListView = d, e.default = d
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var n, s = function() {
                function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }
                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(),
            r = i(49),
            o = i(90);
        var a = {
                direction: "auto",
                autoDetectThreshold: ((n = o) && n.__esModule ? n : {
                    default: n
                }).default.AUTO_DETECT_THRESHOLD
            },
            h = function() {
                function t(e, i) {
                    var n = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, t), this.game = e, this.clickObject = i, this.clickables = [], this.o = this.options = Object.assign({}, a, n), this.addListeners()
                }
                return s(t, [{
                    key: "addListeners",
                    value: function() {
                        this.events = {
                            onInputUp: new Phaser.Signal,
                            onInputDown: new Phaser.Signal,
                            onInputMove: new Phaser.Signal,
                            onDirectionSet: new Phaser.Signal
                        }, this.clickObject.inputEnabled = !0, this.enable(), this.clickObject.events.onInputDown.add(this.handleDown, this), this.clickObject.events.onInputUp.add(this.handleUp, this)
                    }
                }, {
                    key: "removeListeners",
                    value: function() {
                        for (var t in this.clickObject.events.onInputDown.remove(this.handleDown, this), this.clickObject.events.onInputUp.remove(this.handleUp, this), this.events) this.events.hasOwnProperty(t) && this.events[t].removeAll()
                    }
                }, {
                    key: "destroy",
                    value: function() {
                        this.removeListeners()
                    }
                }, {
                    key: "enable",
                    value: function() {
                        this.enabled = !0
                    }
                }, {
                    key: "disable",
                    value: function() {
                        this.enabled = !1
                    }
                }, {
                    key: "setDirection",
                    value: function(t) {
                        this.direction = t, this.events.onDirectionSet.dispatch(t)
                    }
                }, {
                    key: "registerClickables",
                    value: function(t) {
                        this.clickables = t
                    }
                }, {
                    key: "dispatchClicks",
                    value: function(t, e, i) {
                        var n = (0, r.dispatchClicks)(t, e, i);
                        return "onInputDown" == i && (this.currentDown = n), n
                    }
                }, {
                    key: "handleDown",
                    value: function(t, e) {
                        var i = this;
                        this.enabled ? (this.clickBlocked = !1, "auto" == this.o.direction ? (this.direction = null, this.old = null) : (this.setDirection(this.o.direction), this.old = this.down = e[this.direction]), this.game.input.addMoveCallback(this.handleMove, this), this.dispatchClicks(e, this.clickables, "onInputDown"), this.events.onInputDown.dispatch(t, e, function(t, n) {
                            return i.dispatchClicks(e, t, "onInputDown")
                        })) : this.clickBlocked = !0
                    }
                }, {
                    key: "handleMove",
                    value: function(t, e, i) {
                        if (this.enabled) {
                            if (!this.direction && "auto" == this.o.direction) {
                                var n = Math.abs(t.positionDown.x - e),
                                    s = Math.abs(t.positionDown.y - i);
                                if (!(n > this.o.autoDetectThreshold || s > this.o.autoDetectThreshold)) return;
                                this._cancelCurrentDown(t);
                                var r = n > s ? "x" : "y";
                                this.setDirection(r)
                            }
                            this.events.onInputMove.dispatch(t, e, i)
                        }
                    }
                }, {
                    key: "handleUp",
                    value: function(t, e) {
                        var i = this;
                        this.enabled && !this.clickBlocked && (this.game.input.deleteMoveCallback(this.handleMove, this), this.dispatchClicks(e, this.clickables, "onInputUp"), this.events.onInputUp.dispatch(t, e, function(t, n) {
                            return i.dispatchClicks(e, t, "onInputUp")
                        }), this.currentDown = null)
                    }
                }, {
                    key: "_cancelCurrentDown",
                    value: function(t) {
                        this.currentDown && this.currentDown.events && this.currentDown.events.onInputUp && this.currentDown.events.onInputUp.dispatch(this.currentDown, t, !1), this.currentDown = null
                    }
                }]), t
            }();
        e.default = h
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var n, s = i(92),
            r = (n = s) && n.__esModule ? n : {
                default: n
            };
        var o = {
                direction: "x",
                autocull: !0,
                momentum: !1,
                bouncing: !0,
                snapping: !0,
                overflow: 100,
                padding: 10,
                swipeEnabled: !0,
                offset: {
                    x: 100
                }
            },
            a = function(t) {
                function e(t, i, n) {
                    var s = arguments.length <= 3 || void 0 === arguments[3] ? {} : arguments[3];
                    ! function(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }(this, e);
                    var r = function(t, e) {
                        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !e || "object" != typeof e && "function" != typeof e ? t : e
                    }(this, Object.getPrototypeOf(e).call(this, t, i, n, Object.assign({}, o, s)));
                    return r.scroller.options.snapStep = n.width + r.o.padding, r
                }
                return function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }(e, r.default), e
            }();
        e.default = a
    }, function(t, e, i) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var n = function() {
                function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }
                return function(e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }(),
            s = function t(e, i, n) {
                null === e && (e = Function.prototype);
                var s = Object.getOwnPropertyDescriptor(e, i);
                if (void 0 === s) {
                    var r = Object.getPrototypeOf(e);
                    return null === r ? void 0 : t(r, i, n)
                }
                if ("value" in s) return s.value;
                var o = s.get;
                return void 0 !== o ? o.call(n) : void 0
            },
            r = (o(i(50)), o(i(63)));

        function o(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }
        var a = Phaser.Math,
            h = a.radToDeg,
            l = a.degToRad,
            c = new Phaser.Point,
            u = {
                direction: "angle",
                infinite: !1,
                speedLimit: 1.5
            },
            d = function(t) {
                function e(t, i) {
                    var n = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
                    return function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, e),
                        function(t, e) {
                            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                            return !e || "object" != typeof e && "function" != typeof e ? t : e
                        }(this, Object.getPrototypeOf(e).call(this, t, i, {
                            angle: i.width / 2
                        }, Object.assign({}, u, n)))
                }
                return function(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }(e, r.default), n(e, [{
                    key: "handleDown",
                    value: function(t, i) {
                        this.enabled && (this.centerPoint = this.clickObject.toGlobal(new Phaser.Point(0, 0)), c.set(i.x, i.y), this.old = this.down = Phaser.Math.normalizeAngle(Phaser.Math.angleBetweenPoints(c, this.centerPoint)), this.fullDiff = 0, s(Object.getPrototypeOf(e.prototype), "handleDown", this).call(this, t, i))
                    }
                }, {
                    key: "handleMove",
                    value: function(t, e, i) {
                        if (this.enabled) {
                            this.isScrolling = !0, c.set(e, i);
                            var n = Phaser.Math.normalizeAngle(Phaser.Math.angleBetweenPoints(c, this.centerPoint)),
                                s = 0,
                                r = this.old - n;
                            if (this.diff = h(r), this.diff > 180 ? s = 1 : this.diff < -180 && (s = -1), 0 != s) r -= s * l(360), this.diff = h(r);
                            this.diff = this._requestDiff(this.diff, this.target, this.min, this.max, this.o.overflow), this.fullDiff -= this.diff, this.target -= this.diff, this.o.infinite && (this.target = this._wrapTarget(this.target, this.min, this.max)), this.old = n, this.o.time.move = this.game.time.time;
                            var o = this.clickObject.width,
                                a = Math.PI * o * (this.diff / 360);
                            this.acc = Math.min(Math.abs(a / 30), this.o.maxAcceleration), this.scrollObject[this.o.direction] = this.target, this.handleUpdate(), this.o.emitMoving && this.events.onInputMove.dispatch({
                                pointer: t,
                                x: e,
                                y: i
                            })
                        }
                    }
                }, {
                    key: "handleUp",
                    value: function(t, i) {
                        c.set(i.x, i.y), this.current = Phaser.Math.normalizeAngle(Phaser.Math.angleBetweenPoints(c, this.centerPoint)), s(Object.getPrototypeOf(e.prototype), "handleUp", this).call(this, t, i)
                    }
                }, {
                    key: "_wrapTarget",
                    value: function(t, e, i) {
                        return t > i ? t = e + (t - i) : t < e && (t = i - (e - t)), t
                    }
                }]), e
            }();
        e.default = d
    }, function(t, e, i) {
        (function(t) {
            "use strict";
            i(311), i(129), i(130), t._babelPolyfill && (t._babelPolyfill = !0);
            var e = "defineProperty";

            function n(t, i, n) {
                t[i] || Object[e](t, i, {
                    writable: !0,
                    configurable: !0,
                    value: n
                })
            }
            n(String.prototype, "padLeft", "".padStart), n(String.prototype, "padRight", "".padEnd), "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t) {
                [][t] && n(Array, t, Function.call.bind([][t]))
            })
        }).call(e, function() {
            return this
        }())
    }, function(t, e, i) {
        (function(e, i, n) {
            ! function(e) {
                "use strict";
                var s, r = Object.prototype,
                    o = r.hasOwnProperty,
                    a = "function" == typeof Symbol ? Symbol : {},
                    h = a.iterator || "@@iterator",
                    l = a.toStringTag || "@@toStringTag",
                    c = "object" == typeof t,
                    u = e.regeneratorRuntime;
                if (u) c && (t.exports = u);
                else {
                    (u = e.regeneratorRuntime = c ? t.exports : {}).wrap = w;
                    var d = "suspendedStart",
                        p = "suspendedYield",
                        f = "executing",
                        g = "completed",
                        m = {},
                        y = {};
                    y[h] = function() {
                        return this
                    };
                    var v = Object.getPrototypeOf,
                        b = v && v(v(O([])));
                    b && b !== r && o.call(b, h) && (y = b);
                    var x = S.prototype = P.prototype = Object.create(y);
                    T.prototype = x.constructor = S, S.constructor = T, S[l] = T.displayName = "GeneratorFunction", u.isGeneratorFunction = function(t) {
                        var e = "function" == typeof t && t.constructor;
                        return !!e && (e === T || "GeneratorFunction" === (e.displayName || e.name))
                    }, u.mark = function(t) {
                        return Object.setPrototypeOf ? Object.setPrototypeOf(t, S) : (t.__proto__ = S, l in t || (t[l] = "GeneratorFunction")), t.prototype = Object.create(x), t
                    }, u.awrap = function(t) {
                        return {
                            __await: t
                        }
                    }, C(A.prototype), u.AsyncIterator = A, u.async = function(t, e, i, n) {
                        var s = new A(w(t, e, i, n));
                        return u.isGeneratorFunction(e) ? s : s.next().then(function(t) {
                            return t.done ? t.value : s.next()
                        })
                    }, C(x), x[l] = "Generator", x.toString = function() {
                        return "[object Generator]"
                    }, u.keys = function(t) {
                        var e = [];
                        for (var i in t) e.push(i);
                        return e.reverse(),
                            function i() {
                                for (; e.length;) {
                                    var n = e.pop();
                                    if (n in t) return i.value = n, i.done = !1, i
                                }
                                return i.done = !0, i
                            }
                    }, u.values = O, I.prototype = {
                        constructor: I,
                        reset: function(t) {
                            if (this.prev = 0, this.next = 0, this.sent = this._sent = s, this.done = !1, this.delegate = null, this.tryEntries.forEach(M), !t)
                                for (var e in this) "t" === e.charAt(0) && o.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = s)
                        },
                        stop: function() {
                            this.done = !0;
                            var t = this.tryEntries[0].completion;
                            if ("throw" === t.type) throw t.arg;
                            return this.rval
                        },
                        dispatchException: function(t) {
                            if (this.done) throw t;
                            var e = this;

                            function i(i, n) {
                                return r.type = "throw", r.arg = t, e.next = i, !!n
                            }
                            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                var s = this.tryEntries[n],
                                    r = s.completion;
                                if ("root" === s.tryLoc) return i("end");
                                if (s.tryLoc <= this.prev) {
                                    var a = o.call(s, "catchLoc"),
                                        h = o.call(s, "finallyLoc");
                                    if (a && h) {
                                        if (this.prev < s.catchLoc) return i(s.catchLoc, !0);
                                        if (this.prev < s.finallyLoc) return i(s.finallyLoc)
                                    } else if (a) {
                                        if (this.prev < s.catchLoc) return i(s.catchLoc, !0)
                                    } else {
                                        if (!h) throw new Error("try statement without catch or finally");
                                        if (this.prev < s.finallyLoc) return i(s.finallyLoc)
                                    }
                                }
                            }
                        },
                        abrupt: function(t, e) {
                            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                                var n = this.tryEntries[i];
                                if (n.tryLoc <= this.prev && o.call(n, "finallyLoc") && this.prev < n.finallyLoc) {
                                    var s = n;
                                    break
                                }
                            }
                            s && ("break" === t || "continue" === t) && s.tryLoc <= e && e <= s.finallyLoc && (s = null);
                            var r = s ? s.completion : {};
                            return r.type = t, r.arg = e, s ? this.next = s.finallyLoc : this.complete(r), m
                        },
                        complete: function(t, e) {
                            if ("throw" === t.type) throw t.arg;
                            "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = t.arg, this.next = "end") : "normal" === t.type && e && (this.next = e)
                        },
                        finish: function(t) {
                            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                                var i = this.tryEntries[e];
                                if (i.finallyLoc === t) return this.complete(i.completion, i.afterLoc), M(i), m
                            }
                        },
                        catch: function(t) {
                            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                                var i = this.tryEntries[e];
                                if (i.tryLoc === t) {
                                    var n = i.completion;
                                    if ("throw" === n.type) {
                                        var s = n.arg;
                                        M(i)
                                    }
                                    return s
                                }
                            }
                            throw new Error("illegal catch attempt")
                        },
                        delegateYield: function(t, e, i) {
                            return this.delegate = {
                                iterator: O(t),
                                resultName: e,
                                nextLoc: i
                            }, m
                        }
                    }
                }

                function w(t, e, i, n) {
                    var r = e && e.prototype instanceof P ? e : P,
                        o = Object.create(r.prototype),
                        a = new I(n || []);
                    return o._invoke = function(t, e, i) {
                        var n = d;
                        return function(r, o) {
                            if (n === f) throw new Error("Generator is already running");
                            if (n === g) {
                                if ("throw" === r) throw o;
                                return k()
                            }
                            for (;;) {
                                var a = i.delegate;
                                if (a) {
                                    if ("return" === r || "throw" === r && a.iterator[r] === s) {
                                        i.delegate = null;
                                        var h = a.iterator.return;
                                        if (h) {
                                            var l = _(h, a.iterator, o);
                                            if ("throw" === l.type) {
                                                r = "throw", o = l.arg;
                                                continue
                                            }
                                        }
                                        if ("return" === r) continue
                                    }
                                    var l = _(a.iterator[r], a.iterator, o);
                                    if ("throw" === l.type) {
                                        i.delegate = null, r = "throw", o = l.arg;
                                        continue
                                    }
                                    r = "next", o = s;
                                    var c = l.arg;
                                    if (!c.done) return n = p, c;
                                    i[a.resultName] = c.value, i.next = a.nextLoc, i.delegate = null
                                }
                                if ("next" === r) i.sent = i._sent = o;
                                else if ("throw" === r) {
                                    if (n === d) throw n = g, o;
                                    i.dispatchException(o) && (r = "next", o = s)
                                } else "return" === r && i.abrupt("return", o);
                                n = f;
                                var l = _(t, e, i);
                                if ("normal" === l.type) {
                                    n = i.done ? g : p;
                                    var c = {
                                        value: l.arg,
                                        done: i.done
                                    };
                                    if (l.arg !== m) return c;
                                    i.delegate && "next" === r && (o = s)
                                } else "throw" === l.type && (n = g, r = "throw", o = l.arg)
                            }
                        }
                    }(t, i, a), o
                }

                function _(t, e, i) {
                    try {
                        return {
                            type: "normal",
                            arg: t.call(e, i)
                        }
                    } catch (t) {
                        return {
                            type: "throw",
                            arg: t
                        }
                    }
                }

                function P() {}

                function T() {}

                function S() {}

                function C(t) {
                    ["next", "throw", "return"].forEach(function(e) {
                        t[e] = function(t) {
                            return this._invoke(e, t)
                        }
                    })
                }

                function A(t) {
                    function e(n, s, r, a) {
                        var h = _(t[n], t, s);
                        if ("throw" !== h.type) {
                            var l = h.arg,
                                c = l.value;
                            return c && "object" == typeof c && o.call(c, "__await") ? i.resolve(c.__await).then(function(t) {
                                e("next", t, r, a)
                            }, function(t) {
                                e("throw", t, r, a)
                            }) : i.resolve(c).then(function(t) {
                                l.value = t, r(l)
                            }, a)
                        }
                        a(h.arg)
                    }
                    var s;
                    "object" == typeof n && n.domain && (e = n.domain.bind(e)), this._invoke = function(t, n) {
                        function r() {
                            return new i(function(i, s) {
                                e(t, n, i, s)
                            })
                        }
                        return s = s ? s.then(r, r) : r()
                    }
                }

                function E(t) {
                    var e = {
                        tryLoc: t[0]
                    };
                    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
                }

                function M(t) {
                    var e = t.completion || {};
                    e.type = "normal", delete e.arg, t.completion = e
                }

                function I(t) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], t.forEach(E, this), this.reset(!0)
                }

                function O(t) {
                    if (t) {
                        var e = t[h];
                        if (e) return e.call(t);
                        if ("function" == typeof t.next) return t;
                        if (!isNaN(t.length)) {
                            var i = -1,
                                n = function e() {
                                    for (; ++i < t.length;)
                                        if (o.call(t, i)) return e.value = t[i], e.done = !1, e;
                                    return e.value = s, e.done = !0, e
                                };
                            return n.next = n
                        }
                    }
                    return {
                        next: k
                    }
                }

                function k() {
                    return {
                        value: s,
                        done: !0
                    }
                }
            }("object" == typeof e ? e : "object" == typeof window ? window : "object" == typeof self ? self : this)
        }).call(e, function() {
            return this
        }(), i(121), i(122))
    }, function(t, e, i) {
        i(140), t.exports = i(23).RegExp.escape
    }, function(t, e, i) {
        var n = i(5),
            s = i(72),
            r = i(6)("species");
        t.exports = function(t) {
            var e;
            return s(t) && ("function" != typeof(e = t.constructor) || e !== Array && !s(e.prototype) || (e = void 0), n(e) && null === (e = e[r]) && (e = void 0)), void 0 === e ? Array : e
        }
    }, function(t, e, i) {
        var n = i(131);
        t.exports = function(t, e) {
            return new(n(t))(e)
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(2),
            s = i(25);
        t.exports = function(t) {
            if ("string" !== t && "number" !== t && "default" !== t) throw TypeError("Incorrect hint");
            return s(n(this), "number" != t)
        }
    }, function(t, e, i) {
        var n = i(37),
            s = i(59),
            r = i(48);
        t.exports = function(t) {
            var e = n(t),
                i = s.f;
            if (i)
                for (var o, a = i(t), h = r.f, l = 0; a.length > l;) h.call(t, o = a[l++]) && e.push(o);
            return e
        }
    }, function(t, e, i) {
        var n = i(37),
            s = i(16);
        t.exports = function(t, e) {
            for (var i, r = s(t), o = n(r), a = o.length, h = 0; a > h;)
                if (r[i = o[h++]] === e) return i
        }
    }, function(t, e, i) {
        "use strict";
        var n = i(137),
            s = i(55),
            r = i(13);
        t.exports = function() {
            for (var t = r(this), e = arguments.length, i = Array(e), o = 0, a = n._, h = !1; e > o;)(i[o] = arguments[o++]) === a && (h = !0);
            return function() {
                var n, r = arguments.length,
                    o = 0,
                    l = 0;
                if (!h && !r) return s(t, i, this);
                if (n = i.slice(), h)
                    for (; e > o; o++) n[o] === a && (n[o] = arguments[l++]);
                for (; r > l;) n.push(arguments[l++]);
                return s(t, n, this)
            }
        }
    }, function(t, e, i) {
        t.exports = i(3)
    }, function(t, e) {
        t.exports = function(t, e) {
            var i = e === Object(e) ? function(t) {
                return e[t]
            } : e;
            return function(e) {
                return String(e).replace(t, i)
            }
        }
    }, function(t, e, i) {
        var n = i(43),
            s = i(6)("iterator"),
            r = i(33);
        t.exports = i(23).isIterable = function(t) {
            var e = Object(t);
            return void 0 !== e[s] || "@@iterator" in e || r.hasOwnProperty(n(e))
        }
    }, function(t, e, i) {
        var n = i(1),
            s = i(138)(/[\\^$*+?.()|[\]{}]/g, "\\$&");
        n(n.S, "RegExp", {
            escape: function(t) {
                return s(t)
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.P, "Array", {
            copyWithin: i(95)
        }), i(42)("copyWithin")
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(22)(4);
        n(n.P + n.F * !i(21)([].every, !0), "Array", {
            every: function(t) {
                return s(this, t, arguments[1])
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.P, "Array", {
            fill: i(64)
        }), i(42)("fill")
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(22)(2);
        n(n.P + n.F * !i(21)([].filter, !0), "Array", {
            filter: function(t) {
                return s(this, t, arguments[1])
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(22)(6),
            r = "findIndex",
            o = !0;
        r in [] && Array(1)[r](function() {
            o = !1
        }), n(n.P + n.F * o, "Array", {
            findIndex: function(t) {
                return s(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }), i(42)(r)
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(22)(5),
            r = !0;
        "find" in [] && Array(1).find(function() {
            r = !1
        }), n(n.P + n.F * r, "Array", {
            find: function(t) {
                return s(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }), i(42)("find")
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(22)(0),
            r = i(21)([].forEach, !0);
        n(n.P + n.F * !r, "Array", {
            forEach: function(t) {
                return s(this, t, arguments[1])
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(26),
            s = i(1),
            r = i(10),
            o = i(103),
            a = i(71),
            h = i(9),
            l = i(65),
            c = i(88);
        s(s.S + s.F * !i(57)(function(t) {
            Array.from(t)
        }), "Array", {
            from: function(t) {
                var e, i, s, u, d = r(t),
                    p = "function" == typeof this ? this : Array,
                    f = arguments.length,
                    g = f > 1 ? arguments[1] : void 0,
                    m = void 0 !== g,
                    y = 0,
                    v = c(d);
                if (m && (g = n(g, f > 2 ? arguments[2] : void 0, 2)), void 0 == v || p == Array && a(v))
                    for (i = new p(e = h(d.length)); e > y; y++) l(i, y, m ? g(d[y], y) : d[y]);
                else
                    for (u = v.call(d), i = new p; !(s = u.next()).done; y++) l(i, y, m ? o(u, g, [s.value, y], !0) : s.value);
                return i.length = y, i
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(51)(!1),
            r = [].indexOf,
            o = !!r && 1 / [1].indexOf(1, -0) < 0;
        n(n.P + n.F * (o || !i(21)(r)), "Array", {
            indexOf: function(t) {
                return o ? r.apply(this, arguments) || 0 : s(this, t, arguments[1])
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Array", {
            isArray: i(72)
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(16),
            r = [].join;
        n(n.P + n.F * (i(47) != Object || !i(21)(r)), "Array", {
            join: function(t) {
                return r.call(s(this), void 0 === t ? "," : t)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(16),
            r = i(32),
            o = i(9),
            a = [].lastIndexOf,
            h = !!a && 1 / [1].lastIndexOf(1, -0) < 0;
        n(n.P + n.F * (h || !i(21)(a)), "Array", {
            lastIndexOf: function(t) {
                if (h) return a.apply(this, arguments) || 0;
                var e = s(this),
                    i = o(e.length),
                    n = i - 1;
                for (arguments.length > 1 && (n = Math.min(n, r(arguments[1]))), n < 0 && (n = i + n); n >= 0; n--)
                    if (n in e && e[n] === t) return n || 0;
                return -1
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(22)(1);
        n(n.P + n.F * !i(21)([].map, !0), "Array", {
            map: function(t) {
                return s(this, t, arguments[1])
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(65);
        n(n.S + n.F * i(4)(function() {
            function t() {}
            return !(Array.of.call(t) instanceof t)
        }), "Array", { of: function() {
                for (var t = 0, e = arguments.length, i = new("function" == typeof this ? this : Array)(e); e > t;) s(i, t, arguments[t++]);
                return i.length = e, i
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(97);
        n(n.P + n.F * !i(21)([].reduceRight, !0), "Array", {
            reduceRight: function(t) {
                return s(this, t, arguments.length, arguments[1], !0)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(97);
        n(n.P + n.F * !i(21)([].reduce, !0), "Array", {
            reduce: function(t) {
                return s(this, t, arguments.length, arguments[1], !1)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(69),
            r = i(19),
            o = i(40),
            a = i(9),
            h = [].slice;
        n(n.P + n.F * i(4)(function() {
            s && h.call(s)
        }), "Array", {
            slice: function(t, e) {
                var i = a(this.length),
                    n = r(this);
                if (e = void 0 === e ? i : e, "Array" == n) return h.call(this, t, e);
                for (var s = o(t, i), l = o(e, i), c = a(l - s), u = Array(c), d = 0; d < c; d++) u[d] = "String" == n ? this.charAt(s + d) : this[s + d];
                return u
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(22)(3);
        n(n.P + n.F * !i(21)([].some, !0), "Array", {
            some: function(t) {
                return s(this, t, arguments[1])
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(13),
            r = i(10),
            o = i(4),
            a = [].sort,
            h = [1, 2, 3];
        n(n.P + n.F * (o(function() {
            h.sort(void 0)
        }) || !o(function() {
            h.sort(null)
        }) || !i(21)(a)), "Array", {
            sort: function(t) {
                return void 0 === t ? a.call(r(this)) : a.call(r(this), s(t))
            }
        })
    }, function(t, e, i) {
        i(39)("Array")
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Date", {
            now: function() {
                return (new Date).getTime()
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(4),
            r = Date.prototype.getTime,
            o = function(t) {
                return t > 9 ? t : "0" + t
            };
        n(n.P + n.F * (s(function() {
            return "0385-07-25T07:06:39.999Z" != new Date(-5e13 - 1).toISOString()
        }) || !s(function() {
            new Date(NaN).toISOString()
        })), "Date", {
            toISOString: function() {
                if (!isFinite(r.call(this))) throw RangeError("Invalid time value");
                var t = this,
                    e = t.getUTCFullYear(),
                    i = t.getUTCMilliseconds(),
                    n = e < 0 ? "-" : e > 9999 ? "+" : "";
                return n + ("00000" + Math.abs(e)).slice(n ? -6 : -4) + "-" + o(t.getUTCMonth() + 1) + "-" + o(t.getUTCDate()) + "T" + o(t.getUTCHours()) + ":" + o(t.getUTCMinutes()) + ":" + o(t.getUTCSeconds()) + "." + (i > 99 ? i : "0" + o(i)) + "Z"
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(10),
            r = i(25);
        n(n.P + n.F * i(4)(function() {
            return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
                toISOString: function() {
                    return 1
                }
            })
        }), "Date", {
            toJSON: function(t) {
                var e = s(this),
                    i = r(e);
                return "number" != typeof i || isFinite(i) ? e.toISOString() : null
            }
        })
    }, function(t, e, i) {
        var n = i(6)("toPrimitive"),
            s = Date.prototype;
        n in s || i(12)(s, n, i(133))
    }, function(t, e, i) {
        var n = Date.prototype,
            s = n.toString,
            r = n.getTime;
        new Date(NaN) + "" != "Invalid Date" && i(14)(n, "toString", function() {
            var t = r.call(this);
            return t == t ? s.call(this) : "Invalid Date"
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.P, "Function", {
            bind: i(98)
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(5),
            s = i(18),
            r = i(6)("hasInstance"),
            o = Function.prototype;
        r in o || i(8).f(o, r, {
            value: function(t) {
                if ("function" != typeof this || !n(t)) return !1;
                if (!n(this.prototype)) return t instanceof this;
                for (; t = s(t);)
                    if (this.prototype === t) return !0;
                return !1
            }
        })
    }, function(t, e, i) {
        var n = i(8).f,
            s = i(31),
            r = i(11),
            o = Function.prototype,
            a = /^\s*function ([^ (]*)/,
            h = Object.isExtensible || function() {
                return !0
            };
        "name" in o || i(7) && n(o, "name", {
            configurable: !0,
            get: function() {
                try {
                    var t = ("" + this).match(a)[1];
                    return r(this, "name") || !h(this) || n(this, "name", s(5, t)), t
                } catch (t) {
                    return ""
                }
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(105),
            r = Math.sqrt,
            o = Math.acosh;
        n(n.S + n.F * !(o && 710 == Math.floor(o(Number.MAX_VALUE)) && o(1 / 0) == 1 / 0), "Math", {
            acosh: function(t) {
                return (t = +t) < 1 ? NaN : t > 94906265.62425156 ? Math.log(t) + Math.LN2 : s(t - 1 + r(t - 1) * r(t + 1))
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = Math.asinh;
        n(n.S + n.F * !(s && 1 / s(0) > 0), "Math", {
            asinh: function t(e) {
                return isFinite(e = +e) && 0 != e ? e < 0 ? -t(-e) : Math.log(e + Math.sqrt(e * e + 1)) : e
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = Math.atanh;
        n(n.S + n.F * !(s && 1 / s(-0) < 0), "Math", {
            atanh: function(t) {
                return 0 == (t = +t) ? t : Math.log((1 + t) / (1 - t)) / 2
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(77);
        n(n.S, "Math", {
            cbrt: function(t) {
                return s(t = +t) * Math.pow(Math.abs(t), 1 / 3)
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            clz32: function(t) {
                return (t >>>= 0) ? 31 - Math.floor(Math.log(t + .5) * Math.LOG2E) : 32
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = Math.exp;
        n(n.S, "Math", {
            cosh: function(t) {
                return (s(t = +t) + s(-t)) / 2
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(76);
        n(n.S + n.F * (s != Math.expm1), "Math", {
            expm1: s
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(77),
            r = Math.pow,
            o = r(2, -52),
            a = r(2, -23),
            h = r(2, 127) * (2 - a),
            l = r(2, -126);
        n(n.S, "Math", {
            fround: function(t) {
                var e, i, n = Math.abs(t),
                    r = s(t);
                return n < l ? r * (n / l / a + 1 / o - 1 / o) * l * a : (i = (e = (1 + a / o) * n) - (e - n)) > h || i != i ? r * (1 / 0) : r * i
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = Math.abs;
        n(n.S, "Math", {
            hypot: function(t, e) {
                for (var i, n, r = 0, o = 0, a = arguments.length, h = 0; o < a;) h < (i = s(arguments[o++])) ? (r = r * (n = h / i) * n + 1, h = i) : r += i > 0 ? (n = i / h) * n : i;
                return h === 1 / 0 ? 1 / 0 : h * Math.sqrt(r)
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = Math.imul;
        n(n.S + n.F * i(4)(function() {
            return -5 != s(4294967295, 5) || 2 != s.length
        }), "Math", {
            imul: function(t, e) {
                var i = +t,
                    n = +e,
                    s = 65535 & i,
                    r = 65535 & n;
                return 0 | s * r + ((65535 & i >>> 16) * r + s * (65535 & n >>> 16) << 16 >>> 0)
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            log10: function(t) {
                return Math.log(t) / Math.LN10
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            log1p: i(105)
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            log2: function(t) {
                return Math.log(t) / Math.LN2
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            sign: i(77)
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(76),
            r = Math.exp;
        n(n.S + n.F * i(4)(function() {
            return -2e-17 != !Math.sinh(-2e-17)
        }), "Math", {
            sinh: function(t) {
                return Math.abs(t = +t) < 1 ? (s(t) - s(-t)) / 2 : (r(t - 1) - r(-t - 1)) * (Math.E / 2)
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(76),
            r = Math.exp;
        n(n.S, "Math", {
            tanh: function(t) {
                var e = s(t = +t),
                    i = s(-t);
                return e == 1 / 0 ? 1 : i == 1 / 0 ? -1 : (e - i) / (r(t) + r(-t))
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            trunc: function(t) {
                return (t > 0 ? Math.floor : Math.ceil)(t)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(3),
            s = i(11),
            r = i(19),
            o = i(70),
            a = i(25),
            h = i(4),
            l = i(36).f,
            c = i(17).f,
            u = i(8).f,
            d = i(46).trim,
            p = n.Number,
            f = p,
            g = p.prototype,
            m = "Number" == r(i(35)(g)),
            y = "trim" in String.prototype,
            v = function(t) {
                var e = a(t, !1);
                if ("string" == typeof e && e.length > 2) {
                    var i, n, s, r = (e = y ? e.trim() : d(e, 3)).charCodeAt(0);
                    if (43 === r || 45 === r) {
                        if (88 === (i = e.charCodeAt(2)) || 120 === i) return NaN
                    } else if (48 === r) {
                        switch (e.charCodeAt(1)) {
                            case 66:
                            case 98:
                                n = 2, s = 49;
                                break;
                            case 79:
                            case 111:
                                n = 8, s = 55;
                                break;
                            default:
                                return +e
                        }
                        for (var o, h = e.slice(2), l = 0, c = h.length; l < c; l++)
                            if ((o = h.charCodeAt(l)) < 48 || o > s) return NaN;
                        return parseInt(h, n)
                    }
                }
                return +e
            };
        if (!p(" 0o1") || !p("0b1") || p("+0x1")) {
            p = function(t) {
                var e = arguments.length < 1 ? 0 : t,
                    i = this;
                return i instanceof p && (m ? h(function() {
                    g.valueOf.call(i)
                }) : "Number" != r(i)) ? o(new f(v(e)), i, p) : v(e)
            };
            for (var b, x = i(7) ? l(f) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), w = 0; x.length > w; w++) s(f, b = x[w]) && !s(p, b) && u(p, b, c(f, b));
            p.prototype = g, g.constructor = p, i(14)(n, "Number", p)
        }
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Number", {
            EPSILON: Math.pow(2, -52)
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(3).isFinite;
        n(n.S, "Number", {
            isFinite: function(t) {
                return "number" == typeof t && s(t)
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Number", {
            isInteger: i(73)
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Number", {
            isNaN: function(t) {
                return t != t
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(73),
            r = Math.abs;
        n(n.S, "Number", {
            isSafeInteger: function(t) {
                return s(t) && r(t) <= 9007199254740991
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Number", {
            MAX_SAFE_INTEGER: 9007199254740991
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Number", {
            MIN_SAFE_INTEGER: -9007199254740991
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(112);
        n(n.S + n.F * (Number.parseFloat != s), "Number", {
            parseFloat: s
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(113);
        n(n.S + n.F * (Number.parseInt != s), "Number", {
            parseInt: s
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = (i(29), i(32)),
            r = i(94),
            o = i(83),
            a = 1..toFixed,
            h = Math.floor,
            l = [0, 0, 0, 0, 0, 0],
            c = "Number.toFixed: incorrect invocation!",
            u = function(t, e) {
                for (var i = -1, n = e; ++i < 6;) n += t * l[i], l[i] = n % 1e7, n = h(n / 1e7)
            },
            d = function(t) {
                for (var e = 6, i = 0; --e >= 0;) i += l[e], l[e] = h(i / t), i = i % t * 1e7
            },
            p = function() {
                for (var t = 6, e = ""; --t >= 0;)
                    if ("" !== e || 0 === t || 0 !== l[t]) {
                        var i = String(l[t]);
                        e = "" === e ? i : e + o.call("0", 7 - i.length) + i
                    }
                return e
            },
            f = function(t, e, i) {
                return 0 === e ? i : e % 2 == 1 ? f(t, e - 1, i * t) : f(t * t, e / 2, i)
            };
        n(n.P + n.F * (!!a && ("0.000" !== 8e-5.toFixed(3) || "1" !== .9.toFixed(0) || "1.25" !== 1.255.toFixed(2) || "1000000000000000128" !== (0xde0b6b3a7640080).toFixed(0)) || !i(4)(function() {
            a.call({})
        })), "Number", {
            toFixed: function(t) {
                var e, i, n, a, h = r(this, c),
                    l = s(t),
                    g = "",
                    m = "0";
                if (l < 0 || l > 20) throw RangeError(c);
                if (h != h) return "NaN";
                if (h <= -1e21 || h >= 1e21) return String(h);
                if (h < 0 && (g = "-", h = -h), h > 1e-21)
                    if (i = (e = function(t) {
                            for (var e = 0, i = t; i >= 4096;) e += 12, i /= 4096;
                            for (; i >= 2;) e += 1, i /= 2;
                            return e
                        }(h * f(2, 69, 1)) - 69) < 0 ? h * f(2, -e, 1) : h / f(2, e, 1), i *= 4503599627370496, (e = 52 - e) > 0) {
                        for (u(0, i), n = l; n >= 7;) u(1e7, 0), n -= 7;
                        for (u(f(10, n, 1), 0), n = e - 1; n >= 23;) d(1 << 23), n -= 23;
                        d(1 << n), u(1, 1), d(2), m = p()
                    } else u(0, i), u(1 << -e, 0), m = p() + o.call("0", l);
                return m = l > 0 ? g + ((a = m.length) <= l ? "0." + o.call("0", l - a) + m : m.slice(0, a - l) + "." + m.slice(a - l)) : g + m
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(4),
            r = i(94),
            o = 1..toPrecision;
        n(n.P + n.F * (s(function() {
            return "1" !== o.call(1, void 0)
        }) || !s(function() {
            o.call({})
        })), "Number", {
            toPrecision: function(t) {
                var e = r(this, "Number#toPrecision: incorrect invocation!");
                return void 0 === t ? o.call(e) : o.call(e, t)
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S + n.F, "Object", {
            assign: i(106)
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Object", {
            create: i(35)
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S + n.F * !i(7), "Object", {
            defineProperties: i(107)
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S + n.F * !i(7), "Object", {
            defineProperty: i(8).f
        })
    }, function(t, e, i) {
        var n = i(5),
            s = i(30).onFreeze;
        i(24)("freeze", function(t) {
            return function(e) {
                return t && n(e) ? t(s(e)) : e
            }
        })
    }, function(t, e, i) {
        var n = i(16),
            s = i(17).f;
        i(24)("getOwnPropertyDescriptor", function() {
            return function(t, e) {
                return s(n(t), e)
            }
        })
    }, function(t, e, i) {
        i(24)("getOwnPropertyNames", function() {
            return i(108).f
        })
    }, function(t, e, i) {
        var n = i(10),
            s = i(18);
        i(24)("getPrototypeOf", function() {
            return function(t) {
                return s(n(t))
            }
        })
    }, function(t, e, i) {
        var n = i(5);
        i(24)("isExtensible", function(t) {
            return function(e) {
                return !!n(e) && (!t || t(e))
            }
        })
    }, function(t, e, i) {
        var n = i(5);
        i(24)("isFrozen", function(t) {
            return function(e) {
                return !n(e) || !!t && t(e)
            }
        })
    }, function(t, e, i) {
        var n = i(5);
        i(24)("isSealed", function(t) {
            return function(e) {
                return !n(e) || !!t && t(e)
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Object", {
            is: i(114)
        })
    }, function(t, e, i) {
        var n = i(10),
            s = i(37);
        i(24)("keys", function() {
            return function(t) {
                return s(n(t))
            }
        })
    }, function(t, e, i) {
        var n = i(5),
            s = i(30).onFreeze;
        i(24)("preventExtensions", function(t) {
            return function(e) {
                return t && n(e) ? t(s(e)) : e
            }
        })
    }, function(t, e, i) {
        var n = i(5),
            s = i(30).onFreeze;
        i(24)("seal", function(t) {
            return function(e) {
                return t && n(e) ? t(s(e)) : e
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Object", {
            setPrototypeOf: i(60).set
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(43),
            s = {};
        s[i(6)("toStringTag")] = "z", s + "" != "[object z]" && i(14)(Object.prototype, "toString", function() {
            return "[object " + n(this) + "]"
        }, !0)
    }, function(t, e, i) {
        var n = i(1),
            s = i(112);
        n(n.G + n.F * (parseFloat != s), {
            parseFloat: s
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(113);
        n(n.G + n.F * (parseInt != s), {
            parseInt: s
        })
    }, function(t, e, i) {
        "use strict";
        var n, s, r, o = i(34),
            a = i(3),
            h = i(26),
            l = i(43),
            c = i(1),
            u = i(5),
            d = (i(2), i(13)),
            p = i(29),
            f = i(44),
            g = (i(60).set, i(80)),
            m = i(85).set,
            y = i(78)(),
            v = a.TypeError,
            b = a.process,
            x = a.Promise,
            w = "process" == l(b = a.process),
            _ = function() {},
            P = !! function() {
                try {
                    var t = x.resolve(1),
                        e = (t.constructor = {})[i(6)("species")] = function(t) {
                            t(_, _)
                        };
                    return (w || "function" == typeof PromiseRejectionEvent) && t.then(_) instanceof e
                } catch (t) {}
            }(),
            T = function(t, e) {
                return t === e || t === x && e === r
            },
            S = function(t) {
                var e;
                return !(!u(t) || "function" != typeof(e = t.then)) && e
            },
            C = function(t) {
                return T(x, t) ? new A(t) : new s(t)
            },
            A = s = function(t) {
                var e, i;
                this.promise = new t(function(t, n) {
                    if (void 0 !== e || void 0 !== i) throw v("Bad Promise constructor");
                    e = t, i = n
                }), this.resolve = d(e), this.reject = d(i)
            },
            E = function(t) {
                try {
                    t()
                } catch (t) {
                    return {
                        error: t
                    }
                }
            },
            M = function(t, e) {
                if (!t._n) {
                    t._n = !0;
                    var i = t._c;
                    y(function() {
                        for (var n = t._v, s = 1 == t._s, r = 0, o = function(e) {
                                var i, r, o = s ? e.ok : e.fail,
                                    a = e.resolve,
                                    h = e.reject,
                                    l = e.domain;
                                try {
                                    o ? (s || (2 == t._h && k(t), t._h = 1), !0 === o ? i = n : (l && l.enter(), i = o(n), l && l.exit()), i === e.promise ? h(v("Promise-chain cycle")) : (r = S(i)) ? r.call(i, a, h) : a(i)) : h(n)
                                } catch (t) {
                                    h(t)
                                }
                            }; i.length > r;) o(i[r++]);
                        t._c = [], t._n = !1, e && !t._h && I(t)
                    })
                }
            },
            I = function(t) {
                m.call(a, function() {
                    var e, i, n, s = t._v;
                    if (O(t) && (e = E(function() {
                            w ? b.emit("unhandledRejection", s, t) : (i = a.onunhandledrejection) ? i({
                                promise: t,
                                reason: s
                            }) : (n = a.console) && n.error && n.error("Unhandled promise rejection", s)
                        }), t._h = w || O(t) ? 2 : 1), t._a = void 0, e) throw e.error
                })
            },
            O = function(t) {
                if (1 == t._h) return !1;
                for (var e, i = t._a || t._c, n = 0; i.length > n;)
                    if ((e = i[n++]).fail || !O(e.promise)) return !1;
                return !0
            },
            k = function(t) {
                m.call(a, function() {
                    var e;
                    w ? b.emit("rejectionHandled", t) : (e = a.onrejectionhandled) && e({
                        promise: t,
                        reason: t._v
                    })
                })
            },
            R = function(t) {
                var e = this;
                e._d || (e._d = !0, (e = e._w || e)._v = t, e._s = 2, e._a || (e._a = e._c.slice()), M(e, !0))
            },
            L = function(t) {
                var e, i = this;
                if (!i._d) {
                    i._d = !0, i = i._w || i;
                    try {
                        if (i === t) throw v("Promise can't be resolved itself");
                        (e = S(t)) ? y(function() {
                            var n = {
                                _w: i,
                                _d: !1
                            };
                            try {
                                e.call(t, h(L, n, 1), h(R, n, 1))
                            } catch (t) {
                                R.call(n, t)
                            }
                        }): (i._v = t, i._s = 1, M(i, !1))
                    } catch (t) {
                        R.call({
                            _w: i,
                            _d: !1
                        }, t)
                    }
                }
            };
        P || (x = function(t) {
            p(this, x, "Promise", "_h"), d(t), n.call(this);
            try {
                t(h(L, this, 1), h(R, this, 1))
            } catch (t) {
                R.call(this, t)
            }
        }, (n = function(t) {
            this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1
        }).prototype = i(38)(x.prototype, {
            then: function(t, e) {
                var i = C(g(this, x));
                return i.ok = "function" != typeof t || t, i.fail = "function" == typeof e && e, i.domain = w ? b.domain : void 0, this._c.push(i), this._a && this._a.push(i), this._s && M(this, !1), i.promise
            },
            catch: function(t) {
                return this.then(void 0, t)
            }
        }), A = function() {
            var t = new n;
            this.promise = t, this.resolve = h(L, t, 1), this.reject = h(R, t, 1)
        }), c(c.G + c.W + c.F * !P, {
            Promise: x
        }), i(45)(x, "Promise"), i(39)("Promise"), r = i(23).Promise, c(c.S + c.F * !P, "Promise", {
            reject: function(t) {
                var e = C(this);
                return (0, e.reject)(t), e.promise
            }
        }), c(c.S + c.F * (o || !P), "Promise", {
            resolve: function(t) {
                if (t instanceof x && T(t.constructor, this)) return t;
                var e = C(this);
                return (0, e.resolve)(t), e.promise
            }
        }), c(c.S + c.F * !(P && i(57)(function(t) {
            x.all(t).catch(_)
        })), "Promise", {
            all: function(t) {
                var e = this,
                    i = C(e),
                    n = i.resolve,
                    s = i.reject,
                    r = E(function() {
                        var i = [],
                            r = 0,
                            o = 1;
                        f(t, !1, function(t) {
                            var a = r++,
                                h = !1;
                            i.push(void 0), o++, e.resolve(t).then(function(t) {
                                h || (h = !0, i[a] = t, --o || n(i))
                            }, s)
                        }), --o || n(i)
                    });
                return r && s(r.error), i.promise
            },
            race: function(t) {
                var e = this,
                    i = C(e),
                    n = i.reject,
                    s = E(function() {
                        f(t, !1, function(t) {
                            e.resolve(t).then(i.resolve, n)
                        })
                    });
                return s && n(s.error), i.promise
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(13),
            r = i(2),
            o = Function.apply;
        n(n.S, "Reflect", {
            apply: function(t, e, i) {
                return o.call(s(t), e, r(i))
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(35),
            r = i(13),
            o = i(2),
            a = i(5),
            h = i(98);
        n(n.S + n.F * i(4)(function() {
            function t() {}
            return !(Reflect.construct(function() {}, [], t) instanceof t)
        }), "Reflect", {
            construct: function(t, e) {
                r(t), o(e);
                var i = arguments.length < 3 ? t : r(arguments[2]);
                if (t == i) {
                    switch (e.length) {
                        case 0:
                            return new t;
                        case 1:
                            return new t(e[0]);
                        case 2:
                            return new t(e[0], e[1]);
                        case 3:
                            return new t(e[0], e[1], e[2]);
                        case 4:
                            return new t(e[0], e[1], e[2], e[3])
                    }
                    var n = [null];
                    return n.push.apply(n, e), new(h.apply(t, n))
                }
                var l = i.prototype,
                    c = s(a(l) ? l : Object.prototype),
                    u = Function.apply.call(t, c, e);
                return a(u) ? u : c
            }
        })
    }, function(t, e, i) {
        var n = i(8),
            s = i(1),
            r = i(2),
            o = i(25);
        s(s.S + s.F * i(4)(function() {
            Reflect.defineProperty(n.f({}, 1, {
                value: 1
            }), 1, {
                value: 2
            })
        }), "Reflect", {
            defineProperty: function(t, e, i) {
                r(t), e = o(e, !0), r(i);
                try {
                    return n.f(t, e, i), !0
                } catch (t) {
                    return !1
                }
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(17).f,
            r = i(2);
        n(n.S, "Reflect", {
            deleteProperty: function(t, e) {
                var i = s(r(t), e);
                return !(i && !i.configurable) && delete t[e]
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(2),
            r = function(t) {
                this._t = s(t), this._i = 0;
                var e, i = this._k = [];
                for (e in t) i.push(e)
            };
        i(74)(r, "Object", function() {
            var t, e = this._k;
            do {
                if (this._i >= e.length) return {
                    value: void 0,
                    done: !0
                }
            } while (!((t = e[this._i++]) in this._t));
            return {
                value: t,
                done: !1
            }
        }), n(n.S, "Reflect", {
            enumerate: function(t) {
                return new r(t)
            }
        })
    }, function(t, e, i) {
        var n = i(17),
            s = i(1),
            r = i(2);
        s(s.S, "Reflect", {
            getOwnPropertyDescriptor: function(t, e) {
                return n.f(r(t), e)
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(18),
            r = i(2);
        n(n.S, "Reflect", {
            getPrototypeOf: function(t) {
                return s(r(t))
            }
        })
    }, function(t, e, i) {
        var n = i(17),
            s = i(18),
            r = i(11),
            o = i(1),
            a = i(5),
            h = i(2);
        o(o.S, "Reflect", {
            get: function t(e, i) {
                var o, l, c = arguments.length < 3 ? e : arguments[2];
                return h(e) === c ? e[i] : (o = n.f(e, i)) ? r(o, "value") ? o.value : void 0 !== o.get ? o.get.call(c) : void 0 : a(l = s(e)) ? t(l, i, c) : void 0
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Reflect", {
            has: function(t, e) {
                return e in t
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(2),
            r = Object.isExtensible;
        n(n.S, "Reflect", {
            isExtensible: function(t) {
                return s(t), !r || r(t)
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Reflect", {
            ownKeys: i(111)
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(2),
            r = Object.preventExtensions;
        n(n.S, "Reflect", {
            preventExtensions: function(t) {
                s(t);
                try {
                    return r && r(t), !0
                } catch (t) {
                    return !1
                }
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(60);
        s && n(n.S, "Reflect", {
            setPrototypeOf: function(t, e) {
                s.check(t, e);
                try {
                    return s.set(t, e), !0
                } catch (t) {
                    return !1
                }
            }
        })
    }, function(t, e, i) {
        var n = i(8),
            s = i(17),
            r = i(18),
            o = i(11),
            a = i(1),
            h = i(31),
            l = i(2),
            c = i(5);
        a(a.S, "Reflect", {
            set: function t(e, i, a) {
                var u, d, p = arguments.length < 4 ? e : arguments[3],
                    f = s.f(l(e), i);
                if (!f) {
                    if (c(d = r(e))) return t(d, i, a, p);
                    f = h(0)
                }
                return o(f, "value") ? !(!1 === f.writable || !c(p) || ((u = s.f(p, i) || h(0)).value = a, n.f(p, i, u), 0)) : void 0 !== f.set && (f.set.call(p, a), !0)
            }
        })
    }, function(t, e, i) {
        var n = i(3),
            s = i(70),
            r = i(8).f,
            o = i(36).f,
            a = i(56),
            h = i(54),
            l = n.RegExp,
            c = l,
            u = l.prototype,
            d = /a/g,
            p = /a/g,
            f = new l(d) !== d;
        if (i(7) && (!f || i(4)(function() {
                return p[i(6)("match")] = !1, l(d) != d || l(p) == p || "/a/i" != l(d, "i")
            }))) {
            l = function(t, e) {
                var i = this instanceof l,
                    n = a(t),
                    r = void 0 === e;
                return !i && n && t.constructor === l && r ? t : s(f ? new c(n && !r ? t.source : t, e) : c((n = t instanceof l) ? t.source : t, n && r ? h.call(t) : e), i ? this : u, l)
            };
            for (var g = function(t) {
                    t in l || r(l, t, {
                        configurable: !0,
                        get: function() {
                            return c[t]
                        },
                        set: function(e) {
                            c[t] = e
                        }
                    })
                }, m = o(c), y = 0; m.length > y;) g(m[y++]);
            u.constructor = l, l.prototype = u, i(14)(n, "RegExp", l)
        }
        i(39)("RegExp")
    }, function(t, e, i) {
        i(53)("match", 1, function(t, e, i) {
            return [function(i) {
                "use strict";
                var n = t(this),
                    s = void 0 == i ? void 0 : i[e];
                return void 0 !== s ? s.call(i, n) : new RegExp(i)[e](String(n))
            }, i]
        })
    }, function(t, e, i) {
        i(53)("replace", 2, function(t, e, i) {
            return [function(n, s) {
                "use strict";
                var r = t(this),
                    o = void 0 == n ? void 0 : n[e];
                return void 0 !== o ? o.call(n, r, s) : i.call(String(r), n, s)
            }, i]
        })
    }, function(t, e, i) {
        i(53)("search", 1, function(t, e, i) {
            return [function(i) {
                "use strict";
                var n = t(this),
                    s = void 0 == i ? void 0 : i[e];
                return void 0 !== s ? s.call(i, n) : new RegExp(i)[e](String(n))
            }, i]
        })
    }, function(t, e, i) {
        i(53)("split", 2, function(t, e, n) {
            "use strict";
            var s = i(56),
                r = n,
                o = [].push;
            if ("c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
                var a = void 0 === /()??/.exec("")[1];
                n = function(t, e) {
                    var i = String(this);
                    if (void 0 === t && 0 === e) return [];
                    if (!s(t)) return r.call(i, t, e);
                    var n, h, l, c, u, d = [],
                        p = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""),
                        f = 0,
                        g = void 0 === e ? 4294967295 : e >>> 0,
                        m = new RegExp(t.source, p + "g");
                    for (a || (n = new RegExp("^" + m.source + "$(?!\\s)", p));
                        (h = m.exec(i)) && !((l = h.index + h[0].length) > f && (d.push(i.slice(f, h.index)), !a && h.length > 1 && h[0].replace(n, function() {
                            for (u = 1; u < arguments.length - 2; u++) void 0 === arguments[u] && (h[u] = void 0)
                        }), h.length > 1 && h.index < i.length && o.apply(d, h.slice(1)), c = h[0].length, f = l, d.length >= g));) m.lastIndex === h.index && m.lastIndex++;
                    return f === i.length ? !c && m.test("") || d.push("") : d.push(i.slice(f)), d.length > g ? d.slice(0, g) : d
                }
            } else "0".split(void 0, 0).length && (n = function(t, e) {
                return void 0 === t && 0 === e ? [] : r.call(this, t, e)
            });
            return [function(i, s) {
                var r = t(this),
                    o = void 0 == i ? void 0 : i[e];
                return void 0 !== o ? o.call(i, r, s) : n.call(String(r), i, s)
            }, n]
        })
    }, function(t, e, i) {
        "use strict";
        i(118);
        var n = i(2),
            s = i(54),
            r = i(7),
            o = /./.toString,
            a = function(t) {
                i(14)(RegExp.prototype, "toString", t, !0)
            };
        i(4)(function() {
            return "/a/b" != o.call({
                source: "a",
                flags: "b"
            })
        }) ? a(function() {
            var t = n(this);
            return "/".concat(t.source, "/", "flags" in t ? t.flags : !r && t instanceof RegExp ? s.call(t) : void 0)
        }) : "toString" != o.name && a(function() {
            return o.call(this)
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("anchor", function(t) {
            return function(e) {
                return t(this, "a", "name", e)
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("big", function(t) {
            return function() {
                return t(this, "big", "", "")
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("blink", function(t) {
            return function() {
                return t(this, "blink", "", "")
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("bold", function(t) {
            return function() {
                return t(this, "b", "", "")
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(81)(!1);
        n(n.P, "String", {
            codePointAt: function(t) {
                return s(this, t)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(9),
            r = i(82),
            o = "".endsWith;
        n(n.P + n.F * i(68)("endsWith"), "String", {
            endsWith: function(t) {
                var e = r(this, t, "endsWith"),
                    i = arguments.length > 1 ? arguments[1] : void 0,
                    n = s(e.length),
                    a = void 0 === i ? n : Math.min(s(i), n),
                    h = String(t);
                return o ? o.call(e, h, a) : e.slice(a - h.length, a) === h
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("fixed", function(t) {
            return function() {
                return t(this, "tt", "", "")
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("fontcolor", function(t) {
            return function(e) {
                return t(this, "font", "color", e)
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("fontsize", function(t) {
            return function(e) {
                return t(this, "font", "size", e)
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(40),
            r = String.fromCharCode,
            o = String.fromCodePoint;
        n(n.S + n.F * (!!o && 1 != o.length), "String", {
            fromCodePoint: function(t) {
                for (var e, i = [], n = arguments.length, o = 0; n > o;) {
                    if (e = +arguments[o++], s(e, 1114111) !== e) throw RangeError(e + " is not a valid code point");
                    i.push(e < 65536 ? r(e) : r(55296 + ((e -= 65536) >> 10), e % 1024 + 56320))
                }
                return i.join("")
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(82);
        n(n.P + n.F * i(68)("includes"), "String", {
            includes: function(t) {
                return !!~s(this, t, "includes").indexOf(t, arguments.length > 1 ? arguments[1] : void 0)
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("italics", function(t) {
            return function() {
                return t(this, "i", "", "")
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(81)(!0);
        i(75)(String, "String", function(t) {
            this._t = String(t), this._i = 0
        }, function() {
            var t, e = this._t,
                i = this._i;
            return i >= e.length ? {
                value: void 0,
                done: !0
            } : (t = n(e, i), this._i += t.length, {
                value: t,
                done: !1
            })
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("link", function(t) {
            return function(e) {
                return t(this, "a", "href", e)
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(16),
            r = i(9);
        n(n.S, "String", {
            raw: function(t) {
                for (var e = s(t.raw), i = r(e.length), n = arguments.length, o = [], a = 0; i > a;) o.push(String(e[a++])), a < n && o.push(String(arguments[a]));
                return o.join("")
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.P, "String", {
            repeat: i(83)
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("small", function(t) {
            return function() {
                return t(this, "small", "", "")
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(9),
            r = i(82),
            o = "".startsWith;
        n(n.P + n.F * i(68)("startsWith"), "String", {
            startsWith: function(t) {
                var e = r(this, t, "startsWith"),
                    i = s(Math.min(arguments.length > 1 ? arguments[1] : void 0, e.length)),
                    n = String(t);
                return o ? o.call(e, n, i) : e.slice(i, i + n.length) === n
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("strike", function(t) {
            return function() {
                return t(this, "strike", "", "")
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("sub", function(t) {
            return function() {
                return t(this, "sub", "", "")
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(15)("sup", function(t) {
            return function() {
                return t(this, "sup", "", "")
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(46)("trim", function(t) {
            return function() {
                return t(this, 3)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(3),
            s = i(11),
            r = i(7),
            o = i(1),
            a = i(14),
            h = i(30).KEY,
            l = i(4),
            c = i(61),
            u = i(45),
            d = i(41),
            p = i(6),
            f = i(116),
            g = i(87),
            m = i(135),
            y = i(134),
            v = i(72),
            b = i(2),
            x = i(16),
            w = i(25),
            _ = i(31),
            P = i(35),
            T = i(108),
            S = i(17),
            C = i(8),
            A = i(37),
            E = S.f,
            M = C.f,
            I = T.f,
            O = n.Symbol,
            k = n.JSON,
            R = k && k.stringify,
            L = p("_hidden"),
            B = p("toPrimitive"),
            F = {}.propertyIsEnumerable,
            D = c("symbol-registry"),
            U = c("symbols"),
            G = c("op-symbols"),
            N = Object.prototype,
            X = "function" == typeof O,
            j = n.QObject,
            W = !j || !j.prototype || !j.prototype.findChild,
            V = r && l(function() {
                return 7 != P(M({}, "a", {
                    get: function() {
                        return M(this, "a", {
                            value: 7
                        }).a
                    }
                })).a
            }) ? function(t, e, i) {
                var n = E(N, e);
                n && delete N[e], M(t, e, i), n && t !== N && M(N, e, n)
            } : M,
            Y = function(t) {
                var e = U[t] = P(O.prototype);
                return e._k = t, e
            },
            H = X && "symbol" == typeof O.iterator ? function(t) {
                return "symbol" == typeof t
            } : function(t) {
                return t instanceof O
            },
            q = function(t, e, i) {
                return t === N && q(G, e, i), b(t), e = w(e, !0), b(i), s(U, e) ? (i.enumerable ? (s(t, L) && t[L][e] && (t[L][e] = !1), i = P(i, {
                    enumerable: _(0, !1)
                })) : (s(t, L) || M(t, L, _(1, {})), t[L][e] = !0), V(t, e, i)) : M(t, e, i)
            },
            z = function(t, e) {
                b(t);
                for (var i, n = y(e = x(e)), s = 0, r = n.length; r > s;) q(t, i = n[s++], e[i]);
                return t
            },
            K = function(t) {
                var e = F.call(this, t = w(t, !0));
                return !(this === N && s(U, t) && !s(G, t)) && (!(e || !s(this, t) || !s(U, t) || s(this, L) && this[L][t]) || e)
            },
            J = function(t, e) {
                if (t = x(t), e = w(e, !0), t !== N || !s(U, e) || s(G, e)) {
                    var i = E(t, e);
                    return !i || !s(U, e) || s(t, L) && t[L][e] || (i.enumerable = !0), i
                }
            },
            Q = function(t) {
                for (var e, i = I(x(t)), n = [], r = 0; i.length > r;) s(U, e = i[r++]) || e == L || e == h || n.push(e);
                return n
            },
            Z = function(t) {
                for (var e, i = t === N, n = I(i ? G : x(t)), r = [], o = 0; n.length > o;) !s(U, e = n[o++]) || i && !s(N, e) || r.push(U[e]);
                return r
            };
        X || (a((O = function() {
            if (this instanceof O) throw TypeError("Symbol is not a constructor!");
            var t = d(arguments.length > 0 ? arguments[0] : void 0),
                e = function(i) {
                    this === N && e.call(G, i), s(this, L) && s(this[L], t) && (this[L][t] = !1), V(this, t, _(1, i))
                };
            return r && W && V(N, t, {
                configurable: !0,
                set: e
            }), Y(t)
        }).prototype, "toString", function() {
            return this._k
        }), S.f = J, C.f = q, i(36).f = T.f = Q, i(48).f = K, i(59).f = Z, r && !i(34) && a(N, "propertyIsEnumerable", K, !0), f.f = function(t) {
            return Y(p(t))
        }), o(o.G + o.W + o.F * !X, {
            Symbol: O
        });
        for (var $ = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), tt = 0; $.length > tt;) p($[tt++]);
        for ($ = A(p.store), tt = 0; $.length > tt;) g($[tt++]);
        o(o.S + o.F * !X, "Symbol", {
            for: function(t) {
                return s(D, t += "") ? D[t] : D[t] = O(t)
            },
            keyFor: function(t) {
                if (H(t)) return m(D, t);
                throw TypeError(t + " is not a symbol!")
            },
            useSetter: function() {
                W = !0
            },
            useSimple: function() {
                W = !1
            }
        }), o(o.S + o.F * !X, "Object", {
            create: function(t, e) {
                return void 0 === e ? P(t) : z(P(t), e)
            },
            defineProperty: q,
            defineProperties: z,
            getOwnPropertyDescriptor: J,
            getOwnPropertyNames: Q,
            getOwnPropertySymbols: Z
        }), k && o(o.S + o.F * (!X || l(function() {
            var t = O();
            return "[null]" != R([t]) || "{}" != R({
                a: t
            }) || "{}" != R(Object(t))
        })), "JSON", {
            stringify: function(t) {
                if (void 0 !== t && !H(t)) {
                    for (var e, i, n = [t], s = 1; arguments.length > s;) n.push(arguments[s++]);
                    return "function" == typeof(e = n[1]) && (i = e), !i && v(e) || (e = function(t, e) {
                        if (i && (e = i.call(this, t, e)), !H(e)) return e
                    }), n[1] = e, R.apply(k, n)
                }
            }
        }), O.prototype[B] || i(12)(O.prototype, B, O.prototype.valueOf), u(O, "Symbol"), u(Math, "Math", !0), u(n.JSON, "JSON", !0)
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(62),
            r = i(86),
            o = i(2),
            a = i(40),
            h = i(9),
            l = i(5),
            c = (i(6)("typed_array"), i(3).ArrayBuffer),
            u = i(80),
            d = r.ArrayBuffer,
            p = r.DataView,
            f = s.ABV && c.isView,
            g = d.prototype.slice,
            m = s.VIEW;
        n(n.G + n.W + n.F * (c !== d), {
            ArrayBuffer: d
        }), n(n.S + n.F * !s.CONSTR, "ArrayBuffer", {
            isView: function(t) {
                return f && f(t) || l(t) && m in t
            }
        }), n(n.P + n.U + n.F * i(4)(function() {
            return !new d(2).slice(1, void 0).byteLength
        }), "ArrayBuffer", {
            slice: function(t, e) {
                if (void 0 !== g && void 0 === e) return g.call(o(this), t);
                for (var i = o(this).byteLength, n = a(t, i), s = a(void 0 === e ? i : e, i), r = new(u(this, d))(h(s - n)), l = new p(this), c = new p(r), f = 0; n < s;) c.setUint8(f++, l.getUint8(n++));
                return r
            }
        }), i(39)("ArrayBuffer")
    }, function(t, e, i) {
        var n = i(1);
        n(n.G + n.W + n.F * !i(62).ABV, {
            DataView: i(86).DataView
        })
    }, function(t, e, i) {
        i(28)("Float32", 4, function(t) {
            return function(e, i, n) {
                return t(this, e, i, n)
            }
        })
    }, function(t, e, i) {
        i(28)("Float64", 8, function(t) {
            return function(e, i, n) {
                return t(this, e, i, n)
            }
        })
    }, function(t, e, i) {
        i(28)("Int16", 2, function(t) {
            return function(e, i, n) {
                return t(this, e, i, n)
            }
        })
    }, function(t, e, i) {
        i(28)("Int32", 4, function(t) {
            return function(e, i, n) {
                return t(this, e, i, n)
            }
        })
    }, function(t, e, i) {
        i(28)("Int8", 1, function(t) {
            return function(e, i, n) {
                return t(this, e, i, n)
            }
        })
    }, function(t, e, i) {
        i(28)("Uint16", 2, function(t) {
            return function(e, i, n) {
                return t(this, e, i, n)
            }
        })
    }, function(t, e, i) {
        i(28)("Uint32", 4, function(t) {
            return function(e, i, n) {
                return t(this, e, i, n)
            }
        })
    }, function(t, e, i) {
        i(28)("Uint8", 1, function(t) {
            return function(e, i, n) {
                return t(this, e, i, n)
            }
        })
    }, function(t, e, i) {
        i(28)("Uint8", 1, function(t) {
            return function(e, i, n) {
                return t(this, e, i, n)
            }
        }, !0)
    }, function(t, e, i) {
        "use strict";
        var n = i(101);
        i(52)("WeakSet", function(t) {
            return function() {
                return t(this, arguments.length > 0 ? arguments[0] : void 0)
            }
        }, {
            add: function(t) {
                return n.def(this, t, !0)
            }
        }, n, !1, !0)
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(51)(!0);
        n(n.P, "Array", {
            includes: function(t) {
                return s(this, t, arguments.length > 1 ? arguments[1] : void 0)
            }
        }), i(42)("includes")
    }, function(t, e, i) {
        var n = i(1),
            s = i(78)(),
            r = i(3).process,
            o = "process" == i(19)(r);
        n(n.G, {
            asap: function(t) {
                var e = o && r.domain;
                s(e ? e.bind(t) : t)
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(19);
        n(n.S, "Error", {
            isError: function(t) {
                return "Error" === s(t)
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.P + n.R, "Map", {
            toJSON: i(100)("Map")
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            iaddh: function(t, e, i, n) {
                var s = t >>> 0,
                    r = i >>> 0;
                return (e >>> 0) + (n >>> 0) + ((s & r | (s | r) & ~(s + r >>> 0)) >>> 31) | 0
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            imulh: function(t, e) {
                var i = +t,
                    n = +e,
                    s = 65535 & i,
                    r = 65535 & n,
                    o = i >> 16,
                    a = n >> 16,
                    h = (o * r >>> 0) + (s * r >>> 16);
                return o * a + (h >> 16) + ((s * a >>> 0) + (65535 & h) >> 16)
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            isubh: function(t, e, i, n) {
                var s = t >>> 0,
                    r = i >>> 0;
                return (e >>> 0) - (n >>> 0) - ((~s & r | ~(s ^ r) & s - r >>> 0) >>> 31) | 0
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "Math", {
            umulh: function(t, e) {
                var i = +t,
                    n = +e,
                    s = 65535 & i,
                    r = 65535 & n,
                    o = i >>> 16,
                    a = n >>> 16,
                    h = (o * r >>> 0) + (s * r >>> 16);
                return o * a + (h >>> 16) + ((s * a >>> 0) + (65535 & h) >>> 16)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(10),
            r = i(13),
            o = i(8);
        i(7) && n(n.P + i(58), "Object", {
            __defineGetter__: function(t, e) {
                o.f(s(this), t, {
                    get: r(e),
                    enumerable: !0,
                    configurable: !0
                })
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(10),
            r = i(13),
            o = i(8);
        i(7) && n(n.P + i(58), "Object", {
            __defineSetter__: function(t, e) {
                o.f(s(this), t, {
                    set: r(e),
                    enumerable: !0,
                    configurable: !0
                })
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(110)(!0);
        n(n.S, "Object", {
            entries: function(t) {
                return s(t)
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(111),
            r = i(16),
            o = i(17),
            a = i(65);
        n(n.S, "Object", {
            getOwnPropertyDescriptors: function(t) {
                for (var e, i = r(t), n = o.f, h = s(i), l = {}, c = 0; h.length > c;) a(l, e = h[c++], n(i, e));
                return l
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(10),
            r = i(25),
            o = i(18),
            a = i(17).f;
        i(7) && n(n.P + i(58), "Object", {
            __lookupGetter__: function(t) {
                var e, i = s(this),
                    n = r(t, !0);
                do {
                    if (e = a(i, n)) return e.get
                } while (i = o(i))
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(10),
            r = i(25),
            o = i(18),
            a = i(17).f;
        i(7) && n(n.P + i(58), "Object", {
            __lookupSetter__: function(t) {
                var e, i = s(this),
                    n = r(t, !0);
                do {
                    if (e = a(i, n)) return e.set
                } while (i = o(i))
            }
        })
    }, function(t, e, i) {
        var n = i(1),
            s = i(110)(!1);
        n(n.S, "Object", {
            values: function(t) {
                return s(t)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(3),
            r = i(23),
            o = i(78)(),
            a = i(6)("observable"),
            h = i(13),
            l = i(2),
            c = i(29),
            u = i(38),
            d = i(12),
            p = i(44),
            f = p.RETURN,
            g = function(t) {
                return null == t ? void 0 : h(t)
            },
            m = function(t) {
                var e = t._c;
                e && (t._c = void 0, e())
            },
            y = function(t) {
                return void 0 === t._o
            },
            v = function(t) {
                y(t) || (t._o = void 0, m(t))
            },
            b = function(t, e) {
                l(t), this._c = void 0, this._o = t, t = new x(this);
                try {
                    var i = e(t),
                        n = i;
                    null != i && ("function" == typeof i.unsubscribe ? i = function() {
                        n.unsubscribe()
                    } : h(i), this._c = i)
                } catch (e) {
                    return void t.error(e)
                }
                y(this) && m(this)
            };
        b.prototype = u({}, {
            unsubscribe: function() {
                v(this)
            }
        });
        var x = function(t) {
            this._s = t
        };
        x.prototype = u({}, {
            next: function(t) {
                var e = this._s;
                if (!y(e)) {
                    var i = e._o;
                    try {
                        var n = g(i.next);
                        if (n) return n.call(i, t)
                    } catch (t) {
                        try {
                            v(e)
                        } finally {
                            throw t
                        }
                    }
                }
            },
            error: function(t) {
                var e = this._s;
                if (y(e)) throw t;
                var i = e._o;
                e._o = void 0;
                try {
                    var n = g(i.error);
                    if (!n) throw t;
                    t = n.call(i, t)
                } catch (t) {
                    try {
                        m(e)
                    } finally {
                        throw t
                    }
                }
                return m(e), t
            },
            complete: function(t) {
                var e = this._s;
                if (!y(e)) {
                    var i = e._o;
                    e._o = void 0;
                    try {
                        var n = g(i.complete);
                        t = n ? n.call(i, t) : void 0
                    } catch (t) {
                        try {
                            m(e)
                        } finally {
                            throw t
                        }
                    }
                    return m(e), t
                }
            }
        });
        var w = function(t) {
            c(this, w, "Observable", "_f")._f = h(t)
        };
        u(w.prototype, {
            subscribe: function(t) {
                return new b(t, this._f)
            },
            forEach: function(t) {
                var e = this;
                return new(r.Promise || s.Promise)(function(i, n) {
                    h(t);
                    var s = e.subscribe({
                        next: function(e) {
                            try {
                                return t(e)
                            } catch (t) {
                                n(t), s.unsubscribe()
                            }
                        },
                        error: n,
                        complete: i
                    })
                })
            }
        }), u(w, {
            from: function(t) {
                var e = "function" == typeof this ? this : w,
                    i = g(l(t)[a]);
                if (i) {
                    var n = l(i.call(t));
                    return n.constructor === e ? n : new e(function(t) {
                        return n.subscribe(t)
                    })
                }
                return new e(function(e) {
                    var i = !1;
                    return o(function() {
                            if (!i) {
                                try {
                                    if (p(t, !1, function(t) {
                                            if (e.next(t), i) return f
                                        }) === f) return
                                } catch (t) {
                                    if (i) throw t;
                                    return void e.error(t)
                                }
                                e.complete()
                            }
                        }),
                        function() {
                            i = !0
                        }
                })
            },
            of: function() {
                for (var t = 0, e = arguments.length, i = Array(e); t < e;) i[t] = arguments[t++];
                return new("function" == typeof this ? this : w)(function(t) {
                    var e = !1;
                    return o(function() {
                            if (!e) {
                                for (var n = 0; n < i.length; ++n)
                                    if (t.next(i[n]), e) return;
                                t.complete()
                            }
                        }),
                        function() {
                            e = !0
                        }
                })
            }
        }), d(w.prototype, a, function() {
            return this
        }), n(n.G, {
            Observable: w
        }), i(39)("Observable")
    }, function(t, e, i) {
        var n = i(27),
            s = i(2),
            r = n.key,
            o = n.set;
        n.exp({
            defineMetadata: function(t, e, i, n) {
                o(t, e, s(i), r(n))
            }
        })
    }, function(t, e, i) {
        var n = i(27),
            s = i(2),
            r = n.key,
            o = n.map,
            a = n.store;
        n.exp({
            deleteMetadata: function(t, e) {
                var i = arguments.length < 3 ? void 0 : r(arguments[2]),
                    n = o(s(e), i, !1);
                if (void 0 === n || !n.delete(t)) return !1;
                if (n.size) return !0;
                var h = a.get(e);
                return h.delete(i), !!h.size || a.delete(e)
            }
        })
    }, function(t, e, i) {
        var n = i(119),
            s = i(96),
            r = i(27),
            o = i(2),
            a = i(18),
            h = r.keys,
            l = r.key,
            c = function(t, e) {
                var i = h(t, e),
                    r = a(t);
                if (null === r) return i;
                var o = c(r, e);
                return o.length ? i.length ? s(new n(i.concat(o))) : o : i
            };
        r.exp({
            getMetadataKeys: function(t) {
                return c(o(t), arguments.length < 2 ? void 0 : l(arguments[1]))
            }
        })
    }, function(t, e, i) {
        var n = i(27),
            s = i(2),
            r = i(18),
            o = n.has,
            a = n.get,
            h = n.key,
            l = function(t, e, i) {
                if (o(t, e, i)) return a(t, e, i);
                var n = r(e);
                return null !== n ? l(t, n, i) : void 0
            };
        n.exp({
            getMetadata: function(t, e) {
                return l(t, s(e), arguments.length < 3 ? void 0 : h(arguments[2]))
            }
        })
    }, function(t, e, i) {
        var n = i(27),
            s = i(2),
            r = n.keys,
            o = n.key;
        n.exp({
            getOwnMetadataKeys: function(t) {
                return r(s(t), arguments.length < 2 ? void 0 : o(arguments[1]))
            }
        })
    }, function(t, e, i) {
        var n = i(27),
            s = i(2),
            r = n.get,
            o = n.key;
        n.exp({
            getOwnMetadata: function(t, e) {
                return r(t, s(e), arguments.length < 3 ? void 0 : o(arguments[2]))
            }
        })
    }, function(t, e, i) {
        var n = i(27),
            s = i(2),
            r = i(18),
            o = n.has,
            a = n.key,
            h = function(t, e, i) {
                if (o(t, e, i)) return !0;
                var n = r(e);
                return null !== n && h(t, n, i)
            };
        n.exp({
            hasMetadata: function(t, e) {
                return h(t, s(e), arguments.length < 3 ? void 0 : a(arguments[2]))
            }
        })
    }, function(t, e, i) {
        var n = i(27),
            s = i(2),
            r = n.has,
            o = n.key;
        n.exp({
            hasOwnMetadata: function(t, e) {
                return r(t, s(e), arguments.length < 3 ? void 0 : o(arguments[2]))
            }
        })
    }, function(t, e, i) {
        var n = i(27),
            s = i(2),
            r = i(13),
            o = n.key,
            a = n.set;
        n.exp({
            metadata: function(t, e) {
                return function(i, n) {
                    a(t, e, (void 0 !== n ? s : r)(i), o(n))
                }
            }
        })
    }, function(t, e, i) {
        var n = i(1);
        n(n.P + n.R, "Set", {
            toJSON: i(100)("Set")
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(81)(!0);
        n(n.P, "String", {
            at: function(t) {
                return s(this, t)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(20),
            r = i(9),
            o = i(56),
            a = i(54),
            h = RegExp.prototype,
            l = function(t, e) {
                this._r = t, this._s = e
            };
        i(74)(l, "RegExp String", function() {
            var t = this._r.exec(this._s);
            return {
                value: t,
                done: null === t
            }
        }), n(n.P, "String", {
            matchAll: function(t) {
                if (s(this), !o(t)) throw TypeError(t + " is not a regexp!");
                var e = String(this),
                    i = "flags" in h ? String(t.flags) : a.call(t),
                    n = new RegExp(t.source, ~i.indexOf("g") ? i : "g" + i);
                return n.lastIndex = r(t.lastIndex), new l(n, e)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(115);
        n(n.P, "String", {
            padEnd: function(t) {
                return s(this, t, arguments.length > 1 ? arguments[1] : void 0, !1)
            }
        })
    }, function(t, e, i) {
        "use strict";
        var n = i(1),
            s = i(115);
        n(n.P, "String", {
            padStart: function(t) {
                return s(this, t, arguments.length > 1 ? arguments[1] : void 0, !0)
            }
        })
    }, function(t, e, i) {
        "use strict";
        i(46)("trimLeft", function(t) {
            return function() {
                return t(this, 1)
            }
        }, "trimStart")
    }, function(t, e, i) {
        "use strict";
        i(46)("trimRight", function(t) {
            return function() {
                return t(this, 2)
            }
        }, "trimEnd")
    }, function(t, e, i) {
        i(87)("asyncIterator")
    }, function(t, e, i) {
        i(87)("observable")
    }, function(t, e, i) {
        var n = i(1);
        n(n.S, "System", {
            global: i(3)
        })
    }, function(t, e, i) {
        for (var n = i(89), s = i(14), r = i(3), o = i(12), a = i(33), h = i(6), l = h("iterator"), c = h("toStringTag"), u = a.Array, d = ["NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList"], p = 0; p < 5; p++) {
            var f, g = d[p],
                m = r[g],
                y = m && m.prototype;
            if (y)
                for (f in y[l] || o(y, l, u), y[c] || o(y, c, g), a[g] = u, n) y[f] || s(y, f, n[f], !0)
        }
    }, function(t, e, i) {
        var n = i(1),
            s = i(85);
        n(n.G + n.B, {
            setImmediate: s.set,
            clearImmediate: s.clear
        })
    }, function(t, e, i) {
        var n = i(3),
            s = i(1),
            r = i(55),
            o = i(136),
            a = n.navigator,
            h = !!a && /MSIE .\./.test(a.userAgent),
            l = function(t) {
                return h ? function(e, i) {
                    return t(r(o, [].slice.call(arguments, 2), "function" == typeof e ? e : Function(e)), i)
                } : t
            };
        s(s.G + s.B + s.F * h, {
            setTimeout: l(n.setTimeout),
            setInterval: l(n.setInterval)
        })
    }, function(t, e, i) {
        i(260), i(199), i(201), i(200), i(203), i(205), i(210), i(204), i(202), i(212), i(211), i(207), i(208), i(206), i(198), i(209), i(213), i(214), i(166), i(168), i(167), i(216), i(215), i(186), i(196), i(197), i(187), i(188), i(189), i(190), i(191), i(192), i(193), i(194), i(195), i(169), i(170), i(171), i(172), i(173), i(174), i(175), i(176), i(177), i(178), i(179), i(180), i(181), i(182), i(183), i(184), i(185), i(247), i(252), i(259), i(250), i(242), i(243), i(248), i(253), i(255), i(238), i(239), i(240), i(241), i(244), i(245), i(246), i(249), i(251), i(254), i(256), i(257), i(258), i(161), i(163), i(162), i(165), i(164), i(150), i(148), i(154), i(151), i(157), i(159), i(147), i(153), i(144), i(158), i(142), i(156), i(155), i(149), i(152), i(141), i(143), i(146), i(145), i(160), i(89), i(232), i(237), i(118), i(233), i(234), i(235), i(236), i(217), i(117), i(119), i(120), i(272), i(261), i(262), i(267), i(270), i(271), i(265), i(268), i(266), i(269), i(263), i(264), i(218), i(219), i(220), i(221), i(222), i(225), i(223), i(224), i(226), i(227), i(228), i(229), i(231), i(230), i(273), i(299), i(302), i(301), i(303), i(304), i(300), i(305), i(306), i(284), i(287), i(283), i(281), i(282), i(285), i(286), i(276), i(298), i(307), i(275), i(277), i(279), i(278), i(280), i(289), i(290), i(292), i(291), i(294), i(293), i(295), i(296), i(297), i(274), i(288), i(310), i(309), i(308), t.exports = i(23)
    }, function(t, e) {}]);
var PhaserNineSlice, __extends = this && this.__extends || function(t, e) {
    for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);

    function n() {
        this.constructor = t
    }
    t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
};
! function(t) {
    var e = function(t) {
        function e(e, i, n, s, r, o, a, h) {
            var l = t.call(this, e, i, n, s, r) || this;
            return l.baseTexture = l.texture.baseTexture, l.baseFrame = l.texture.frame, null === r || h ? h || (h = e.cache.getNineSlice(s)) : h = e.cache.getNineSlice(r), void 0 === h ? l : (l.topSize = h.top, h.left ? l.leftSize = h.left : l.leftSize = l.topSize, h.right ? l.rightSize = h.right : l.rightSize = l.leftSize, h.bottom ? l.bottomSize = h.bottom : l.bottomSize = l.topSize, l.loadTexture(new Phaser.RenderTexture(l.game, l.localWidth, l.localHeight)), l.resize(o, a), l)
        }
        return __extends(e, t), e.prototype.renderTexture = function() {
            this.texture.resize(this.localWidth, this.localHeight, !0);
            for (var t = [0, this.leftSize, this.baseFrame.width - this.rightSize, this.baseFrame.width], e = [0, this.topSize, this.baseFrame.height - this.bottomSize, this.baseFrame.height], i = [0, this.leftSize, this.localWidth - this.rightSize, this.localWidth], n = [0, this.topSize, this.localHeight - this.bottomSize, this.localHeight], s = 0; s < 3; s++)
                for (var r = 0; r < 3; r++) {
                    var o = this.createTexturePart(t[r], e[s], t[r + 1] - t[r], e[s + 1] - e[s]);
                    o.width = i[r + 1] - i[r], o.height = n[s + 1] - n[s], this.texture.renderXY(o, i[r], n[s])
                }
        }, e.prototype.resize = function(t, e) {
            this.localWidth = t, this.localHeight = e, this.renderTexture()
        }, e.prototype.createTexturePart = function(t, e, i, n) {
            var s = new PIXI.Rectangle(this.baseFrame.x + this.texture.frame.x + t, this.baseFrame.y + this.texture.frame.y + e, Math.max(i, 1), Math.max(n, 1));
            return new Phaser.Sprite(this.game, 0, 0, new PIXI.Texture(this.baseTexture, s))
        }, e
    }(Phaser.Sprite);
    t.NineSlice = e
}(PhaserNineSlice || (PhaserNineSlice = {})),
function(t) {
    var e = function(e) {
        function i(t, i) {
            var n = e.call(this, t, i) || this;
            return n.addNineSliceCache(), n.addNineSliceFactory(), n.addNineSliceLoader(), n
        }
        return __extends(i, e), i.prototype.addNineSliceLoader = function() {
            Phaser.Loader.prototype.nineSlice = function(t, e, i, n, s, r) {
                var o = {
                    top: i
                };
                n && (o.left = n), s && (o.right = s), r && (o.bottom = r), this.addToFileList("image", t, e), this.game.cache.addNineSlice(t, o)
            }
        }, i.prototype.addNineSliceFactory = function() {
            Phaser.GameObjectFactory.prototype.nineSlice = function(e, i, n, s, r, o, a) {
                void 0 === a && (a = this.world);
                var h = new t.NineSlice(this.game, e, i, n, s, r, o);
                return a.add(h)
            }, Phaser.GameObjectCreator.prototype.nineSlice = function(e, i, n, s, r, o) {
                return new t.NineSlice(this.game, e, i, n, s, r, o)
            }
        }, i.prototype.addNineSliceCache = function() {
            Phaser.Cache.prototype.nineSlice = {}, Phaser.Cache.prototype.addNineSlice = function(t, e) {
                this.nineSlice[t] = e
            }, Phaser.Cache.prototype.getNineSlice = function(t) {
                var e = this.nineSlice[t];
                return e
            }
        }, i
    }(Phaser.Plugin);
    t.Plugin = e
}(PhaserNineSlice || (PhaserNineSlice = {}));
var spine = {
    radDeg: 180 / Math.PI,
    degRad: Math.PI / 180,
    Float32Array: "undefined" == typeof Float32Array ? Array : Float32Array,
    Uint32Array: "undefined" == typeof Uint32Array ? Array : Uint32Array,
    Uint16Array: "undefined" == typeof Uint16Array ? Array : Uint16Array
};
spine.temp = new spine.Float32Array(2), spine.BoneData = function(t, e) {
    this.name = t, this.parent = e
}, spine.BoneData.prototype = {
    length: 0,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    inheritScale: !0,
    inheritRotation: !0
}, spine.BlendMode = {
    normal: 0,
    additive: 1,
    multiply: 2,
    screen: 3
}, spine.SlotData = function(t, e) {
    this.name = t, this.boneData = e
}, spine.SlotData.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    attachmentName: null,
    blendMode: spine.BlendMode.normal
}, spine.IkConstraintData = function(t) {
    this.name = t, this.bones = []
}, spine.IkConstraintData.prototype = {
    target: null,
    bendDirection: 1,
    mix: 1
}, spine.TransformConstraintData = function(t) {
    this.name = t
}, spine.TransformConstraintData.prototype = {
    bone: null,
    target: null,
    translateMix: 1,
    x: 0,
    y: 0
}, spine.Bone = function(t, e, i) {
    this.data = t, this.skeleton = e, this.parent = i, this.setToSetupPose()
}, spine.Bone.yDown = !1, spine.Bone.prototype = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    a: 0,
    b: 0,
    worldX: 0,
    c: 0,
    d: 0,
    worldY: 0,
    worldSignX: 1,
    worldSignY: 1,
    update: function() {
        this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY)
    },
    updateWorldTransformWith: function() {
        this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY)
    },
    updateWorldTransform: function(t, e, i, n, s) {
        this.appliedRotation = i, this.appliedScaleX = n, this.appliedScaleY = s, i *= spine.degRad;
        var r = Math.cos(i),
            o = Math.sin(i),
            a = r * n,
            h = -o * s,
            l = o * n,
            c = r * s,
            u = this.parent;
        if (!u) {
            var d = this.skeleton;
            return d.flipX && (t = -t, a = -a, h = -h), d.flipY != spine.Bone.yDown && (e = -e, l = -l, c = -c), this.a = a, this.b = h, this.c = l, this.d = c, this.worldX = t, this.worldY = e, this.worldSignX = n < 0 ? -1 : 1, void(this.worldSignY = s < 0 ? -1 : 1)
        }
        var p = u.a,
            f = u.b,
            g = u.c,
            m = u.d;
        if (this.worldX = p * t + f * e + u.worldX, this.worldY = g * t + m * e + u.worldY, this.worldSignX = u.worldSignX * (n < 0 ? -1 : 1), this.worldSignY = u.worldSignY * (s < 0 ? -1 : 1), this.data.inheritRotation && this.data.inheritScale) this.a = p * a + f * l, this.b = p * h + f * c, this.c = g * a + m * l, this.d = g * h + m * c;
        else {
            if (this.data.inheritRotation) {
                p = 1, f = 0, g = 0, m = 1;
                do {
                    i = u.appliedRotation * spine.degRad;
                    var y = p * (r = Math.cos(i)) + f * (o = Math.sin(i));
                    if (f = p * -o + f * r, p = y, y = g * r + m * o, m = g * -o + m * r, g = y, !u.data.inheritRotation) break;
                    u = u.parent
                } while (u);
                this.a = p * a + f * l, this.b = p * h + f * c, this.c = g * a + m * l, this.d = g * h + m * c
            } else if (this.data.inheritScale) {
                p = 1, f = 0, g = 0, m = 1;
                do {
                    i = u.appliedRotation * spine.degRad, r = Math.cos(i), o = Math.sin(i);
                    var v = u.appliedScaleX,
                        b = u.appliedScaleY,
                        x = r * v,
                        w = -o * b,
                        _ = o * v,
                        P = r * b;
                    y = p * x + f * _;
                    if (f = p * w + f * P, p = y, y = g * x + m * _, m = g * w + m * P, g = y, v < 0 && (i = -i), y = p * (r = Math.cos(-i)) + f * (o = Math.sin(-i)), f = p * -o + f * r, p = y, y = g * r + m * o, m = g * -o + m * r, g = y, !u.data.inheritScale) break;
                    u = u.parent
                } while (u);
                this.a = p * a + f * l, this.b = p * h + f * c, this.c = g * a + m * l, this.d = g * h + m * c
            } else this.a = a, this.b = h, this.c = l, this.d = c;
            this.skeleton.flipX && (this.a = -this.a, this.b = -this.b), this.skeleton.flipY != spine.Bone.yDown && (this.c = -this.c, this.d = -this.d)
        }
    },
    setToSetupPose: function() {
        var t = this.data;
        this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY
    },
    getWorldRotationX: function() {
        return Math.atan2(this.c, this.a) * spine.radDeg
    },
    getWorldRotationY: function() {
        return Math.atan2(this.d, this.b) * spine.radDeg
    },
    getWorldScaleX: function() {
        return Math.sqrt(this.a * this.a + this.b * this.b) * this.worldSignX
    },
    getWorldScaleY: function() {
        return Math.sqrt(this.c * this.c + this.d * this.d) * this.worldSignY
    },
    worldToLocal: function(t) {
        var e = t[0] - this.worldX,
            i = t[1] - this.worldY,
            n = this.a,
            s = this.b,
            r = this.c,
            o = this.d,
            a = 1 / (n * o - s * r);
        return t[0] = e * o * a - i * s * a, t[1] = i * n * a - e * r * a, t
    },
    localToWorld: function(t) {
        var e = t[0],
            i = t[1];
        return t[0] = e * this.a + i * this.b + this.worldX, t[1] = e * this.c + i * this.d + this.worldY, t
    }
}, spine.Slot = function(t, e) {
    this.data = t, this.bone = e, this.attachmentVertices = new spine.Float32Array, this.setToSetupPose()
}, spine.Slot.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    _attachmentTime: 0,
    attachment: null,
    setAttachment: function(t) {
        this.attachment != t && (this.attachment = t, this._attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0)
    },
    setAttachmentTime: function(t) {
        this._attachmentTime = this.bone.skeleton.time - t
    },
    getAttachmentTime: function() {
        return this.bone.skeleton.time - this._attachmentTime
    },
    setToSetupPose: function() {
        var t = this.data;
        if (this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, t.attachmentName) {
            for (var e = this.bone.skeleton.data.slots, i = 0, n = e.length; i < n; i++)
                if (e[i] == t) {
                    this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachmentBySlotIndex(i, t.attachmentName));
                    break
                }
        } else this.setAttachment(null)
    }
}, spine.IkConstraint = function(t, e) {
    this.data = t, this.mix = t.mix, this.bendDirection = t.bendDirection, this.bones = [];
    for (var i = 0, n = t.bones.length; i < n; i++) this.bones[i] = e.findBone(t.bones[i].name);
    this.target = e.findBone(t.target.name)
}, spine.IkConstraint.prototype = {
    apply: function() {
        this.update()
    },
    update: function() {
        var t = this.target,
            e = this.bones;
        switch (e.length) {
            case 1:
                spine.IkConstraint.apply1(e[0], t.worldX, t.worldY, this.mix);
                break;
            case 2:
                spine.IkConstraint.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.mix)
        }
    }
}, spine.IkConstraint.apply1 = function(t, e, i, n) {
    var s = t.parent ? t.parent.getWorldRotationX() : 0,
        r = t.rotation,
        o = Math.atan2(i - t.worldY, e - t.worldX) * spine.radDeg - s;
    t.worldSignX != t.worldSignY != (t.skeleton.flipX != (t.skeleton.flipY != spine.Bone.yDown)) && (o = 360 - o), o > 180 ? o -= 360 : o < -180 && (o += 360), t.updateWorldTransform(t.x, t.y, r + (o - r) * n, t.appliedScaleX, t.appliedScaleY)
}, spine.IkConstraint.apply2 = function(t, e, i, n, s, r) {
    if (0 != r) {
        var o, a, h, l = t.x,
            c = t.y,
            u = t.appliedScaleX,
            d = t.appliedScaleY;
        u < 0 ? (u = -u, o = 180, h = -1) : (o = 0, h = 1), d < 0 && (d = -d, h = -h);
        var p = e.x,
            f = e.y,
            g = e.appliedScaleX,
            m = Math.abs(u - d) <= 1e-4;
        m || 0 == f || (e.worldX = t.a * p + t.worldX, e.worldY = t.c * p + t.worldY, f = 0), g < 0 ? (g = -g, a = 180) : a = 0;
        var y, v, b, x, w = t.parent;
        if (w) {
            var _ = w.a,
                P = w.b,
                T = w.c,
                S = 1 / (_ * (L = w.d) - P * T),
                C = w.worldX,
                A = w.worldY;
            y = ((q = i - C) * L - (H = n - A) * P) * S - l, v = (H * _ - q * T) * S - c, b = ((q = e.worldX - C) * L - (H = e.worldY - A) * P) * S - l, x = (H * _ - q * T) * S - c
        } else y = i - l, v = n - c, b = e.worldX - l, x = e.worldY - c;
        var E, M, I = Math.sqrt(b * b + x * x),
            O = e.data.length * g;
        t: if (m) {
            var k = (y * y + v * v - I * I - (O *= u) * O) / (2 * I * O);
            k < -1 ? k = -1 : k > 1 && (k = 1), M = Math.acos(k) * s;
            _ = I + O * k;
            var R = O * Math.sin(M);
            E = Math.atan2(v * _ - y * R, y * _ + v * R)
        } else {
            _ = u * O, P = d * O;
            var L, B = Math.atan2(v, y),
                F = _ * _,
                D = P * P,
                U = y * y + v * v,
                G = D * (I * I) + F * U - F * D,
                N = -2 * D * I,
                X = D - F;
            if ((L = N * N - 4 * X * G) >= 0) {
                var j = Math.sqrt(L);
                N < 0 && (j = -j);
                var W = (j = -(N + j) / 2) / X,
                    V = G / j,
                    Y = Math.abs(W) < Math.abs(V) ? W : V;
                if (Y * Y <= U) {
                    var H = Math.sqrt(U - Y * Y) * s;
                    E = B - Math.atan2(H, Y), M = Math.atan2(H / d, (Y - I) / u);
                    break t
                }
            }
            var q, z = 0,
                K = Number.MAX_VALUE,
                J = 0,
                Q = 0,
                Z = 0,
                $ = 0,
                tt = 0,
                et = 0,
                it = (q = I + _) * q;
            it > $ && (Z = 0, $ = it, tt = q), (it = (q = I - _) * q) < K && (z = Math.PI, K = it, J = q);
            var nt = Math.acos(-_ * I / (F - D));
            (it = (q = _ * Math.cos(nt) + I) * q + (H = P * Math.sin(nt)) * H) < K && (z = nt, K = it, J = q, Q = H), it > $ && (Z = nt, $ = it, tt = q, et = H), U <= (K + $) / 2 ? (E = B - Math.atan2(Q * s, J), M = z * s) : (E = B - Math.atan2(et * s, tt), M = Z * s)
        }
        var st = Math.atan2(f, p) * h;
        E = (E - st) * spine.radDeg + o, M = (M + st) * spine.radDeg * h + a, E > 180 ? E -= 360 : E < -180 && (E += 360), M > 180 ? M -= 360 : M < -180 && (M += 360);
        var rt = t.rotation;
        t.updateWorldTransform(l, c, rt + (E - rt) * r, t.appliedScaleX, t.appliedScaleY), rt = e.rotation, e.updateWorldTransform(p, f, rt + (M - rt) * r, e.appliedScaleX, e.appliedScaleY)
    }
}, spine.TransformConstraint = function(t, e) {
    this.data = t, this.translateMix = t.translateMix, this.x = t.x, this.y = t.y, this.bone = e.findBone(t.bone.name), this.target = e.findBone(t.target.name)
}, spine.TransformConstraint.prototype = {
    apply: function() {
        this.update()
    },
    update: function() {
        var t = this.translateMix;
        if (t > 0) {
            var e = spine.temp;
            e[0] = x, e[1] = y, this.target.localToWorld(e);
            var i = this.bone;
            i.worldX += (e[0] - i.worldX) * t, i.worldY += (e[1] - i.worldY) * t
        }
    }
}, spine.Skin = function(t) {
    this.name = t, this.attachments = {}
}, spine.Skin.prototype = {
    addAttachment: function(t, e, i) {
        this.attachments[t + ":" + e] = i
    },
    getAttachment: function(t, e) {
        return this.attachments[t + ":" + e]
    },
    _attachAll: function(t, e) {
        for (var i in e.attachments) {
            var n = i.indexOf(":"),
                s = parseInt(i.substring(0, n)),
                r = i.substring(n + 1),
                o = t.slots[s];
            if (o.attachment && o.attachment.name == r) {
                var a = this.getAttachment(s, r);
                a && o.setAttachment(a)
            }
        }
    }
}, spine.Animation = function(t, e, i) {
    this.name = t, this.timelines = e, this.duration = i
}, spine.Animation.prototype = {
    apply: function(t, e, i, n, s) {
        n && 0 != this.duration && (i %= this.duration, e > 0 && (e %= this.duration));
        for (var r = this.timelines, o = 0, a = r.length; o < a; o++) r[o].apply(t, e, i, s, 1)
    },
    mix: function(t, e, i, n, s, r) {
        n && 0 != this.duration && (i %= this.duration, e > 0 && (e %= this.duration));
        for (var o = this.timelines, a = 0, h = o.length; a < h; a++) o[a].apply(t, e, i, s, r)
    }
}, spine.Animation.binarySearch = function(t, e, i) {
    var n = 0,
        s = Math.floor(t.length / i) - 2;
    if (!s) return i;
    for (var r = s >>> 1;;) {
        if (t[(r + 1) * i] <= e ? n = r + 1 : s = r, n == s) return (n + 1) * i;
        r = n + s >>> 1
    }
}, spine.Animation.binarySearch1 = function(t, e) {
    var i = 0,
        n = t.length - 2;
    if (!n) return 1;
    for (var s = n >>> 1;;) {
        if (t[s + 1] <= e ? i = s + 1 : n = s, i == n) return i + 1;
        s = i + n >>> 1
    }
}, spine.Animation.linearSearch = function(t, e, i) {
    for (var n = 0, s = t.length - i; n <= s; n += i)
        if (t[n] > e) return n;
    return -1
}, spine.Curves = function(t) {
    var e = 19 * (t - 1);
    this.curves = new spine.Float32Array(e), this.curves.length = e
}, spine.Curves.prototype = {
    setLinear: function(t) {
        this.curves[19 * t] = 0
    },
    setStepped: function(t) {
        this.curves[19 * t] = 1
    },
    setCurve: function(t, e, i, n, s) {
        var r = .1 * .1 * .1 * 6,
            o = 2 * -e + n,
            a = 2 * -i + s,
            h = 3 * (e - n) + 1,
            l = 3 * (i - s) + 1,
            c = e * (3 * .1) + o * (.1 * .1 * 3) + h * (.1 * .1 * .1),
            u = i * (3 * .1) + a * (.1 * .1 * 3) + l * (.1 * .1 * .1),
            d = o * (.1 * .1 * 6) + h * r,
            p = a * (.1 * .1 * 6) + l * r,
            f = h * r,
            g = l * r,
            m = 19 * t,
            y = this.curves;
        y[m++] = 2;
        for (var v = c, b = u, x = m + 19 - 1; m < x; m += 2) y[m] = v, y[m + 1] = b, c += d, u += p, d += f, p += g, v += c, b += u
    },
    getCurvePercent: function(t, e) {
        e = e < 0 ? 0 : e > 1 ? 1 : e;
        var i = this.curves,
            n = 19 * t,
            s = i[n];
        if (0 === s) return e;
        if (1 == s) return 0;
        for (var r = 0, o = ++n, a = n + 19 - 1; n < a; n += 2) {
            var h, l;
            if ((r = i[n]) >= e) return n == o ? (h = 0, l = 0) : (h = i[n - 2], l = i[n - 1]), l + (i[n + 1] - l) * (e - h) / (r - h)
        }
        var c = i[n - 1];
        return c + (1 - c) * (e - r) / (1 - r)
    }
}, spine.RotateTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(2 * t), this.frames.length = 2 * t
}, spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 2
    },
    setFrame: function(t, e, i) {
        t *= 2, this.frames[t] = e, this.frames[t + 1] = i
    },
    apply: function(t, e, i, n, s) {
        var r = this.frames;
        if (!(i < r[0])) {
            var o = t.bones[this.boneIndex];
            if (i >= r[r.length - 2]) {
                for (var a = o.data.rotation + r[r.length - 1] - o.rotation; a > 180;) a -= 360;
                for (; a < -180;) a += 360;
                o.rotation += a * s
            } else {
                var h = spine.Animation.binarySearch(r, i, 2),
                    l = r[h - 1],
                    c = r[h],
                    u = 1 - (i - c) / (r[h - 2] - c);
                u = this.curves.getCurvePercent(h / 2 - 1, u);
                for (a = r[h + 1] - l; a > 180;) a -= 360;
                for (; a < -180;) a += 360;
                for (a = o.data.rotation + (l + a * u) - o.rotation; a > 180;) a -= 360;
                for (; a < -180;) a += 360;
                o.rotation += a * s
            }
        }
    }
}, spine.TranslateTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), this.frames.length = 3 * t
}, spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(t, e, i, n) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = n
    },
    apply: function(t, e, i, n, s) {
        var r = this.frames;
        if (!(i < r[0])) {
            var o = t.bones[this.boneIndex];
            if (i >= r[r.length - 3]) return o.x += (o.data.x + r[r.length - 2] - o.x) * s, void(o.y += (o.data.y + r[r.length - 1] - o.y) * s);
            var a = spine.Animation.binarySearch(r, i, 3),
                h = r[a - 2],
                l = r[a - 1],
                c = r[a],
                u = 1 - (i - c) / (r[a + -3] - c);
            u = this.curves.getCurvePercent(a / 3 - 1, u), o.x += (o.data.x + h + (r[a + 1] - h) * u - o.x) * s, o.y += (o.data.y + l + (r[a + 2] - l) * u - o.y) * s
        }
    }
}, spine.ScaleTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), this.frames.length = 3 * t
}, spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(t, e, i, n) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = n
    },
    apply: function(t, e, i, n, s) {
        var r = this.frames;
        if (!(i < r[0])) {
            var o = t.bones[this.boneIndex];
            if (i >= r[r.length - 3]) return o.scaleX += (o.data.scaleX * r[r.length - 2] - o.scaleX) * s, void(o.scaleY += (o.data.scaleY * r[r.length - 1] - o.scaleY) * s);
            var a = spine.Animation.binarySearch(r, i, 3),
                h = r[a - 2],
                l = r[a - 1],
                c = r[a],
                u = 1 - (i - c) / (r[a + -3] - c);
            u = this.curves.getCurvePercent(a / 3 - 1, u), o.scaleX += (o.data.scaleX * (h + (r[a + 1] - h) * u) - o.scaleX) * s, o.scaleY += (o.data.scaleY * (l + (r[a + 2] - l) * u) - o.scaleY) * s
        }
    }
}, spine.ColorTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(5 * t), this.frames.length = 5 * t
}, spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 5
    },
    setFrame: function(t, e, i, n, s, r) {
        t *= 5, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = n, this.frames[t + 3] = s, this.frames[t + 4] = r
    },
    apply: function(t, e, i, n, s) {
        var r = this.frames;
        if (!(i < r[0])) {
            var o, a, h, l;
            if (i >= r[r.length - 5]) {
                var c = r.length - 1;
                o = r[c - 3], a = r[c - 2], h = r[c - 1], l = r[c]
            } else {
                var u = spine.Animation.binarySearch(r, i, 5),
                    d = r[u - 4],
                    p = r[u - 3],
                    f = r[u - 2],
                    g = r[u - 1],
                    m = r[u],
                    y = 1 - (i - m) / (r[u - 5] - m);
                y = this.curves.getCurvePercent(u / 5 - 1, y), o = d + (r[u + 1] - d) * y, a = p + (r[u + 2] - p) * y, h = f + (r[u + 3] - f) * y, l = g + (r[u + 4] - g) * y
            }
            var v = t.slots[this.slotIndex];
            s < 1 ? (v.r += (o - v.r) * s, v.g += (a - v.g) * s, v.b += (h - v.b) * s, v.a += (l - v.a) * s) : (v.r = o, v.g = a, v.b = h, v.a = l)
        }
    }
}, spine.AttachmentTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(t), this.frames.length = t, this.attachmentNames = [], this.attachmentNames.length = t
}, spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(t, e, i) {
        this.frames[t] = e, this.attachmentNames[t] = i
    },
    apply: function(t, e, i, n, s) {
        var r = this.frames;
        if (i < r[0]) e > i && this.apply(t, e, Number.MAX_VALUE, null, 0);
        else {
            e > i && (e = -1);
            var o = i >= r[r.length - 1] ? r.length - 1 : spine.Animation.binarySearch1(r, i) - 1;
            if (!(r[o] < e)) {
                var a = this.attachmentNames[o];
                t.slots[this.slotIndex].setAttachment(a ? t.getAttachmentBySlotIndex(this.slotIndex, a) : null)
            }
        }
    }
}, spine.EventTimeline = function(t) {
    this.frames = new spine.Float32Array(t), this.frames.length = t, this.events = [], this.events.length = t
}, spine.EventTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(t, e) {
        this.frames[t] = e.time, this.events[t] = e
    },
    apply: function(t, e, i, n, s) {
        if (n) {
            var r = this.frames,
                o = r.length;
            if (e > i) this.apply(t, e, Number.MAX_VALUE, n, s), e = -1;
            else if (e >= r[o - 1]) return;
            if (!(i < r[0])) {
                var a;
                if (e < r[0]) a = 0;
                else
                    for (var h = r[a = spine.Animation.binarySearch1(r, e)]; a > 0 && r[a - 1] == h;) a--;
                for (var l = this.events; a < o && i >= r[a]; a++) n[n.length] = l[a]
            }
        }
    }
}, spine.DrawOrderTimeline = function(t) {
    this.frames = new spine.Float32Array(t), this.frames.length = t, this.drawOrders = [], this.drawOrders.length = t
}, spine.DrawOrderTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(t, e, i) {
        this.frames[t] = e, this.drawOrders[t] = i
    },
    apply: function(t, e, i, n, s) {
        var r = this.frames;
        if (!(i < r[0])) {
            var o;
            o = i >= r[r.length - 1] ? r.length - 1 : spine.Animation.binarySearch1(r, i) - 1;
            var a = t.drawOrder,
                h = t.slots,
                l = this.drawOrders[o];
            if (l)
                for (c = 0, u = l.length; c < u; c++) a[c] = t.slots[l[c]];
            else
                for (var c = 0, u = h.length; c < u; c++) a[c] = h[c]
        }
    }
}, spine.FfdTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(t), this.frames.length = t, this.frameVertices = [], this.frameVertices.length = t
}, spine.FfdTimeline.prototype = {
    slotIndex: 0,
    attachment: 0,
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(t, e, i) {
        this.frames[t] = e, this.frameVertices[t] = i
    },
    apply: function(t, e, i, n, s) {
        var r = t.slots[this.slotIndex],
            o = r.attachment;
        if (o && (o == this.attachment || o.inheritFFD && o.parentMesh == this.attachment)) {
            var a = this.frames;
            if (!(i < a[0])) {
                var h = this.frameVertices,
                    l = h[0].length,
                    c = r.attachmentVertices;
                if (c.length != l && (r.attachmentVertices = c = new spine.Float32Array(l), s = 1), i >= a[a.length - 1]) {
                    var u = h[a.length - 1];
                    if (s < 1)
                        for (var d = 0; d < l; d++) c[d] += (u[d] - c[d]) * s;
                    else
                        for (d = 0; d < l; d++) c[d] = u[d]
                } else {
                    var p = spine.Animation.binarySearch1(a, i),
                        f = a[p],
                        g = 1 - (i - f) / (a[p - 1] - f);
                    g = this.curves.getCurvePercent(p - 1, g < 0 ? 0 : g > 1 ? 1 : g);
                    var m = h[p - 1],
                        y = h[p];
                    if (s < 1)
                        for (d = 0; d < l; d++) {
                            var v = m[d];
                            c[d] += (v + (y[d] - v) * g - c[d]) * s
                        } else
                            for (d = 0; d < l; d++) {
                                v = m[d];
                                c[d] = v + (y[d] - v) * g
                            }
                }
            }
        }
    }
}, spine.IkConstraintTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), this.frames.length = 3 * t
}, spine.IkConstraintTimeline.prototype = {
    ikConstraintIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(t, e, i, n) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = n
    },
    apply: function(t, e, i, n, s) {
        var r = this.frames;
        if (!(i < r[0])) {
            var o = t.ikConstraints[this.ikConstraintIndex];
            if (i >= r[r.length - 3]) return o.mix += (r[r.length - 2] - o.mix) * s, void(o.bendDirection = r[r.length - 1]);
            var a = spine.Animation.binarySearch(r, i, 3),
                h = r[a + -2],
                l = r[a],
                c = 1 - (i - l) / (r[a + -3] - l);
            c = this.curves.getCurvePercent(a / 3 - 1, c);
            var u = h + (r[a + 1] - h) * c;
            o.mix += (u - o.mix) * s, o.bendDirection = r[a + -1]
        }
    }
}, spine.SkeletonData = function() {
    this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], this.ikConstraints = [], this.transformConstraints = []
}, spine.SkeletonData.prototype = {
    name: null,
    defaultSkin: null,
    width: 0,
    height: 0,
    version: null,
    hash: null,
    findBone: function(t) {
        for (var e = this.bones, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findBoneIndex: function(t) {
        for (var e = this.bones, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return i;
        return -1
    },
    findSlot: function(t) {
        for (var e = this.slots, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return slot[i];
        return null
    },
    findSlotIndex: function(t) {
        for (var e = this.slots, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return i;
        return -1
    },
    findSkin: function(t) {
        for (var e = this.skins, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findEvent: function(t) {
        for (var e = this.events, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findAnimation: function(t) {
        for (var e = this.animations, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findIkConstraint: function(t) {
        for (var e = this.ikConstraints, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findTransformConstraints: function(t) {
        for (var e = this.transformConstraints, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return e[i];
        return null
    }
}, spine.Skeleton = function(t) {
    this.data = t, this.bones = [];
    for (var e = 0, i = t.bones.length; e < i; e++) {
        var n = t.bones[e],
            s = n.parent ? this.bones[t.bones.indexOf(n.parent)] : null;
        this.bones[e] = new spine.Bone(n, this, s)
    }
    this.slots = [], this.drawOrder = [];
    for (e = 0, i = t.slots.length; e < i; e++) {
        var r = t.slots[e],
            o = this.bones[t.bones.indexOf(r.boneData)],
            a = new spine.Slot(r, o);
        this.slots[e] = a, this.drawOrder[e] = a
    }
    this.ikConstraints = [];
    for (e = 0, i = t.ikConstraints.length; e < i; e++) this.ikConstraints[e] = new spine.IkConstraint(t.ikConstraints[e], this);
    this.transformConstraints = [];
    for (e = 0, i = t.transformConstraints.length; e < i; e++) this.transformConstraints[e] = new spine.TransformConstraint(t.transformConstraints[e], this);
    this.cache = [], this.updateCache()
}, spine.Skeleton.prototype = {
    x: 0,
    y: 0,
    skin: null,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    time: 0,
    flipX: !1,
    flipY: !1,
    updateCache: function() {
        var t = this.bones,
            e = this.cache,
            i = this.ikConstraints,
            n = this.transformConstraints,
            s = i.length,
            r = n.length;
        e.length = 0;
        for (var o = 0, a = t.length; o < a; o++) {
            var h = t[o];
            e[e.length] = h;
            for (var l = 0; l < s; l++) {
                var c = i[l];
                if (h == c.bones[c.bones.length - 1]) {
                    e[e.length] = c;
                    break
                }
            }
        }
        for (o = 0; o < r; o++) {
            var u = n[o];
            for (l = e.length - 1; l >= 0; l--) {
                var d = e[l];
                if (d == u.bone || d == u.target) {
                    e.splice(l + 1, 0, u);
                    break
                }
            }
        }
    },
    updateWorldTransform: function() {
        for (var t = this.cache, e = 0, i = t.length; e < i; e++) t[e].update()
    },
    setToSetupPose: function() {
        this.setBonesToSetupPose(), this.setSlotsToSetupPose()
    },
    setBonesToSetupPose: function() {
        for (var t = this.bones, e = 0, i = t.length; e < i; e++) t[e].setToSetupPose();
        var n = this.ikConstraints;
        for (e = 0, i = n.length; e < i; e++) {
            (r = n[e]).bendDirection = r.data.bendDirection, r.mix = r.data.mix
        }
        var s = this.transformConstraints;
        for (e = 0, i = s.length; e < i; e++) {
            var r;
            (r = s[e]).translateMix = r.data.translateMix, r.x = r.data.x, r.y = r.data.y
        }
    },
    setSlotsToSetupPose: function() {
        for (var t = this.slots, e = this.drawOrder, i = 0, n = t.length; i < n; i++) e[i] = t[i], t[i].setToSetupPose(i)
    },
    getRootBone: function() {
        return this.bones.length ? this.bones[0] : null
    },
    findBone: function(t) {
        for (var e = this.bones, i = 0, n = e.length; i < n; i++)
            if (e[i].data.name == t) return e[i];
        return null
    },
    findBoneIndex: function(t) {
        for (var e = this.bones, i = 0, n = e.length; i < n; i++)
            if (e[i].data.name == t) return i;
        return -1
    },
    findSlot: function(t) {
        for (var e = this.slots, i = 0, n = e.length; i < n; i++)
            if (e[i].data.name == t) return e[i];
        return null
    },
    findSlotIndex: function(t) {
        for (var e = this.slots, i = 0, n = e.length; i < n; i++)
            if (e[i].data.name == t) return i;
        return -1
    },
    setSkinByName: function(t) {
        var e = this.data.findSkin(t);
        if (!e) throw "Skin not found: " + t;
        this.setSkin(e)
    },
    setSkin: function(t) {
        if (t)
            if (this.skin) t._attachAll(this, this.skin);
            else
                for (var e = this.slots, i = 0, n = e.length; i < n; i++) {
                    var s = e[i],
                        r = s.data.attachmentName;
                    if (r) {
                        var o = t.getAttachment(i, r);
                        o && s.setAttachment(o)
                    }
                }
        this.skin = t
    },
    getAttachmentBySlotName: function(t, e) {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(t), e)
    },
    getAttachmentBySlotIndex: function(t, e) {
        if (this.skin) {
            var i = this.skin.getAttachment(t, e);
            if (i) return i
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
    },
    setAttachment: function(t, e) {
        for (var i = this.slots, n = 0, s = i.length; n < s; n++) {
            var r = i[n];
            if (r.data.name == t) {
                var o = null;
                if (e && !(o = this.getAttachmentBySlotIndex(n, e))) throw "Attachment not found: " + e + ", for slot: " + t;
                return void r.setAttachment(o)
            }
        }
        throw "Slot not found: " + t
    },
    findIkConstraint: function(t) {
        for (var e = this.ikConstraints, i = 0, n = e.length; i < n; i++)
            if (e[i].data.name == t) return e[i];
        return null
    },
    findTransformConstraint: function(t) {
        for (var e = this.transformConstraints, i = 0, n = e.length; i < n; i++)
            if (e[i].data.name == t) return e[i];
        return null
    },
    update: function(t) {
        this.time += t
    }
}, spine.EventData = function(t) {
    this.name = t
}, spine.EventData.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.Event = function(t, e) {
    this.time = t, this.data = e
}, spine.Event.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.AttachmentType = {
    region: 0,
    boundingbox: 1,
    mesh: 2,
    weightedmesh: 3,
    linkedmesh: 4,
    weightedlinkedmesh: 5
}, spine.RegionAttachment = function(t) {
    this.name = t, this.offset = new spine.Float32Array(8), this.offset.length = 8, this.uvs = new spine.Float32Array(8), this.uvs.length = 8
}, spine.RegionAttachment.prototype = {
    type: spine.AttachmentType.region,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    width: 0,
    height: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    rendererObject: null,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    setUVs: function(t, e, i, n, s) {
        var r = this.uvs;
        s ? (r[2] = t, r[3] = n, r[4] = t, r[5] = e, r[6] = i, r[7] = e, r[0] = i, r[1] = n) : (r[0] = t, r[1] = n, r[2] = t, r[3] = e, r[4] = i, r[5] = e, r[6] = i, r[7] = n)
    },
    updateOffset: function() {
        var t = this.width / this.regionOriginalWidth * this.scaleX,
            e = this.height / this.regionOriginalHeight * this.scaleY,
            i = -this.width / 2 * this.scaleX + this.regionOffsetX * t,
            n = -this.height / 2 * this.scaleY + this.regionOffsetY * e,
            s = i + this.regionWidth * t,
            r = n + this.regionHeight * e,
            o = this.rotation * spine.degRad,
            a = Math.cos(o),
            h = Math.sin(o),
            l = i * a + this.x,
            c = i * h,
            u = n * a + this.y,
            d = n * h,
            p = s * a + this.x,
            f = s * h,
            g = r * a + this.y,
            m = r * h,
            y = this.offset;
        y[0] = l - d, y[1] = u + c, y[2] = l - m, y[3] = g + c, y[4] = p - m, y[5] = g + f, y[6] = p - d, y[7] = u + f
    },
    computeVertices: function(t, e, i, n) {
        t += i.worldX, e += i.worldY;
        var s = i.a,
            r = i.b,
            o = i.c,
            a = i.d,
            h = this.offset;
        n[0] = h[0] * s + h[1] * r + t, n[1] = h[0] * o + h[1] * a + e, n[2] = h[2] * s + h[3] * r + t, n[3] = h[2] * o + h[3] * a + e, n[4] = h[4] * s + h[5] * r + t, n[5] = h[4] * o + h[5] * a + e, n[6] = h[6] * s + h[7] * r + t, n[7] = h[6] * o + h[7] * a + e
    }
}, spine.MeshAttachment = function(t) {
    this.name = t
}, spine.MeshAttachment.prototype = {
    type: spine.AttachmentType.mesh,
    vertices: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function() {
        var t = this.regionU2 - this.regionU,
            e = this.regionV2 - this.regionV,
            i = this.regionUVs.length;
        if (this.uvs && this.uvs.length == i || (this.uvs = new spine.Float32Array(i)), this.regionRotate)
            for (var n = 0; n < i; n += 2) this.uvs[n] = this.regionU + this.regionUVs[n + 1] * t, this.uvs[n + 1] = this.regionV + e - this.regionUVs[n] * e;
        else
            for (n = 0; n < i; n += 2) this.uvs[n] = this.regionU + this.regionUVs[n] * t, this.uvs[n + 1] = this.regionV + this.regionUVs[n + 1] * e
    },
    computeWorldVertices: function(t, e, i, n) {
        var s = i.bone;
        t += s.worldX, e += s.worldY;
        var r = s.a,
            o = s.b,
            a = s.c,
            h = s.d,
            l = this.vertices,
            c = l.length;
        i.attachmentVertices.length == c && (l = i.attachmentVertices);
        for (var u = 0; u < c; u += 2) {
            var d = l[u],
                p = l[u + 1];
            n[u] = d * r + p * o + t, n[u + 1] = d * a + p * h + e
        }
    },
    setParentMesh: function(t) {
        this.parentMesh = t, t && (this.vertices = t.vertices, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.edges = t.edges, this.width = t.width, this.height = t.height)
    }
}, spine.WeightedMeshAttachment = function(t) {
    this.name = t
}, spine.WeightedMeshAttachment.prototype = {
    type: spine.AttachmentType.weightedmesh,
    bones: null,
    weights: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function(t, e, i, n, s) {
        var r = this.regionU2 - this.regionU,
            o = this.regionV2 - this.regionV,
            a = this.regionUVs.length;
        if (this.uvs && this.uvs.length == a || (this.uvs = new spine.Float32Array(a)), this.regionRotate)
            for (var h = 0; h < a; h += 2) this.uvs[h] = this.regionU + this.regionUVs[h + 1] * r, this.uvs[h + 1] = this.regionV + o - this.regionUVs[h] * o;
        else
            for (h = 0; h < a; h += 2) this.uvs[h] = this.regionU + this.regionUVs[h] * r, this.uvs[h + 1] = this.regionV + this.regionUVs[h + 1] * o
    },
    computeWorldVertices: function(t, e, i, n) {
        var s, r, o, a, h, l, c, u = i.bone.skeleton.bones,
            d = this.weights,
            p = this.bones,
            f = 0,
            g = 0,
            m = 0,
            y = 0,
            v = p.length;
        if (i.attachmentVertices.length)
            for (var b = i.attachmentVertices; g < v; f += 2) {
                for (r = 0, o = 0, s = p[g++] + g; g < s; g++, m += 3, y += 2) a = u[p[g]], h = d[m] + b[y], l = d[m + 1] + b[y + 1], c = d[m + 2], r += (h * a.a + l * a.b + a.worldX) * c, o += (h * a.c + l * a.d + a.worldY) * c;
                n[f] = r + t, n[f + 1] = o + e
            } else
                for (; g < v; f += 2) {
                    for (r = 0, o = 0, s = p[g++] + g; g < s; g++, m += 3) a = u[p[g]], h = d[m], l = d[m + 1], c = d[m + 2], r += (h * a.a + l * a.b + a.worldX) * c, o += (h * a.c + l * a.d + a.worldY) * c;
                    n[f] = r + t, n[f + 1] = o + e
                }
    },
    setParentMesh: function(t) {
        this.parentMesh = t, t && (this.bones = t.bones, this.weights = t.weights, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.edges = t.edges, this.width = t.width, this.height = t.height)
    }
}, spine.BoundingBoxAttachment = function(t) {
    this.name = t, this.vertices = new spine.Float32Array
}, spine.BoundingBoxAttachment.prototype = {
    type: spine.AttachmentType.boundingbox,
    computeWorldVertices: function(t, e, i, n) {
        t += i.worldX, e += i.worldY;
        for (var s = i.a, r = i.b, o = i.c, a = i.d, h = this.vertices, l = 0, c = h.length; l < c; l += 2) {
            var u = h[l],
                d = h[l + 1];
            n[l] = u * s + d * r + t, n[l + 1] = u * o + d * a + e
        }
    }
}, spine.AnimationStateData = function(t) {
    this.skeletonData = t, this.animationToMixTime = {}
}, spine.AnimationStateData.prototype = {
    defaultMix: 0,
    setMixByName: function(t, e, i) {
        var n = this.skeletonData.findAnimation(t);
        if (!n) throw "Animation not found: " + t;
        var s = this.skeletonData.findAnimation(e);
        if (!s) throw "Animation not found: " + e;
        this.setMix(n, s, i)
    },
    setMix: function(t, e, i) {
        this.animationToMixTime[t.name + ":" + e.name] = i
    },
    getMix: function(t, e) {
        var i = t.name + ":" + e.name;
        return this.animationToMixTime.hasOwnProperty(i) ? this.animationToMixTime[i] : this.defaultMix
    }
}, spine.TrackEntry = function() {}, spine.TrackEntry.prototype = {
    next: null,
    previous: null,
    animation: null,
    loop: !1,
    delay: 0,
    time: 0,
    lastTime: -1,
    endTime: 0,
    timeScale: 1,
    mixTime: 0,
    mixDuration: 0,
    mix: 1,
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null
}, spine.AnimationState = function(t) {
    this.data = t, this.tracks = [], this.events = []
}, spine.AnimationState.prototype = {
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null,
    timeScale: 1,
    update: function(t) {
        t *= this.timeScale;
        for (var e = 0; e < this.tracks.length; e++) {
            var i = this.tracks[e];
            if (i) {
                if (i.time += t * i.timeScale, i.previous) {
                    var n = t * i.previous.timeScale;
                    i.previous.time += n, i.mixTime += n
                }
                var s = i.next;
                s ? (s.time = i.lastTime - s.delay, s.time >= 0 && this.setCurrent(e, s)) : !i.loop && i.lastTime >= i.endTime && this.clearTrack(e)
            }
        }
    },
    apply: function(t) {
        for (var e = 0; e < this.tracks.length; e++) {
            var i = this.tracks[e];
            if (i) {
                this.events.length = 0;
                var n = i.time,
                    s = i.lastTime,
                    r = i.endTime,
                    o = i.loop;
                !o && n > r && (n = r);
                var a = i.previous;
                if (a) {
                    var h = a.time;
                    !a.loop && h > a.endTime && (h = a.endTime), a.animation.apply(t, h, h, a.loop, null);
                    var l = i.mixTime / i.mixDuration * i.mix;
                    l >= 1 && (l = 1, i.previous = null), i.animation.mix(t, i.lastTime, n, o, this.events, l)
                } else 1 == i.mix ? i.animation.apply(t, i.lastTime, n, o, this.events) : i.animation.mix(t, i.lastTime, n, o, this.events, i.mix);
                for (var c = 0, u = this.events.length; c < u; c++) {
                    var d = this.events[c];
                    i.onEvent && i.onEvent(e, d), this.onEvent && this.onEvent(e, d)
                }
                if (o ? s % r > n % r : s < r && n >= r) {
                    var p = Math.floor(n / r);
                    i.onComplete && i.onComplete(e, p), this.onComplete && this.onComplete(e, p)
                }
                i.lastTime = i.time
            }
        }
    },
    clearTracks: function() {
        for (var t = 0, e = this.tracks.length; t < e; t++) this.clearTrack(t);
        this.tracks.length = 0
    },
    clearTrack: function(t) {
        if (!(t >= this.tracks.length)) {
            var e = this.tracks[t];
            e && (e.onEnd && e.onEnd(t), this.onEnd && this.onEnd(t), this.tracks[t] = null)
        }
    },
    _expandToIndex: function(t) {
        if (t < this.tracks.length) return this.tracks[t];
        for (; t >= this.tracks.length;) this.tracks[this.tracks.length] = null;
        return null
    },
    setCurrent: function(t, e) {
        var i = this._expandToIndex(t);
        if (i) {
            var n = i.previous;
            i.previous = null, i.onEnd && i.onEnd(t), this.onEnd && this.onEnd(t), e.mixDuration = this.data.getMix(i.animation, e.animation), e.mixDuration > 0 && (e.mixTime = 0, n && i.mixTime / i.mixDuration < .5 ? e.previous = n : e.previous = i)
        }
        this.tracks[t] = e, e.onStart && e.onStart(t), this.onStart && this.onStart(t)
    },
    setAnimationByName: function(t, e, i) {
        var n = this.data.skeletonData.findAnimation(e);
        if (!n) throw "Animation not found: " + e;
        return this.setAnimation(t, n, i)
    },
    setAnimation: function(t, e, i) {
        var n = new spine.TrackEntry;
        return n.animation = e, n.loop = i, n.endTime = e.duration, this.setCurrent(t, n), n
    },
    addAnimationByName: function(t, e, i, n) {
        var s = this.data.skeletonData.findAnimation(e);
        if (!s) throw "Animation not found: " + e;
        return this.addAnimation(t, s, i, n)
    },
    addAnimation: function(t, e, i, n) {
        var s = new spine.TrackEntry;
        s.animation = e, s.loop = i, s.endTime = e.duration;
        var r = this._expandToIndex(t);
        if (r) {
            for (; r.next;) r = r.next;
            r.next = s
        } else this.tracks[t] = s;
        return n <= 0 && (r ? n += r.endTime - this.data.getMix(r.animation, e) : n = 0), s.delay = n, s
    },
    getCurrent: function(t) {
        return t >= this.tracks.length ? null : this.tracks[t]
    }
}, spine.SkeletonJson = function(t) {
    this.attachmentLoader = t, this.linkedMeshes = []
}, spine.SkeletonJson.prototype = {
    scale: 1,
    readSkeletonData: function(t, e) {
        var i = new spine.SkeletonData;
        i.name = e;
        var n = t.skeleton;
        n && (i.hash = n.hash, i.version = n.spine, i.width = n.width || 0, i.height = n.height || 0);
        for (var s = 0, r = (l = t.bones).length; s < r; s++) {
            var o = l[s],
                a = null;
            if (o.parent && !(a = i.findBone(o.parent))) throw "Parent bone not found: " + o.parent;
            (b = new spine.BoneData(o.name, a)).length = (o.length || 0) * this.scale, b.x = (o.x || 0) * this.scale, b.y = (o.y || 0) * this.scale, b.rotation = o.rotation || 0, b.scaleX = o.hasOwnProperty("scaleX") ? o.scaleX : 1, b.scaleY = o.hasOwnProperty("scaleY") ? o.scaleY : 1, b.inheritScale = !o.hasOwnProperty("inheritScale") || o.inheritScale, b.inheritRotation = !o.hasOwnProperty("inheritRotation") || o.inheritRotation, i.bones[s] = b
        }
        var h = t.ik;
        if (h)
            for (s = 0, r = h.length; s < r; s++) {
                for (var l, c = h[s], u = new spine.IkConstraintData(c.name), d = 0, p = (l = c.bones).length; d < p; d++) {
                    var f = i.findBone(l[d]);
                    if (!f) throw "IK bone not found: " + l[d];
                    u.bones[d] = f
                }
                if (u.target = i.findBone(c.target), !u.target) throw "Target bone not found: " + c.target;
                u.bendDirection = !c.hasOwnProperty("bendPositive") || c.bendPositive ? 1 : -1, u.mix = c.hasOwnProperty("mix") ? c.mix : 1, i.ikConstraints[s] = u
            }
        var g = t.transform;
        if (g)
            for (s = 0, r = g.length; s < r; s++) {
                var m = g[s],
                    y = new spine.TransformConstraintData(m.name);
                if (y.bone = i.findBone(m.bone), !y.bone) throw "Bone not found: " + m.bone;
                if (y.target = i.findBone(m.target), !y.target) throw "Target bone not found: " + m.target;
                y.mix = m.hasOwnProperty("translateMix") ? c.translateMix : 1, y.x = (m.x || 0) * this.scale, y.y = (m.y || 0) * this.scale, i.transformConstraints[s] = y
            }
        var v = t.slots;
        for (s = 0, r = v.length; s < r; s++) {
            var b, x = v[s];
            if (!(b = i.findBone(x.bone))) throw "Slot bone not found: " + x.bone;
            var w = new spine.SlotData(x.name, b),
                _ = x.color;
            _ && (w.r = this.toColor(_, 0), w.g = this.toColor(_, 1), w.b = this.toColor(_, 2), w.a = this.toColor(_, 3)), w.attachmentName = x.attachment, w.blendMode = spine.BlendMode[x.blend || "normal"], i.slots[s] = w
        }
        var P = t.skins;
        for (var T in P)
            if (P.hasOwnProperty(T)) {
                var S = P[T],
                    C = new spine.Skin(T);
                for (var A in S)
                    if (S.hasOwnProperty(A)) {
                        var E = i.findSlotIndex(A),
                            M = S[A];
                        for (var I in M)
                            if (M.hasOwnProperty(I)) {
                                var O = this.readAttachment(C, E, I, M[I]);
                                O && C.addAttachment(E, I, O)
                            }
                    }
                i.skins[i.skins.length] = C, "default" == C.name && (i.defaultSkin = C)
            }
        for (s = 0, r = this.linkedMeshes.length; s < r; s++) {
            var k = this.linkedMeshes[s];
            if (!(C = k.skin ? i.findSkin(k.skin) : i.defaultSkin)) throw "Skin not found: " + k.skin;
            if (!(a = C.getAttachment(k.slotIndex, k.parent))) throw "Parent mesh not found: " + k.parent;
            k.mesh.setParentMesh(a), k.mesh.updateUVs()
        }
        this.linkedMeshes.length = 0;
        var R = t.events;
        for (var L in R)
            if (R.hasOwnProperty(L)) {
                var B = R[L],
                    F = new spine.EventData(L);
                F.intValue = B.int || 0, F.floatValue = B.float || 0, F.stringValue = B.string || null, i.events[i.events.length] = F
            }
        var D = t.animations;
        for (var U in D) D.hasOwnProperty(U) && this.readAnimation(U, D[U], i);
        return i
    },
    readAttachment: function(t, e, i, n) {
        i = n.name || i;
        var s = n.type || "region";
        "skinnedmesh" == s && (s = "weightedmesh"), s = spine.AttachmentType[s];
        var r = n.path || i,
            o = this.scale;
        switch (s) {
            case spine.AttachmentType.region:
                var a = this.attachmentLoader.newRegionAttachment(t, i, r);
                if (!a) return null;
                a.path = r, a.x = (n.x || 0) * o, a.y = (n.y || 0) * o, a.scaleX = n.hasOwnProperty("scaleX") ? n.scaleX : 1, a.scaleY = n.hasOwnProperty("scaleY") ? n.scaleY : 1, a.rotation = n.rotation || 0, a.width = (n.width || 0) * o, a.height = (n.height || 0) * o;
                var h = n.color;
                return h && (a.r = this.toColor(h, 0), a.g = this.toColor(h, 1), a.b = this.toColor(h, 2), a.a = this.toColor(h, 3)), a.updateOffset(), a;
            case spine.AttachmentType.mesh:
            case spine.AttachmentType.linkedmesh:
                return (l = this.attachmentLoader.newMeshAttachment(t, i, r)) ? (l.path = r, (h = n.color) && (l.r = this.toColor(h, 0), l.g = this.toColor(h, 1), l.b = this.toColor(h, 2), l.a = this.toColor(h, 3)), l.width = (n.width || 0) * o, l.height = (n.height || 0) * o, n.parent ? (l.inheritFFD = !n.hasOwnProperty("ffd") || n.ffd, this.linkedMeshes[this.linkedMeshes.length] = {
                    mesh: l,
                    skin: n.skin,
                    slotIndex: e,
                    parent: n.parent
                }) : (l.vertices = this.getFloatArray(n, "vertices", o), l.triangles = this.getUint32Array(n, "triangles"), l.regionUVs = this.getFloatArray(n, "uvs", 1), l.updateUVs(), l.hullLength = 2 * (n.hull || 0), n.edges && (l.edges = this.getUint16Array(n, "edges"))), l) : null;
            case spine.AttachmentType.weightedmesh:
            case spine.AttachmentType.weightedlinkedmesh:
                var l;
                if (!(l = this.attachmentLoader.newWeightedMeshAttachment(t, i, r))) return null;
                if (l.path = r, (h = n.color) && (l.r = this.toColor(h, 0), l.g = this.toColor(h, 1), l.b = this.toColor(h, 2), l.a = this.toColor(h, 3)), l.width = (n.width || 0) * o, l.height = (n.height || 0) * o, n.parent) l.inheritFFD = !n.hasOwnProperty("ffd") || n.ffd, this.linkedMeshes[this.linkedMeshes.length] = {
                    mesh: l,
                    skin: n.skin,
                    slotIndex: e,
                    parent: n.parent
                };
                else {
                    for (var c = this.getFloatArray(n, "uvs", 1), u = this.getFloatArray(n, "vertices", 1), d = new spine.Float32Array(3 * c.length * 3), p = new spine.Uint32Array(3 * c.length), f = 0, g = 0, m = 0, y = u.length; f < y;) {
                        var v = 0 | u[f++];
                        p[g++] = v;
                        for (var b = f + 4 * v; f < b;) p[g++] = u[f], d[m++] = u[f + 1] * o, d[m++] = u[f + 2] * o, d[m++] = u[f + 3], f += 4
                    }
                    l.bones = p, l.weights = d, l.triangles = this.getUint32Array(n, "triangles"), l.regionUVs = c, l.updateUVs(), l.hullLength = 2 * (n.hull || 0), n.edges && (l.edges = this.getUint16Array(n, "edges"))
                }
                return l;
            case spine.AttachmentType.boundingbox:
                var x = this.attachmentLoader.newBoundingBoxAttachment(t, i);
                u = n.vertices;
                x.vertices = new spine.Float32Array(u.length);
                for (f = 0, y = u.length; f < y; f++) x.vertices[f] = u[f] * o;
                return x
        }
        throw "Unknown attachment type: " + s
    },
    readAnimation: function(t, e, i) {
        var n = [],
            s = 0,
            r = e.slots;
        for (var o in r)
            if (r.hasOwnProperty(o)) {
                var a = r[o],
                    h = i.findSlotIndex(o);
                for (var l in a)
                    if (a.hasOwnProperty(l)) {
                        var c = a[l];
                        if ("color" == l) {
                            (D = new spine.ColorTimeline(c.length)).slotIndex = h;
                            for (var u = 0, d = 0, p = c.length; d < p; d++) {
                                var f = (b = c[d]).color,
                                    g = this.toColor(f, 0),
                                    m = this.toColor(f, 1),
                                    y = this.toColor(f, 2),
                                    v = this.toColor(f, 3);
                                D.setFrame(u, b.time, g, m, y, v), this.readCurve(D, u, b), u++
                            }
                            n[n.length] = D, s = Math.max(s, D.frames[5 * D.getFrameCount() - 5])
                        } else {
                            if ("attachment" != l) throw "Invalid timeline type for a slot: " + l + " (" + o + ")";
                            (D = new spine.AttachmentTimeline(c.length)).slotIndex = h;
                            for (u = 0, d = 0, p = c.length; d < p; d++) {
                                var b = c[d];
                                D.setFrame(u++, b.time, b.name)
                            }
                            n[n.length] = D, s = Math.max(s, D.frames[D.getFrameCount() - 1])
                        }
                    }
            }
        var x = e.bones;
        for (var w in x)
            if (x.hasOwnProperty(w)) {
                var _ = i.findBoneIndex(w);
                if (-1 == _) throw "Bone not found: " + w;
                var P = x[w];
                for (var l in P)
                    if (P.hasOwnProperty(l)) {
                        c = P[l];
                        if ("rotate" == l) {
                            (D = new spine.RotateTimeline(c.length)).boneIndex = _;
                            for (u = 0, d = 0, p = c.length; d < p; d++) {
                                b = c[d];
                                D.setFrame(u, b.time, b.angle), this.readCurve(D, u, b), u++
                            }
                            n[n.length] = D, s = Math.max(s, D.frames[2 * D.getFrameCount() - 2])
                        } else {
                            if ("translate" != l && "scale" != l) throw "Invalid timeline type for a bone: " + l + " (" + w + ")";
                            var T = 1;
                            "scale" == l ? D = new spine.ScaleTimeline(c.length) : (D = new spine.TranslateTimeline(c.length), T = this.scale), D.boneIndex = _;
                            for (u = 0, d = 0, p = c.length; d < p; d++) {
                                var S = ((b = c[d]).x || 0) * T,
                                    C = (b.y || 0) * T;
                                D.setFrame(u, b.time, S, C), this.readCurve(D, u, b), u++
                            }
                            n[n.length] = D, s = Math.max(s, D.frames[3 * D.getFrameCount() - 3])
                        }
                    }
            }
        var A = e.ik;
        for (var E in A)
            if (A.hasOwnProperty(E)) {
                var M = i.findIkConstraint(E);
                c = A[E];
                (D = new spine.IkConstraintTimeline(c.length)).ikConstraintIndex = i.ikConstraints.indexOf(M);
                for (u = 0, d = 0, p = c.length; d < p; d++) {
                    var I = (b = c[d]).hasOwnProperty("mix") ? b.mix : 1,
                        O = !b.hasOwnProperty("bendPositive") || b.bendPositive ? 1 : -1;
                    D.setFrame(u, b.time, I, O), this.readCurve(D, u, b), u++
                }
                n[n.length] = D, s = Math.max(s, D.frames[3 * D.getFrameCount() - 3])
            }
        var k = e.ffd;
        for (var R in k) {
            var L = i.findSkin(R);
            a = k[R];
            for (o in a) {
                h = i.findSlotIndex(o);
                var B = a[o];
                for (var F in B) {
                    c = B[F];
                    var D = new spine.FfdTimeline(c.length),
                        U = L.getAttachment(h, F);
                    if (!U) throw "FFD attachment not found: " + F;
                    D.slotIndex = h, D.attachment = U;
                    var G, N = U.type == spine.AttachmentType.mesh;
                    G = N ? U.vertices.length : U.weights.length / 3 * 2;
                    for (u = 0, d = 0, p = c.length; d < p; d++) {
                        if ((b = c[d]).vertices) {
                            var X, j = b.vertices;
                            (X = new spine.Float32Array(G)).length = G;
                            var W = b.offset || 0,
                                V = j.length;
                            if (1 == this.scale)
                                for (var Y = 0; Y < V; Y++) X[Y + W] = j[Y];
                            else
                                for (Y = 0; Y < V; Y++) X[Y + W] = j[Y] * this.scale;
                            if (N) {
                                var H = U.vertices;
                                for (Y = 0, V = X.length; Y < V; Y++) X[Y] += H[Y]
                            }
                        } else N ? X = U.vertices : (X = new spine.Float32Array(G)).length = G;
                        D.setFrame(u, b.time, X), this.readCurve(D, u, b), u++
                    }
                    n[n.length] = D, s = Math.max(s, D.frames[D.getFrameCount() - 1])
                }
            }
        }
        var q = e.drawOrder;
        if (q || (q = e.draworder), q) {
            D = new spine.DrawOrderTimeline(q.length);
            var z = i.slots.length;
            for (u = 0, d = 0, p = q.length; d < p; d++) {
                var K = q[d],
                    J = null;
                if (K.offsets) {
                    (J = new spine.Uint32Array(z)).length = z;
                    for (Y = z - 1; Y >= 0; Y--) J[Y] = 4294967295;
                    var Q = K.offsets,
                        Z = new spine.Uint32Array(z - Q.length);
                    Z.length = z - Q.length;
                    var $ = 0,
                        tt = 0;
                    for (Y = 0, V = Q.length; Y < V; Y++) {
                        var et = Q[Y];
                        if (-1 == (h = i.findSlotIndex(et.slot))) throw "Slot not found: " + et.slot;
                        for (; $ != h;) Z[tt++] = $++;
                        J[$ + et.offset] = $++
                    }
                    for (; $ < z;) Z[tt++] = $++;
                    for (Y = z - 1; Y >= 0; Y--) 4294967295 == J[Y] && (J[Y] = Z[--tt])
                }
                D.setFrame(u++, K.time, J)
            }
            n[n.length] = D, s = Math.max(s, D.frames[D.getFrameCount() - 1])
        }
        var it = e.events;
        if (it) {
            for (D = new spine.EventTimeline(it.length), u = 0, d = 0, p = it.length; d < p; d++) {
                var nt = it[d],
                    st = i.findEvent(nt.name);
                if (!st) throw "Event not found: " + nt.name;
                var rt = new spine.Event(nt.time, st);
                rt.intValue = nt.hasOwnProperty("int") ? nt.int : st.intValue, rt.floatValue = nt.hasOwnProperty("float") ? nt.float : st.floatValue, rt.stringValue = nt.hasOwnProperty("string") ? nt.string : st.stringValue, D.setFrame(u++, rt)
            }
            n[n.length] = D, s = Math.max(s, D.frames[D.getFrameCount() - 1])
        }
        i.animations[i.animations.length] = new spine.Animation(t, n, s)
    },
    readCurve: function(t, e, i) {
        var n = i.curve;
        n ? "stepped" == n ? t.curves.setStepped(e) : n instanceof Array && t.curves.setCurve(e, n[0], n[1], n[2], n[3]) : t.curves.setLinear(e)
    },
    toColor: function(t, e) {
        if (8 != t.length) throw "Color hexidecimal length must be 8, recieved: " + t;
        return parseInt(t.substring(2 * e, 2 * e + 2), 16) / 255
    },
    getFloatArray: function(t, e, i) {
        var n = t[e],
            s = new spine.Float32Array(n.length),
            r = 0,
            o = n.length;
        if (1 == i)
            for (; r < o; r++) s[r] = n[r];
        else
            for (; r < o; r++) s[r] = n[r] * i;
        return s
    },
    getUint32Array: function(t, e) {
        for (var i = t[e], n = new spine.Uint32Array(i.length), s = 0, r = i.length; s < r; s++) n[s] = 0 | i[s];
        return n
    },
    getUint16Array: function(t, e) {
        for (var i = t[e], n = new spine.Uint16Array(i.length), s = 0, r = i.length; s < r; s++) n[s] = 0 | i[s];
        return n
    }
}, spine.Atlas = function(t, e) {
    this.textureLoader = e, this.pages = [], this.regions = [];
    var i = new spine.AtlasReader(t),
        n = [];
    n.length = 4;
    for (var s = null;;) {
        var r = i.readLine();
        if (null === r) break;
        if ((r = i.trim(r)).length)
            if (s) {
                var o = new spine.AtlasRegion;
                o.name = r, o.page = s, o.rotate = "true" == i.readValue(), i.readTuple(n);
                var a = parseInt(n[0]),
                    h = parseInt(n[1]);
                i.readTuple(n);
                var l = parseInt(n[0]),
                    c = parseInt(n[1]);
                o.u = a / s.width, o.v = h / s.height, o.rotate ? (o.u2 = (a + c) / s.width, o.v2 = (h + l) / s.height) : (o.u2 = (a + l) / s.width, o.v2 = (h + c) / s.height), o.x = a, o.y = h, o.width = Math.abs(l), o.height = Math.abs(c), 4 == i.readTuple(n) && (o.splits = [parseInt(n[0]), parseInt(n[1]), parseInt(n[2]), parseInt(n[3])], 4 == i.readTuple(n) && (o.pads = [parseInt(n[0]), parseInt(n[1]), parseInt(n[2]), parseInt(n[3])], i.readTuple(n))), o.originalWidth = parseInt(n[0]), o.originalHeight = parseInt(n[1]), i.readTuple(n), o.offsetX = parseInt(n[0]), o.offsetY = parseInt(n[1]), o.index = parseInt(i.readValue()), this.regions[this.regions.length] = o
            } else {
                (s = new spine.AtlasPage).name = r, 2 == i.readTuple(n) && (s.width = parseInt(n[0]), s.height = parseInt(n[1]), i.readTuple(n)), s.format = spine.Atlas.Format[n[0]], i.readTuple(n), s.minFilter = spine.Atlas.TextureFilter[n[0]], s.magFilter = spine.Atlas.TextureFilter[n[1]];
                var u = i.readValue();
                s.uWrap = spine.Atlas.TextureWrap.clampToEdge, s.vWrap = spine.Atlas.TextureWrap.clampToEdge, "x" == u ? s.uWrap = spine.Atlas.TextureWrap.repeat : "y" == u ? s.vWrap = spine.Atlas.TextureWrap.repeat : "xy" == u && (s.uWrap = s.vWrap = spine.Atlas.TextureWrap.repeat), e.load(s, r, this), this.pages[this.pages.length] = s
            }
        else s = null
    }
}, spine.Atlas.prototype = {
    findRegion: function(t) {
        for (var e = this.regions, i = 0, n = e.length; i < n; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    dispose: function() {
        for (var t = this.pages, e = 0, i = t.length; e < i; e++) this.textureLoader.unload(t[e].rendererObject)
    },
    updateUVs: function(t) {
        for (var e = this.regions, i = 0, n = e.length; i < n; i++) {
            var s = e[i];
            s.page == t && (s.u = s.x / t.width, s.v = s.y / t.height, s.rotate ? (s.u2 = (s.x + s.height) / t.width, s.v2 = (s.y + s.width) / t.height) : (s.u2 = (s.x + s.width) / t.width, s.v2 = (s.y + s.height) / t.height))
        }
    }
}, spine.Atlas.Format = {
    alpha: 0,
    intensity: 1,
    luminanceAlpha: 2,
    rgb565: 3,
    rgba4444: 4,
    rgb888: 5,
    rgba8888: 6
}, spine.Atlas.TextureFilter = {
    nearest: 0,
    linear: 1,
    mipMap: 2,
    mipMapNearestNearest: 3,
    mipMapLinearNearest: 4,
    mipMapNearestLinear: 5,
    mipMapLinearLinear: 6
}, spine.Atlas.TextureWrap = {
    mirroredRepeat: 0,
    clampToEdge: 1,
    repeat: 2
}, spine.AtlasPage = function() {}, spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
}, spine.AtlasRegion = function() {}, spine.AtlasRegion.prototype = {
    page: null,
    name: null,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    u: 0,
    v: 0,
    u2: 0,
    v2: 0,
    offsetX: 0,
    offsetY: 0,
    originalWidth: 0,
    originalHeight: 0,
    index: 0,
    rotate: !1,
    splits: null,
    pads: null
}, spine.AtlasReader = function(t) {
    this.lines = t.split(/\r\n|\r|\n/)
}, spine.AtlasReader.prototype = {
    index: 0,
    trim: function(t) {
        return t.replace(/^\s+|\s+$/g, "")
    },
    readLine: function() {
        return this.index >= this.lines.length ? null : this.lines[this.index++]
    },
    readValue: function() {
        var t = this.readLine(),
            e = t.indexOf(":");
        if (-1 == e) throw "Invalid line: " + t;
        return this.trim(t.substring(e + 1))
    },
    readTuple: function(t) {
        var e = this.readLine(),
            i = e.indexOf(":");
        if (-1 == i) throw "Invalid line: " + e;
        for (var n = 0, s = i + 1; n < 3; n++) {
            var r = e.indexOf(",", s);
            if (-1 == r) break;
            t[n] = this.trim(e.substr(s, r - s)), s = r + 1
        }
        return t[n] = this.trim(e.substring(s)), n + 1
    }
}, spine.AtlasAttachmentLoader = function(t) {
    this.atlas = t
}, spine.AtlasAttachmentLoader.prototype = {
    newRegionAttachment: function(t, e, i) {
        var n = this.atlas.findRegion(i);
        if (!n) throw "Region not found in atlas: " + i + " (region attachment: " + e + ")";
        var s = new spine.RegionAttachment(e);
        return s.rendererObject = n, s.setUVs(n.u, n.v, n.u2, n.v2, n.rotate), s.regionOffsetX = n.offsetX, s.regionOffsetY = n.offsetY, s.regionWidth = n.width, s.regionHeight = n.height, s.regionOriginalWidth = n.originalWidth, s.regionOriginalHeight = n.originalHeight, s
    },
    newMeshAttachment: function(t, e, i) {
        var n = this.atlas.findRegion(i);
        if (!n) throw "Region not found in atlas: " + i + " (mesh attachment: " + e + ")";
        var s = new spine.MeshAttachment(e);
        return s.rendererObject = n, s.regionU = n.u, s.regionV = n.v, s.regionU2 = n.u2, s.regionV2 = n.v2, s.regionRotate = n.rotate, s.regionOffsetX = n.offsetX, s.regionOffsetY = n.offsetY, s.regionWidth = n.width, s.regionHeight = n.height, s.regionOriginalWidth = n.originalWidth, s.regionOriginalHeight = n.originalHeight, s
    },
    newWeightedMeshAttachment: function(t, e, i) {
        var n = this.atlas.findRegion(i);
        if (!n) throw "Region not found in atlas: " + i + " (weighted mesh attachment: " + e + ")";
        var s = new spine.WeightedMeshAttachment(e);
        return s.rendererObject = n, s.regionU = n.u, s.regionV = n.v, s.regionU2 = n.u2, s.regionV2 = n.v2, s.regionRotate = n.rotate, s.regionOffsetX = n.offsetX, s.regionOffsetY = n.offsetY, s.regionWidth = n.width, s.regionHeight = n.height, s.regionOriginalWidth = n.originalWidth, s.regionOriginalHeight = n.originalHeight, s
    },
    newBoundingBoxAttachment: function(t, e) {
        return new spine.BoundingBoxAttachment(e)
    }
}, spine.SkeletonBounds = function() {
    this.polygonPool = [], this.polygons = [], this.boundingBoxes = []
}, spine.SkeletonBounds.prototype = {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0,
    update: function(t, e) {
        var i = t.slots,
            n = i.length,
            s = t.x,
            r = t.y,
            o = this.boundingBoxes,
            a = this.polygonPool,
            h = this.polygons;
        o.length = 0;
        for (var l = 0, c = h.length; l < c; l++) a[a.length] = h[l];
        h.length = 0;
        for (l = 0; l < n; l++) {
            var u = i[l],
                d = u.attachment;
            if (d.type == spine.AttachmentType.boundingbox) {
                o[o.length] = d;
                var p, f = a.length;
                f > 0 ? (p = a[f - 1], a.splice(f - 1, 1)) : p = new spine.Float32Array, h[h.length] = p, p.length = d.vertices.length, d.computeWorldVertices(s, r, u.bone, p)
            }
        }
        e && this.aabbCompute()
    },
    aabbCompute: function() {
        for (var t = this.polygons, e = Number.MAX_VALUE, i = Number.MAX_VALUE, n = -Number.MAX_VALUE, s = -Number.MAX_VALUE, r = 0, o = t.length; r < o; r++)
            for (var a = t[r], h = 0, l = a.length; h < l; h += 2) {
                var c = a[h],
                    u = a[h + 1];
                e = Math.min(e, c), i = Math.min(i, u), n = Math.max(n, c), s = Math.max(s, u)
            }
        this.minX = e, this.minY = i, this.maxX = n, this.maxY = s
    },
    aabbContainsPoint: function(t, e) {
        return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
    },
    aabbIntersectsSegment: function(t, e, i, n) {
        var s = this.minX,
            r = this.minY,
            o = this.maxX,
            a = this.maxY;
        if (t <= s && i <= s || e <= r && n <= r || t >= o && i >= o || e >= a && n >= a) return !1;
        var h = (n - e) / (i - t),
            l = h * (s - t) + e;
        if (l > r && l < a) return !0;
        if ((l = h * (o - t) + e) > r && l < a) return !0;
        var c = (r - e) / h + t;
        return c > s && c < o || (c = (a - e) / h + t) > s && c < o
    },
    aabbIntersectsSkeleton: function(t) {
        return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
    },
    containsPoint: function(t, e) {
        for (var i = this.polygons, n = 0, s = i.length; n < s; n++)
            if (this.polygonContainsPoint(i[n], t, e)) return this.boundingBoxes[n];
        return null
    },
    intersectsSegment: function(t, e, i, n) {
        for (var s = this.polygons, r = 0, o = s.length; r < o; r++)
            if (s[r].intersectsSegment(t, e, i, n)) return this.boundingBoxes[r];
        return null
    },
    polygonContainsPoint: function(t, e, i) {
        for (var n = t.length, s = n - 2, r = !1, o = 0; o < n; o += 2) {
            var a = t[o + 1],
                h = t[s + 1];
            if (a < i && h >= i || h < i && a >= i) {
                var l = t[o];
                l + (i - a) / (h - a) * (t[s] - l) < e && (r = !r)
            }
            s = o
        }
        return r
    },
    polygonIntersectsSegment: function(t, e, i, n, s) {
        for (var r = t.length, o = e - n, a = i - s, h = e * s - i * n, l = t[r - 2], c = t[r - 1], u = 0; u < r; u += 2) {
            var d = t[u],
                p = t[u + 1],
                f = l * p - c * d,
                g = l - d,
                m = c - p,
                y = o * m - a * g,
                v = (h * g - o * f) / y;
            if ((v >= l && v <= d || v >= d && v <= l) && (v >= e && v <= n || v >= n && v <= e)) {
                var b = (h * m - a * f) / y;
                if ((b >= c && b <= p || b >= p && b <= c) && (b >= i && b <= s || b >= s && b <= i)) return !0
            }
            l = d, c = p
        }
        return !1
    },
    getPolygon: function(t) {
        var e = this.boundingBoxes.indexOf(t);
        return -1 == e ? null : this.polygons[e]
    },
    getWidth: function() {
        return this.maxX - this.minX
    },
    getHeight: function() {
        return this.maxY - this.minY
    }
};
var PhaserSpine;
__extends = this && this.__extends || function(t, e) {
    for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);

    function n() {
        this.constructor = t
    }
    t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
};
! function(t) {
    var e = function(e) {
        function i(t, i) {
            var n = e.call(this, t, i) || this;
            return n.addSpineCache(), n.addSpineFactory(), n.addSpineLoader(), n
        }
        return __extends(i, e), i.prototype.addSpineLoader = function() {
            Phaser.Loader.prototype.spine = function(t, e, i) {
                var n = this,
                    s = t + "Atlas",
                    r = {
                        atlas: s,
                        basePath: "" === e.substring(0, e.lastIndexOf("/")) ? "." : e.substring(0, e.lastIndexOf("/")),
                        variants: void 0
                    };
                void 0 === i ? i = [""] : r.variants = i, i.forEach(function(t) {
                    n.onFileComplete.add(function(e, i) {
                        if (i === s) new spine.Atlas(n.game.cache.getText(i), {
                            load: function(e, i, s) {
                                n.image(i, r.basePath + "/" + i.substr(0, i.lastIndexOf(".")) + t + ".png")
                            }
                        })
                    }), n.text(s, e.substr(0, e.lastIndexOf(".")) + t + ".atlas")
                }), this.json(t, e), this.game.cache.addSpine(t, r)
            }
        }, i.prototype.addSpineFactory = function() {
            Phaser.GameObjectFactory.prototype.spine = function(e, i, n, s, r) {
                void 0 === r && (r = this.world);
                var o = new t.Spine(this.game, n, s);
                return o.setToSetupPose(), o.position.x = e, o.position.y = i, r.add(o)
            }, Phaser.GameObjectCreator.prototype.spine = function(e, i, n, s, r) {
                return new t.Spine(this.game, n, s)
            }
        }, i.prototype.addSpineCache = function() {
            Phaser.Cache.prototype.spine = {}, Phaser.Cache.prototype.addSpine = function(t, e) {
                this.spine[t] = e
            }, Phaser.Cache.prototype.getSpine = function(t) {
                return this.spine.hasOwnProperty(t), this.spine[t]
            }
        }, i
    }(Phaser.Plugin);
    e.RESOLUTION_REGEXP = /@(.+)x/, t.SpinePlugin = e
}(PhaserSpine || (PhaserSpine = {})), Phaser.Rope.prototype.postUpdate = function() {}, spine.Bone.yDown = !0,
    function(t) {
        var e = function(e) {
            function i(i, n, s) {
                var r = e.call(this, i) || this;
                r.imageScale = 1;
                var o = r.game.cache.getSpine(n);
                void 0 !== s && -1 !== o.variants.indexOf(s) ? r.imageScale = r.getScaleFromVariant(s) : o.variants && o.variants.length >= 1 && (r.imageScale = r.getScaleFromVariant(o.variants[0]));
                var a = new t.SpineTextureLoader(i),
                    h = new spine.Atlas(i.cache.getText(o.atlas), a),
                    l = new spine.AtlasAttachmentLoader(h),
                    c = new spine.SkeletonJson(l);
                if (r.skeletonData = c.readSkeletonData(i.cache.getJSON(n)), !r.skeletonData) throw new Error("Spine data must be preloaded using Loader.spine");
                r.onEvent = new Phaser.Signal, r.onComplete = new Phaser.Signal, r.onEnd = new Phaser.Signal, r.skeleton = new spine.Skeleton(r.skeletonData), r.skeleton.updateWorldTransform(), r.stateData = new spine.AnimationStateData(r.skeletonData), r.state = new spine.AnimationState(r.stateData), r.state.onEvent = r.onEvent.dispatch.bind(r.onEvent), r.state.onComplete = r.onComplete.dispatch.bind(r.onComplete), r.state.onEnd = r.onEnd.dispatch.bind(r.onEnd), r.slotContainers = [];
                for (var u = 0, d = r.skeleton.slots.length; u < d; u++) {
                    var p = r.skeleton.slots[u],
                        f = p.attachment,
                        g = new Phaser.Group(i);
                    if (r.slotContainers.push(g), r.add(g), f instanceof spine.RegionAttachment) {
                        var m = f.rendererObject.name,
                            y = r.createSprite(p, f);
                        p.currentSprite = y, p.currentSpriteName = m, g.add(y)
                    } else {
                        if (!(f instanceof spine.WeightedMeshAttachment)) continue;
                        var v = r.createMesh(p, f);
                        p.currentMesh = v, p.currentMeshName = f.name, g.add(v)
                    }
                }
                return r.autoUpdate = !0, r
            }
            return __extends(i, e), Object.defineProperty(i.prototype, "autoUpdate", {
                get: function() {
                    return this.updateTransform === t.Spine.prototype.autoUpdateTransform
                },
                set: function(e) {
                    this.updateTransform = e ? t.Spine.prototype.autoUpdateTransform : PIXI.DisplayObjectContainer.prototype.updateTransform
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.getScaleFromVariant = function(e) {
                var i = t.SpinePlugin.RESOLUTION_REGEXP.exec(e);
                return i ? parseFloat(i[1]) : 1
            }, i.prototype.setTint = function(t) {
                this.globalTint = t;
                for (var e = this.skeleton.slots, i = 0; i < e.length; i++) {
                    e[i].currentSprite.tint = t
                }
            }, i.prototype.update = function(t) {
                if (void 0 !== t) {
                    this.state.update(t), this.state.apply(this.skeleton), this.skeleton.updateWorldTransform();
                    for (var e = this.skeleton.drawOrder, i = this.skeleton.slots, n = 0, s = e.length; n < s; n++) void 0 !== e[n].currentSprite && (this.children[n] = e[n].currentSprite.parent);
                    for (n = 0, s = i.length; n < s; n++) {
                        var r = i[n],
                            o = r.attachment,
                            a = this.slotContainers[n];
                        if (o) {
                            var h = o.type;
                            if (h === spine.AttachmentType.region) {
                                if (o.rendererObject && (!r.currentSpriteName || r.currentSpriteName !== o.name)) {
                                    var l = o.rendererObject.name;
                                    if (void 0 !== r.currentSprite && (r.currentSprite.visible = !1), r.sprites = r.sprites || {}, void 0 !== r.sprites[l]) r.sprites[l].visible = !0;
                                    else {
                                        var c = this.createSprite(r, o);
                                        a.add(c)
                                    }
                                    r.currentSprite = r.sprites[l], r.currentSpriteName = l
                                }
                                var u = r.bone;
                                a.position.x = o.x * u.a + o.y * u.b + u.worldX, a.position.y = o.x * u.c + o.y * u.d + u.worldY, a.scale.x = u.getWorldScaleX(), a.scale.y = u.getWorldScaleY(), a.rotation = (u.getWorldRotationX() - o.rotation) * Math.PI / 180, u.getWorldScaleY() < 0 && (a.scale.y = -a.scale.y), u.getWorldScaleX() < 0 && (a.scale.x = -a.scale.x), (u.getWorldScaleY() < 0 || u.getWorldScaleX() < 0) && (a.rotation = -a.rotation), r.currentSprite.blendMode = r.blendMode, this.globalTint || (r.currentSprite.tint = r.currentSprite.tint = parseInt(Phaser.Color.componentToHex(255 * r.r).substring(0, 2) + Phaser.Color.componentToHex(255 * r.g).substring(0, 2) + Phaser.Color.componentToHex(255 * r.b).substring(0, 2), 16))
                            } else {
                                if (h !== spine.AttachmentType.weightedmesh && h !== spine.AttachmentType.weightedlinkedmesh) {
                                    a.visible = !1;
                                    continue
                                }
                                if (!r.currentMeshName || r.currentMeshName !== o.name) {
                                    var d = o.name;
                                    if (void 0 !== r.currentMesh && (r.currentMesh.visible = !1), r.meshes = r.meshes || {}, void 0 !== r.meshes[d]) r.meshes[d].visible = !0;
                                    else {
                                        var p = this.createMesh(r, o);
                                        a.add(p)
                                    }
                                    r.currentMesh = r.meshes[d], r.currentMeshName = d
                                }
                                o.computeWorldVertices(r.bone.skeleton.x, r.bone.skeleton.y, r, r.currentMesh.vertices)
                            }
                            a.visible = !0, a.alpha = r.a
                        } else a.visible = !1
                    }
                }
            }, i.prototype.destroy = function(t, i) {
                e.prototype.destroy.call(this, !0, i)
            }, i.prototype.autoUpdateTransform = function() {
                if (i.globalAutoUpdate) {
                    this.lastTime = this.lastTime || Date.now();
                    var t = .001 * (Date.now() - this.lastTime);
                    this.lastTime = Date.now(), this.update(t)
                } else this.lastTime = 0;
                PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
            }, i.prototype.createSprite = function(t, e) {
                var i = e.rendererObject,
                    n = i.page.rendererObject,
                    s = new PIXI.Rectangle(i.x, i.y, i.rotate ? i.height : i.width, i.rotate ? i.width : i.height),
                    r = new PIXI.Texture(n, s),
                    o = new Phaser.Sprite(this.game, 0, 0, r),
                    a = i.rotate ? .5 * Math.PI : 0;
                if (o.scale.x = i.width / i.originalWidth * e.scaleX / this.imageScale, o.scale.y = i.height / i.originalHeight * e.scaleY / this.imageScale, o.rotation = a, o.anchor.x = (.5 * i.originalWidth - i.offsetX) / i.width, o.anchor.y = 1 - (.5 * i.originalHeight - i.offsetY) / i.height, o.alpha = e.a, i.rotate) {
                    var h = o.scale.x;
                    o.scale.x = o.scale.y, o.scale.y = h
                }
                return t.sprites = t.sprites || {}, t.sprites[i.name] = o, o
            }, i.prototype.createMesh = function(t, e) {
                var i = e.rendererObject.page.rendererObject,
                    n = new PIXI.Texture(i),
                    s = new Phaser.Rope(this.game, 0, 0, n);
                return s.drawMode = 1, s.canvasPadding = 1.5, s.vertices = new spine.Float32Array(e.uvs.length), s.uvs = e.uvs, s.indices = e.triangles, s.alpha = e.a, t.meshes = t.meshes || {}, t.meshes[e.name] = s, s
            }, i.prototype.setMixByName = function(t, e, i) {
                this.stateData.setMixByName(t, e, i)
            }, i.prototype.setAnimationByName = function(t, e, i) {
                void 0 === i && (i = !1);
                var n = this.state.data.skeletonData.findAnimation(e);
                return n ? this.state.setAnimation(t, n, i) : null
            }, i.prototype.addAnimationByName = function(t, e, i, n) {
                void 0 === i && (i = !1), void 0 === n && (n = 0);
                var s = this.state.data.skeletonData.findAnimation(e);
                return s ? this.state.addAnimation(t, s, i, n) : null
            }, i.prototype.getCurrentAnimationForTrack = function(t) {
                return this.state.tracks[t].animation.name
            }, i.prototype.setSkinByName = function(t) {
                var e = this.skeleton.data.findSkin(t);
                e && this.skeleton.setSkin(e)
            }, i.prototype.setSkin = function(t) {
                this.skeleton.setSkin(t)
            }, i.prototype.setToSetupPose = function() {
                this.skeleton.setToSetupPose()
            }, i.prototype.createCombinedSkin = function(t) {
                for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
                if (0 !== e.length) {
                    for (var n = new spine.Skin(t), s = 0; s < e.length; s++) {
                        var r = e[s],
                            o = this.skeleton.data.findSkin(r);
                        if (!o) return;
                        for (var a in o.attachments) {
                            var h = a.split(":"),
                                l = h[0],
                                c = h[1],
                                u = o.attachments[a];
                            if (void 0 === l || void 0 === c) return;
                            void 0 === n.getAttachment(l, c) && n.addAttachment(l, c, u)
                        }
                    }
                    return this.skeleton.data.skins.push(n), n
                }
            }, i
        }(Phaser.Group);
        e.globalAutoUpdate = !0, t.Spine = e
    }(PhaserSpine || (PhaserSpine = {})),
    function(t) {
        var e = function() {
            return function(t) {
                this.load = function(t, e, i) {
                    var n = this.game.make.image(0, 0, e);
                    t.rendererObject = n.texture.baseTexture
                }, this.unload = function(t) {
                    t.destroy()
                }, this.game = t
            }
        }();
        t.SpineTextureLoader = e
    }(PhaserSpine || (PhaserSpine = {}));